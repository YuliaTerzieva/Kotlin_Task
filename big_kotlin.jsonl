{"docstring": " Use this function to indicate that some when branch is semantically unreachable ", "modifier": "", "signature": "fun unreachableBranch(argument: Any?): Nothing", "body": "{<EOL> error(\"This argument should've been processed by previous when branches but it wasn't: $argument\")<EOL>}"}
{"docstring": " Translate exception to unchecked exception Return type is specified to make it possible to use it like this throw ExceptionUtilsrethrowe In this case compiler knows that code after this rethrowing wont be executed ", "modifier": "", "signature": "fun rethrow(e: Throwable): RuntimeException", "body": "{<EOL> throw e<EOL>}"}
{"docstring": " String String AString AString also Ain Nothing Aout Any also A Aout Any different error types nonequals even errorTypeEqualToAnything ", "modifier": "", "signature": "fun strictEqualTypes(a: UnwrappedType, b: UnwrappedType): Boolean", "body": "{<EOL> return AbstractStrictEqualityTypeChecker.strictEqualTypes(SimpleClassicTypeSystemContext, a, b)<EOL> }"}
{"docstring": " return true if any of the types referenced in parameter types including type parameters and extension receiver of the function is an error type Does not check the return type of the function ", "modifier": "", "signature": "fun containsErrorTypeInParameters(function: FunctionDescriptor): Boolean", "body": "{<EOL> val receiverParameter = function.extensionReceiverParameter<EOL> if (receiverParameter != null && containsErrorType(receiverParameter.type))<EOL> return true<EOL><EOL> for (parameter in function.valueParameters) {<EOL> if (containsErrorType(parameter.type))<EOL> return true<EOL> }"}
{"docstring": " return true if this is an FQ name of a fictitious class representing the function type eg kotlinFunction1 but NOT kotlinreflectKFunction1 ", "modifier": "", "signature": "fun isNumberedFunctionClassFqName(fqName: FqNameUnsafe): Boolean", "body": "{<EOL> return fqName.startsWith(BUILT_INS_PACKAGE_NAME) &&<EOL> fqName.getFunctionTypeKind() == FunctionTypeKind.Function<EOL>}"}
{"docstring": " This class contains Javarelated overridability conditions that may force incompatibility class JavaIncompatibilityRulesOverridabilityCondition ExternalOverridabilityCondition override fun isOverridable superDescriptor CallableDescriptor subDescriptor CallableDescriptor subClassDescriptor ClassDescriptor Result if isIncompatibleInAccordanceWithBuiltInOverridabilityRulessuperDescriptor subDescriptor subClassDescriptor return ResultINCOMPATIBLE if doesJavaOverrideHaveIncompatibleValueParameterKindssuperDescriptor subDescriptor return ResultINCOMPATIBLE return ResultUNKNOWN This overridability condition checks two things 1 Method accidentally having the same signature as special builtin has does not supposed to be override for it in Java class 2 In such Java class with special signature clash special builtin is loaded as hidden function with special signature and it should not override nonspecial method in further inheritance See javanioBuffer private fun isIncompatibleInAccordanceWithBuiltInOverridabilityRules superDescriptor CallableDescriptor subDescriptor CallableDescriptor subClassDescriptor ClassDescriptor Boolean if superDescriptor is CallableMemberDescriptor subDescriptor is FunctionDescriptor KotlinBuiltInsisBuiltInsubDescriptor return false if subDescriptornamesameAsBuiltinMethodWithErasedValueParameters subDescriptornamesameAsRenamedInJvmBuiltin return false val overriddenBuiltin superDescriptorgetOverriddenSpecialBuiltin Checking second condition special hidden override is not supposed to be an override to nonspecial irrelevant Java declaration val isOneOfDescriptorsHidden subDescriptorisHiddenToOvercomeSignatureClash superDescriptor as FunctionDescriptorisHiddenToOvercomeSignatureClash if isOneOfDescriptorsHidden overriddenBuiltin null subDescriptorisHiddenToOvercomeSignatureClash return true If new containing class is not Java class or subDescriptor signature was artificially changed use basic overridability rules if subClassDescriptor is JavaClassDescriptor subDescriptorinitialSignatureDescriptor null return false If current Java class has Kotlin super class with override of overriddenBuiltin then common overridability rules can be applied because of final special bridge generated in Kotlin super class if overriddenBuiltin null subClassDescriptorhasRealKotlinSuperClassWithOverrideOfoverriddenBuiltin return false class A extends HashMapObject Object void getObject x The problem is that when checking overridability of Aget and HashMapget we fall through to here because we do not recreate a magic copy of it because it has the same signature But it obviously that if subDescriptor and superDescriptor has the same JVM descriptor theyre oneway overridable Note that it doesnt work if special builtIn was renamed because we do not consider renamed builtins in computeJvmDescriptor TODO things get more and more complicated here consider moving signature mapping from backend and using it here instead of all of this magic if overriddenBuiltin is FunctionDescriptor superDescriptor is FunctionDescriptor BuiltinMethodsWithSpecialGenericSignaturegetOverriddenBuiltinFunctionWithErasedValueParametersInJavaoverriddenBuiltin null subDescriptorcomputeJvmDescriptorwithReturnType false superDescriptororiginalcomputeJvmDescriptorwithReturnType false return false Here we know that something in Java with common signature is going to override some special builtin that is supposed to be incompatible override return true override fun getContract ExternalOverridabilityConditionContractCONFLICTS_ONLY companion object Checks if any pair of corresponding value parameters has different type kinds eg one is primitive and another is not As it comes from its name it only checks overrides in Java classes ", "modifier": "", "signature": "fun doesJavaOverrideHaveIncompatibleValueParameterKinds(\n            superDescriptor: CallableDescriptor,\n            subDescriptor: CallableDescriptor\n        ): Boolean", "body": "{<EOL> if (subDescriptor !is JavaMethodDescriptor || superDescriptor !is FunctionDescriptor) return false<EOL> assert(subDescriptor.valueParameters.size == superDescriptor.valueParameters.size) {<EOL> \"External overridability condition with CONFLICTS_ONLY should not be run with different value parameters size\"<EOL> }"}
{"docstring": " Context that defines how typechecker operates stores typechecker state created by TypeCheckerProviderContextnewTypeCheckerState in most cases Stateful and shouldnt be reused Once some typechecker operation is performed using a TypeCheckerProviderContext for example a AbstractTypeCheckerisSubtypeOf new instance of particular TypeCheckerState should be created with properly specified type system context open class TypeCheckerState val isErrorTypeEqualsToAnything Boolean val isStubTypeEqualsToAnything Boolean val allowedTypeVariable Boolean val typeSystemContext TypeSystemContext val kotlinTypePreparator AbstractTypePreparator val kotlinTypeRefiner AbstractTypeRefiner OptInTypeRefinementclass fun refineTypetype KotlinTypeMarker KotlinTypeMarker return kotlinTypeRefinerrefineTypetype fun prepareTypetype KotlinTypeMarker KotlinTypeMarker return kotlinTypePreparatorprepareTypetype open fun customIsSubtypeOfsubType KotlinTypeMarker superType KotlinTypeMarker Boolean true protected var argumentsDepth 0 internal inline fun T runWithArgumentsSettingssubArgument KotlinTypeMarker f TypeCheckerState T T if argumentsDepth 100 errorArguments depth is too high Some related argument subArgument argumentsDepth val result f argumentsDepth return result open fun getLowerCapturedTypePolicysubType SimpleTypeMarker superType CapturedTypeMarker LowerCapturedTypePolicy CHECK_SUBTYPE_AND_LOWER open fun addSubtypeConstraint subType KotlinTypeMarker superType KotlinTypeMarker isFromNullabilityConstraint Boolean false Boolean null Handling cases like AInt AT AF_var There are two possible solutions for F_var Int and T and both of them may work well or not with other constrains Effectively we need to fork constraint system to two copies one with F_varInt and the other with F_varT and then maintain them both until we find some contradiction with one of the versions But that might lead to the exponential size of CS thus we use the following heuristics we accumulate forks data until the last stage of the candidate resolution and then try to apply back then until some of the constrains set has no contradiction atForkPoint works trivially in noninference context and for FE10 it just run basic subtyping mechanism for each subTypeArguments component until the first success open fun runForkingPointblock ForkPointContext Unit Boolean withForkPointContextDefault block result interface ForkPointContext fun forkblock Boolean class Default ForkPointContext var result Boolean false override fun forkblock Boolean if result return result block enum class LowerCapturedTypePolicy CHECK_ONLY_LOWER CHECK_SUBTYPE_AND_LOWER SKIP_LOWER private var supertypesLocked false var supertypesDeque ArrayDequeSimpleTypeMarker null private set var supertypesSet MutableSetSimpleTypeMarker null private set fun initialize assertsupertypesLocked Supertypes were locked for thisclass supertypesLocked true if supertypesDeque null supertypesDeque ArrayDeque4 if supertypesSet null supertypesSet SmartSetcreate fun clear supertypesDequeclear supertypesSetclear supertypesLocked false inline fun anySupertype start SimpleTypeMarker predicate SimpleTypeMarker Boolean supertypesPolicy SimpleTypeMarker SupertypesPolicy Boolean if predicatestart return true initialize val deque supertypesDeque val visitedSupertypes supertypesSet dequepushstart while dequeisNotEmpty if visitedSupertypessize 1000 errorToo many supertypes for type start Supertypes visitedSupertypesjoinToString val current dequepop if visitedSupertypesaddcurrent continue val policy supertypesPolicycurrenttakeIf it SupertypesPolicyNone continue val supertypes withtypeSystemContext currenttypeConstructorsupertypes for supertype in supertypes val newType policytransformTypethis supertype if predicatenewType clear return true dequeaddnewType clear return false sealed class SupertypesPolicy abstract fun transformTypestate TypeCheckerState type KotlinTypeMarker SimpleTypeMarker object None SupertypesPolicy override fun transformTypestate TypeCheckerState type KotlinTypeMarker throw UnsupportedOperationExceptionShould not be called object UpperIfFlexible SupertypesPolicy override fun transformTypestate TypeCheckerState type KotlinTypeMarker withstatetypeSystemContext typeupperBoundIfFlexible object LowerIfFlexible SupertypesPolicy override fun transformTypestate TypeCheckerState type KotlinTypeMarker withstatetypeSystemContext typelowerBoundIfFlexible abstract class DoCustomTransform SupertypesPolicy fun isAllowedTypeVariabletype KotlinTypeMarker Boolean return allowedTypeVariable withtypeSystemContext typeisTypeVariableType object AbstractTypeChecker JvmField var RUN_SLOW_ASSERTIONS false fun prepareType context TypeCheckerProviderContext type KotlinTypeMarker stubTypesEqualToAnything Boolean true contextnewTypeCheckerStatetrue stubTypesEqualToAnythingprepareTypetype fun isSubtypeOf context TypeCheckerProviderContext subType KotlinTypeMarker superType KotlinTypeMarker stubTypesEqualToAnything Boolean true Boolean return isSubtypeOfcontextnewTypeCheckerStatetrue stubTypesEqualToAnything subType superType It matches class types but ignores their type parameters Consider the following example abstract class FooT class FooBar FooAny In this case isSubtypeOfClass returns true for FooBar and FooT input arguments But isSubtypeOf returns false for the same input arguments ", "modifier": "", "signature": "fun isSubtypeOfClass(\n        state: TypeCheckerState,\n        typeConstructor: TypeConstructorMarker,\n        superConstructor: TypeConstructorMarker\n    ): Boolean", "body": "{<EOL> if (typeConstructor == superConstructor) return true<EOL> with(state.typeSystemContext) {<EOL> for (superType in typeConstructor.supertypes()) {<EOL> if (isSubtypeOfClass(state, superType.typeConstructor(), superConstructor)) {<EOL> return true<EOL> }"}
{"docstring": " Right now there are two places where we want to create this tracker 1 Right before fir2ir phase We need to store evaluated values to use them later in const value serialization 2 In tests for K1 IR This is needed ONLY for tests to log results of interpretation on lowering level ", "modifier": "", "signature": "fun create(): EvaluatedConstTracker", "body": "{<EOL> return DefaultEvaluatedConstTracker()<EOL> }"}
{"docstring": " A class name which is used to uniquely identify a Kotlin class If local true the class represented by this id is either itself local or is an inner class of some local class This also means that the first nonclass container of the class is not a package In the case of a local class relativeClassName consists of a single name including all callables and class names all the way up to the package separated by dollar signs If a class is an inner of local relativeClassName would consist of two names the second one being the class short name data class ClassIdval packageFqName FqName val relativeClassName FqName val isLocal Boolean constructorpackageFqName FqName topLevelName Name thispackageFqName FqNametopLeveltopLevelName isLocal false init assertrelativeClassNameisRoot Class name must not be root packageFqName if isLocal local else val parentClassId ClassId get runIfisNestedClass ClassIdpackageFqName relativeClassNameparent isLocal val shortClassName Name get relativeClassNameshortName val outerClassId ClassId get val parent relativeClassNameparent return runIfparentisRoot ClassIdpackageFqName parent isLocal val outermostClassId ClassId get var name relativeClassName while nameparentisRoot name nameparent return ClassIdpackageFqName name isLocal false val isNestedClass Boolean get relativeClassNameparentisRoot fun createNestedClassIdname Name ClassId return ClassIdpackageFqName relativeClassNamechildname isLocal fun asSingleFqName FqName return if packageFqNameisRoot relativeClassName else FqNamepackageFqNameasString relativeClassNameasString fun startsWithsegment Name Boolean return packageFqNamestartsWithsegment return a string where packages are delimited by and classes by eg kotlinMapEntry ", "modifier": "", "signature": "fun asString(): String", "body": "{<EOL> fun FqName.escapeSlashes(): String {<EOL> val res = asString()<EOL> if (res.contains('/')) {<EOL> return \"`$res`\"<EOL> }"}
{"docstring": " Subclasses of this class are used to identify different versions of the binary output of the compiler and their compatibility guarantees Major version should be increased only when the new binary format is neither forward nor backward compatible This shouldnt really ever happen at all Minor version should be increased when the new format is backward compatible ie the new compiler can process old data but the old compiler will not be able to process new data Patch version can be increased freely and is only supposed to be used for debugging Increase the patch version when you make a change to binaries which is both forward and backward compatible abstract class BinaryVersionprivate vararg val numbers Int val major Int numbersgetOrNull0 UNKNOWN val minor Int numbersgetOrNull1 UNKNOWN val patch Int numbersgetOrNull2 UNKNOWN val rest ListInt if numberssize 3 if numberssize MAX_LENGTH throw IllegalArgumentExceptionBinaryVersion with length more than MAX_LENGTH are not supported Provided length numberssize else numbersasListsubList3 numberssizetoList else emptyList DeprecatedPlease use isCompatibleWithCurrentCompilerVersion ReplaceWithisCompatibleWithCurrentCompilerVersion open fun isCompatible Boolean isCompatibleWithCurrentCompilerVersion abstract fun isCompatibleWithCurrentCompilerVersion Boolean fun toArray IntArray numbers Returns true if this version of some format loaded from some binaries is compatible to the expected version of that format in the current compiler param ourVersion the version of this format in the current compiler ", "modifier": "protected ", "signature": "fun isCompatibleTo(ourVersion: BinaryVersion): Boolean", "body": "{<EOL> return if (major == 0) ourVersion.major == 0 && minor == ourVersion.minor<EOL> else major == ourVersion.major && minor <= ourVersion.minor<EOL> }"}
{"docstring": " Compare erased types ", "modifier": "private ", "signature": "fun areTypesTheSame(ktTypeRef: KtTypeReference, psiType: PsiType, varArgs: Boolean): Boolean", "body": "{<EOL> val qualifiedName =<EOL> getQualifiedName(ktTypeRef.typeElement, ktTypeRef.getAllModifierLists().any { it.hasSuspendModifier() }"}
{"docstring": " see orgjetbrainskotlinanalysisdecompilerpsitextmustNotBeWrittenToDecompiledText ", "modifier": "private ", "signature": "fun mustNotBeWrittenToStubs(flags: Int): Boolean", "body": "{<EOL> return Flags.MEMBER_KIND.get(flags) == MemberKind.FAKE_OVERRIDE<EOL>}"}
{"docstring": " Checks if this file is a compiled internal Kotlin class ie a Kotlin class not necessarily ABIcompatible with the current plugin which should NOT be decompiled and as a result shown under the library in the Project view be searchable via Find class etc ", "modifier": "", "signature": "fun isKotlinInternalCompiledFile(file: VirtualFile, fileContent: ByteArray? = null): Boolean", "body": "{<EOL> if (!file.isValidAndExists(fileContent)) {<EOL> return false<EOL> }"}
{"docstring": " Checks if this file is a compiled Kotlin class file not necessarily ABIcompatible with the current plugin ", "modifier": "", "signature": "fun isKotlinJvmCompiledFile(file: VirtualFile, fileContent: ByteArray? = null): Boolean", "body": "{<EOL> if (file.extension != JavaClassFileType.INSTANCE!!.defaultExtension) {<EOL> return false<EOL> }"}
{"docstring": " Checks if this file is a compiled Kotlin class file ABIcompatible with the current plugin ", "modifier": "private ", "signature": "fun isKotlinWithCompatibleAbiVersion(file: VirtualFile, jvmMetadataVersion: JvmMetadataVersion): Boolean", "body": "{<EOL> val clsKotlinBinaryClassCache = ClsKotlinBinaryClassCache.getInstance()<EOL> if (!clsKotlinBinaryClassCache.isKotlinJvmCompiledFile(file)) return false<EOL><EOL> val kotlinClass = clsKotlinBinaryClassCache.getKotlinBinaryClassHeaderData(file)<EOL> return kotlinClass != null && kotlinClass.metadataVersion.isCompatible(jvmMetadataVersion)<EOL>}"}
{"docstring": " Returns the segments of a qualified access PSI For example given foobarOuterClassInnerClass this returns foo bar OuterClass InnerClass private fun KtDotQualifiedExpressionfqNameSegments ListString val qualifiers generateSequencethis as KtExpression it as KtDotQualifiedExpressionreceiverExpression map it as KtDotQualifiedExpressionselectorExpression it toList asReversed val qualifyingReferences qualifiersmapIndexed index qualifier We want to handle qualified calls like fooBarBaz but not like fooBarBaz if qualifier is KtCallExpression index qualifierslastIndex return null qualifierreferenceExpression as KtNameReferenceExpression return null return qualifyingReferencesmap itgetReferencedName private fun getSymbolsForAnnotationCall fir FirAnnotation session FirSession symbolBuilder KtSymbolByFirBuilder CollectionKtSymbol val type firresolvedType return listOfNotNulltypetoTargetSymbolsession symbolBuilder private fun findPossibleTypeQualifier qualifier KtSimpleNameExpression wholeTypeFir FirResolvedTypeRef ClassId val qualifierToResolve qualifierparent as KtUserType FIXME make it work with generics in functional types like AABBCC AADD val wholeType when val psi wholeTypeFirpsi is KtUserType psi is KtTypeReference psitypeElementunwrapNullability as KtUserType else null return null val qualifiersToDrop countQualifiersToDropwholeType qualifierToResolve return wholeTypeFirtypeclassIddropLastNestedClassesqualifiersToDrop return class id without classesToDrop last nested classes or null if classesToDrop is too big Example foobarBazInner with 1 dropped class is foobarBaz and with 2 dropped class is null private fun ClassIddropLastNestedClassesclassesToDrop Int generateSequencethis itouterClassId dropclassesToDropfirstOrNull return How many qualifiers needs to be dropped from wholeType to get nestedType Example to get foobar from foobarBazInner you need to drop 2 qualifiers Inner and Baz ", "modifier": "private ", "signature": "fun countQualifiersToDrop(wholeType: KtUserType, nestedType: KtUserType): Int", "body": "{<EOL> val qualifierIndex = generateSequence(wholeType) { it.qualifier }"}
{"docstring": " Returns whether subClass is a strict subtype of superClass Resolves subClass to FirResolvePhaseSUPER_TYPES ", "modifier": "", "signature": "fun isSubClassOf(subClass: FirClass, superClass: FirClass, useSiteSession: FirSession, allowIndirectSubtyping: Boolean = true): Boolean", "body": "{<EOL> subClass.lazyResolveToPhase(FirResolvePhase.SUPER_TYPES)<EOL><EOL> if (subClass.superConeTypes.any { it.toRegularClassSymbol(useSiteSession) == superClass.symbol }"}
{"docstring": " A scope containing both nonstatic and static members A smart combined scope as opposed to a naive combination of KtScopes with getCompositeScope avoids duplicate inner classes as they are contained in nonstatic and static scopes A proper combined declared member scope kind also makes it easier to cache combined scopes directly if needed COMBINED private fun getDeclaredMemberScopeclassSymbol KtSymbolWithMembers kind DeclaredMemberScopeKind KtScope val firDeclaration classSymbolfirSymbolfir val firScope when firDeclaration is FirJavaClass getFirJavaDeclaredMemberScopefirDeclaration kind return getEmptyScope else getFirKotlinDeclaredMemberScopeclassSymbol kind return KtFirDelegatingNamesAwareScopefirScope builder private fun getFirKotlinDeclaredMemberScope classSymbol KtSymbolWithMembers kind DeclaredMemberScopeKind FirContainingNamesAwareScope val combinedScope getCombinedFirKotlinDeclaredMemberScopeclassSymbol return when kind DeclaredMemberScopeKindNON_STATIC FirNonStaticMembersScopecombinedScope DeclaredMemberScopeKindSTATIC FirStaticScopecombinedScope DeclaredMemberScopeKindCOMBINED combinedScope Returns a declared member scope which contains both static and nonstatic callables as well as all classifiers Java classes need to be handled specially because declaredMemberScope doesnt handle Java enhancement properly ", "modifier": "private ", "signature": "fun getCombinedFirKotlinDeclaredMemberScope(symbolWithMembers: KtSymbolWithMembers): FirContainingNamesAwareScope", "body": "{<EOL> val useSiteSession = analysisSession.useSiteSession<EOL> return when (symbolWithMembers) {<EOL> is KtFirScriptSymbol -> FirScriptDeclarationsScope(useSiteSession, symbolWithMembers.firSymbol.fir)<EOL> else -> useSiteSession.declaredMemberScope(symbolWithMembers.getFirForScope(), memberRequiredPhase = null)<EOL> }"}
{"docstring": " Returns whether this FirScope is a scope wider than another based on the above PartialOrderOfScope or not private fun FirScopeisWiderThananother FirScope Boolean toPartialOrderscopeDistanceLevel anothertoPartialOrderscopeDistanceLevel Assuming that all scopes in this ListFirScope and base are surrounding from returns whether an element of this ListFirScope is closer than base based on the distance from from private fun ListFirScopehasScopeCloserThanbase FirScope from KtElement any scope if scopeisScopeForClass baseisScopeForClass val classContainingFrom fromfindClassOrObjectParent returnany false returnany scopeisScopeForClassCloserThanAnotherScopeForClassbase classContainingFrom baseisWiderThanscope Returns true if containingFile has a KtImportDirective whose imported FqName is the same as classId but references a different symbol ", "modifier": "private ", "signature": "fun importDirectiveForDifferentSymbolWithSameNameIsPresent(classId: ClassId): Boolean", "body": "{<EOL> val importDirectivesWithSameImportedFqName = containingFile.collectDescendantsOfType { importedDirective: KtImportDirective -><EOL> importedDirective.importedFqName?.shortName() == classId.shortClassName<EOL> }"}
{"docstring": " Returns true if adding classToImport import to the file might alter or break the resolve of existing references in the file NB At the moment it might have both false positives and false negatives since it does not check all possible references ", "modifier": "private ", "signature": "fun importBreaksExistingReferences(classToImport: ClassId, importAllInParent: Boolean): Boolean", "body": "{<EOL> return importAffectsUsagesOfClassesWithSameName(classToImport, importAllInParent)<EOL> }"}
{"docstring": " Same as above but for more general callable symbols Currently only checks constructor calls assuming true for everything else ", "modifier": "private ", "signature": "fun importBreaksExistingReferences(callableToImport: FirCallableSymbol<*>, importAllInParent: Boolean): Boolean", "body": "{<EOL> if (callableToImport is FirConstructorSymbol) {<EOL> val classToImport = callableToImport.classIdIfExists<EOL> if (classToImport != null) {<EOL> return importAffectsUsagesOfClassesWithSameName(classToImport, importAllInParent)<EOL> }"}
{"docstring": " It is important to avoid passing type arguments when they are implicit type arguments For example package abc fun T E fooa T b E A fun test fun fooa Int b String B abcfoo3 test In the above code we must prevent it from shortening abcfoo3 test However if we explicitly pass the type arguments to the resolver the resolver considers it has some explicit type arguments Therefore it reports that the only function matching the signature is A because B does not have type parameters However actually B also matches the signature and we must avoid dropping abc from the call expression if callExpressiontypeArgumentsisNotEmpty true typeArgumentsaddAllfunctionCalltypeArguments argumentList functionCallargumentList calleeReference fakeCalleeReference val candidates AllCandidatesResolvershorteningContextanalysisSessionuseSiteSessiongetAllCandidates firResolveSession fakeFirQualifiedAccess name expressionInScope ResolutionModeContextIndependent return candidatesfilter overloadCandidate when overloadCandidatecandidatelowestApplicability CandidateApplicabilityRESOLVED true CandidateApplicabilityK2_SYNTHETIC_RESOLVED true SAM constructor call else false private fun findCandidatesForPropertyAccess annotations ListFirAnnotation typeArguments ListFirTypeProjection name Name elementInScope KtElement ListOverloadCandidate val fakeCalleeReference buildSimpleNamedReference thisname name val fakeFirQualifiedAccess buildPropertyAccessExpression thisannotationsaddAllannotations thistypeArgumentsaddAlltypeArguments calleeReference fakeCalleeReference val candidates AllCandidatesResolvershorteningContextanalysisSessionuseSiteSessiongetAllCandidates firResolveSession fakeFirQualifiedAccess name elementInScope ResolutionModeContextIndependent return candidatesfilter overloadCandidate overloadCandidatecandidatelowestApplicability CandidateApplicabilityRESOLVED private fun ListOverloadCandidatefindScopeForSymbolsymbol FirBasedSymbol FirScope firstOrNull itcandidatesymbol symbol candidateoriginScope Returns whether a member of companion is used to initialize the enum entry or not For example enum class Cval i Int ONEexprCKexpr CONE uses CK for initialization companion object const val K 1 private fun KtExpressionisCompanionMemberUsedForEnumEntryInitresolvedSymbol FirCallableSymbol Boolean val enumEntry getNonStrictParentOfTypeKtEnumEntry return false val firEnumEntry enumEntryresolveToFirSymbolfirResolveSession as FirEnumEntrySymbol return false val classNameOfResolvedSymbol resolvedSymbolcallableIdclassName return false return firEnumEntrycallableIdclassName classNameOfResolvedSymbolparent classNameOfResolvedSymbolshortName SpecialNamesDEFAULT_NAME_FOR_COMPANION_OBJECT Returns whether it is fine to shorten firQualifiedAccess or not param firQualifiedAccess FIR for the shortening target expression param calledSymbol The symbol referenced by the qualified access expression param expressionInScope An expression under the same scope as the shortening target expression The decision has two steps 1 Collect all candidates matching firQualifiedAccess We use AllCandidatesResolvershorteningContextanalysisSessionuseSiteSessiongetAllCandidates fake FIR See resolveUnqualifiedAccess above 2 Check whether the candidate with the highest priority based on the distance to the scope from expressionInScope is the same as calledSymbol ot not We use hasScopeCloserThan to determine the distance to the scope ", "modifier": "private ", "signature": "fun shortenIfAlreadyImported(\n        firQualifiedAccess: FirQualifiedAccessExpression,\n        calledSymbol: FirCallableSymbol<*>,\n        expressionInScope: KtExpression,\n    ): Boolean", "body": "{<EOL> /**<EOL> * Avoid shortening reference to enum companion used in enum entry initialization there is no guarantee that the companion object<EOL> * was initialized in advance.<EOL> * For example, When we shorten the following code:<EOL> * enum class C(val i: Int) {<EOL> * ONE(<expr>C.K</expr>) // shorten C.K to K<EOL> * ;<EOL> * companion object {<EOL> * const val K = 1<EOL> * }"}
{"docstring": " This method intentionally mirrors the appearance of the classShortenStrategy and callableShortenStrategy filters but ATM we dont have a way to properly handle FirThisReferences through the existing filters We need a better way to decide shortening strategy for labeled and regular this expressions KT63555 ", "modifier": "private ", "signature": "fun thisLabelShortenStrategy(thisReference: FirThisReference): ShortenStrategy", "body": "{<EOL> val referencedSymbol = thisReference.boundSymbol<EOL><EOL> val strategy = when (referencedSymbol) {<EOL> is FirClassLikeSymbol<*> -> classShortenStrategy(referencedSymbol)<EOL> is FirCallableSymbol<*> -> callableShortenStrategy(referencedSymbol)<EOL> else -> ShortenStrategy.DO_NOT_SHORTEN<EOL> }"}
{"docstring": " isUsed and doesParentUseChild are defined in mutual recursion climbing up the syntax tree passing control back and forth between the two Whether an expression is used is defined by the context in which it appears Eg a statement in a block is considered used if it is the last expression in that block AND the block itself is used a recursive call to isUsed one level higher in the syntax tree The methods are _conservative_ erring on the side of answering true ", "modifier": "private ", "signature": "fun isUsed(psiElement: PsiElement): Boolean", "body": "{<EOL> return when (psiElement) {<EOL> /**<EOL> * DECLARATIONS<EOL> */<EOL> // Inner PSI of KtLambdaExpressions. Used if the containing KtLambdaExpression is.<EOL> is KtFunctionLiteral -><EOL> doesParentUseChild(psiElement.parent, psiElement)<EOL><EOL> // KtNamedFunction includes `fun() { ... }"}
{"docstring": " EXPRESSIONS A handful of expression are never considered used Everything of type Nothing is KtThrowExpression false is KtReturnExpression false is KtBreakExpression false is KtContinueExpression false Loops is KtLoopExpression false The this in constructorx Int thisx is KtConstructorDelegationReferenceExpression false Administrative node for EnumEntries Never used as expression is KtEnumEntrySuperclassReferenceExpression false The reference in a constructor call Eg C in C is KtConstructorCalleeExpression false Labels themselves label in returnlabel or labelwhile is KtLabelReferenceExpression false The operation symbol itself in binary and unary operations is KtOperationReferenceExpression false All other expressions are used if their parent expression uses them else doesParentUseChildpsiElementparent psiElement private fun doesParentUseChildparent PsiElement child PsiElement Boolean return when parent NONEXPRESSION PARENTS KtValueArguments are a container for callsites and use exactly the argument expression they wrap is KtValueArgument parentgetArgumentExpression child is KtDelegatedSuperTypeEntry parentdelegateExpression child KtContainerNode are containers used in KtIfExpressions and should be regarded as parentheses for the purpose of this analysis is KtContainerNode CAUTION Not parentUseparentparent _parent_ Here we assume the parent eg If condition statement ignores the ContainerNode when accessing child doesParentUseChildparentparent child KtWhenEntryWhenCondition are containers used in KtWhenExpressions ard should be regarded as parentheses is KtWhenEntry parentexpression child isUsedparentparent child in parentconditions is KtWhenCondition doesParentUseChildparentparent parent Type parameters return types and other annotations are all contained in KtUserType and are never considered used as expressions is KtUserType false Only toplevel named declarations have KtFileKtScript Parents and are never considered used is KtFile false is KtScript false Only class members have KtClassBody parents and are never considered used is KtClassBody false _ and _ contexts use their inner expression is KtStringTemplateEntry parentexpression child Catch blocks are used if the parenttry uses the catch block is KtCatchClause doesParentUseChildparentparent parent Finally blocks are never used is KtFinallySection false is KtExpression errorWithAttachmentUnhandled NonKtExpression parent of KtExpression parentclass withPsiEntryparent parent EXPRESSIONS Enum entries type parameters lamda expressions and script initializers never use any child expressions is KtEnumEntry false is KtTypeParameter false is KtLambdaExpression false is KtScriptInitializer false The last expression of a block is considered used iff the block itself is used is KtBlockExpression parentstatementslastOrNull child isUsedparent Destructuring declarations use their initializer is KtDestructuringDeclaration parentinitializer child Backing field declarations use their initializer is KtBackingField parentinitializer child Property accessors can use their bodies if not blocks is KtPropertyAccessor parentbodyExpression child doesPropertyAccessorUseBodyparent child Lambdas do not use their expressionblocks if they are inferred to be of unit type is KtFunctionLiteral parentbodyBlockExpression child returnsUnitparent See doesNamedFunctionUseBody is KtNamedFunction doesNamedFunctionUseBodyparent child Function parameter declarations use their default value expressions is KtParameter parentdefaultValue child Variable declarations use their initializer is KtVariableDeclaration parentinitializer child Binary expressions always use both operands is KtBinaryExpression parentleft child parentright child Binary expressions with type RHS always use its operand is KtBinaryExpressionWithTypeRHS parentleft child Is expressions always use their LHS is KtIsExpression parentleftHandSide child Unary expressions always use its operand is KtUnaryExpression parentbaseExpression child Qualified expressions always use its receiver The selector is used iff the qualified expression is is KtQualifiedExpression parentreceiverExpression child parentselectorExpression child isUsedparent Array accesses use both receiver and index is KtArrayAccessExpression child in parentindexExpressions parentarrayExpression child Calls use only the callee directly arguments are wrapped in a KtValueArgument container is KtCallExpression parentcalleeExpression child doesCallExpressionUseCalleechild Collection literals use each of its constituent expressions is KtCollectionLiteralExpression child in parentgetInnerExpressions Annotations are regarded as parentheses The annotation itself is never used is KtAnnotatedExpression parentbaseExpression child isUsedparent See doesDoubleColonUseLHS is KtDoubleColonExpression parentlhs child doesDoubleColonUseLHSchild Parentheses are ignored for this analysis is KtParenthesizedExpression doesParentUseChildparentparent parent When expressions use the subject expression _unless_ the first branch in the when is an else is KtWhenExpression parentsubjectExpression child parententriesfirstOrNullisElse false Throw expressions use the expression thrown is KtThrowExpression parentthrownExpression child Body and catch blocks of trycatch expressions are used if the trycatch itself is used is KtTryExpression parenttryBlock child child in parentcatchClauses isUsedparent If expressions always use their condition and the branches are used if the If itself is used as an expression is KtIfExpression parentcondition child parentthen child parentelse child isUsedparent For expressions use their loop range expression is KtForExpression parentloopRange child While DoWhile loops use their conditions not their bodies is KtWhileExpressionBase parentcondition child Return expressions use the return value is KtReturnExpression parentreturnedExpression child Labels are regarded as parentheses for this analysis The label itself is never used is KtLabeledExpression parentbaseExpression child isUsedparent No children is KtConstantExpression false no children of class and script initializers are used is KtAnonymousInitializer false no child expressions of primary constructors is KtPrimaryConstructor false error no children of secondary constructs are used is KtSecondaryConstructor false KtClass KtObjectDeclaration KtTypeAlias has no expression children is KtClassLikeDeclaration false has no expression children Simple names do not have expression children Labels operations references by name is KtSimpleNameExpression false thissuper in constructor delegations No expression children is KtConstructorDelegationReferenceExpression false Object Literal expressions use none of its children is KtObjectLiteralExpression false break continue super this do not have children is KtBreakExpression false is KtContinueExpression false is KtSuperExpression false is KtThisExpression false No direct expression children is KtStringTemplateExpression false else errorWithAttachmentUnhandled KtElement subtype parentclass withPsiEntryparent parent The left hand side of a is regarded as used unless it refers to a type We decide that the LHS is a type reference by checking if the left hand side is a qualified name and in case it _is_ resolving that name If it resolves to a nonclass declaration it does _not_ refer to a type ", "modifier": "private ", "signature": "fun doesDoubleColonUseLHS(lhs: PsiElement): Boolean", "body": "{<EOL> val reference = when (val inner = lhs.unwrapParenthesesLabelsAndAnnotations()) {<EOL> is KtReferenceExpression -><EOL> inner.mainReference<EOL> is KtDotQualifiedExpression -><EOL> (inner.selectorExpression as? KtReferenceExpression)?.mainReference ?: return true<EOL> else -><EOL> return true<EOL> }"}
{"docstring": " Invocations of _statically named_ callables is not considered a use Eg consider 1 fun f 54 f 2 val f 54 f in which the f in 2 is regarded as used and f in 1 is not ", "modifier": "private ", "signature": "fun doesCallExpressionUseCallee(callee: PsiElement): Boolean", "body": "{<EOL> return callee !is KtReferenceExpression ||<EOL> analyze(callee) {<EOL> isSimpleVariableAccessCall(callee)<EOL> }"}
{"docstring": " The body of setters are always used The body of getters are only used if they are expression bodies ", "modifier": "private ", "signature": "fun doesPropertyAccessorUseBody(propertyAccessor: KtPropertyAccessor, body: PsiElement): Boolean", "body": "{<EOL> return propertyAccessor.isSetter || (propertyAccessor.isGetter && body !is KtBlockExpression)<EOL>}"}
{"docstring": " Checks whether the File contains a legal LL_FIR_DIVERGENCE directive without reading the whole file fun FilehasLlFirDivergenceDirective Boolean useLines findDirectiveInLinesititerator fun StringremoveLlFirDivergenceDirectivetrimLines Boolean String To ignore LL_FIR_DIVERGENCE we advance iterator with findDirectiveInLines and then concatenate the rest of the lines val iterator thislineSequenceiterator return if findDirectiveInLinesiterator trimStart ensures that the LL_FIR_DIVERGENCE directive can be separated from the rest of the file by blank lines iteratorasSequenceconcatLinestrimLinestrimStart else thistrim Trim start and end newlines in file if directive not foundprivate fun SequenceStringconcatLinestrimLines Boolean String if trimLines joinToStringn ittrimEnd trimEnd else joinToStringn Tries to find the LL_FIR_DIVERGENCE directive in the lines given by iterator and returns whether this is the case If the directive was found iterator is guaranteed to be advanced exactly past the LL_FIR_DIVERGENCE directive The format of the directive is as such LL_FIR_DIVERGENCE lorem ipsum dolor sit amet LL_FIR_DIVERGENCE Blank lines before the directive or inside the directive region are ignored ", "modifier": "private ", "signature": "fun findDirectiveInLines(iterator: Iterator<String>): Boolean", "body": "{<EOL> val firstNonBlankLine = iterator.nextNonBlankLineTrimmed()<EOL> if (firstNonBlankLine != LL_FIR_DIVERGENCE_DIRECTIVE_COMMENT) return false<EOL><EOL> // Ignore line comments and blank lines until the second (closing) `LL_FIR_DIVERGENCE` is found. Any other text, such as uncommented<EOL> // code inside the directive region, is illegal.<EOL> while (iterator.hasNext()) {<EOL> val line = iterator.nextNonBlankLineTrimmed() ?: return false<EOL> if (line.startsWith(\"//\")) {<EOL> if (line == LL_FIR_DIVERGENCE_DIRECTIVE_COMMENT) return true<EOL> }"}
{"docstring": " Publish FirResolvedToPhaseState with toPhase phase and unlocks current FirInProcessOfResolvingToJumpingPhaseState see withJumpingLockImpl see FirInProcessOfResolvingToJumpingPhaseState see FirResolvedToPhaseState private fun FirElementWithResolveStatejumpingUnlocktoPhase FirResolvePhase val currentState jumpingResolutionStatesStackpop resolveStateFieldUpdatersetthis FirResolvedToPhaseStatetoPhase currentStatelatchcountDown private val resolveStateFieldUpdater AtomicReferenceFieldUpdaternewUpdater FirElementWithResolveStateclassjava FirResolveStateclassjava resolveStateprivate val globalLockEnabled Boolean by lazyLazyThreadSafetyModePUBLICATION Registryiskotlinparallelresolveundergloballock falseprivate const val DEFAULT_LOCKING_INTERVAL 50L see FirInProcessOfResolvingToJumpingPhaseState private class JumpingResolutionStatesStack private val stateStackHolder ThreadLocalwithInitialMutableListFirInProcessOfResolvingToJumpingPhaseState mutableListOf Adds newState to the stack and set waitingForFirInProcessOfResolvingToJumpingPhaseStatewaitingFor for the previous state if needed fun pushnewState FirInProcessOfResolvingToJumpingPhaseState val states stateStackHolderget val currentState stateslastOrNull currentStatewaitingFor newState states newState Pops from the top of the stack the last state and return it Updates waitingForFirInProcessOfResolvingToJumpingPhaseStatewaitingFor for the previous state if needed Note it doesnt release the lockFirInProcessOfResolvingToJumpingPhaseStatelatch ", "modifier": "", "signature": "fun pop(): FirInProcessOfResolvingToJumpingPhaseState", "body": "{<EOL> val states = stateStackHolder.get()<EOL><EOL> val currentState = states.removeLast()<EOL> val prevState = states.lastOrNull()<EOL> requireWithAttachment(<EOL> condition = prevState == null || prevState.waitingFor === currentState,<EOL> message = { \"The lock contact is violated\" }"}
{"docstring": " Aggregates KTKtElement FIRorgjetbrainskotlinfirFirElement mappings and diagnostics for associated KtFile For every KtFile we need mapping for we have FileStructure which contains a tree likestructure of FileStructureElement When we want to get KT FIR mapping we getOrPutgetStructureElementFor FileStructureElement for the closest nonlocal declaration which contains the requested KtElement Some of FileStructureElement can be invalidated in the case on inblock PSI modification See invalidateElement and LLFirDeclarationModificationService for details The mapping is an optimization to avoid searching for the associated FirElementorgjetbrainskotlinfirFirElement by KtElement as it requires deep traverse through the main element of FileStructureElement see orgjetbrainskotlinanalysislowlevelapifirelementbuilderFirElementBuilder see FileStructureElement see LLFirDeclarationModificationService internal class FileStructure private constructor private val ktFile KtFile private val firFile FirFile private val moduleComponents LLFirModuleResolveComponents companion object fun build ktFile KtFile moduleComponents LLFirModuleResolveComponents FileStructure val firFile moduleComponentsfirFileBuilderbuildRawFirFileWithCachingktFile return FileStructurektFile firFile moduleComponents private val firProvider firFilemoduleDatasessionfirProvider private val structureElements ConcurrentHashMapKtElement FileStructureElement Must be called only under writelock This method is responsible for invalidation of reanalyzable declarations see LLFirDeclarationModificationService see getNonLocalReanalyzableContainingDeclaration fun invalidateElementelement KtElement val container getContainerKtElementelement structureElementsremovecontainer return FileStructureElement for the closest nonlocal declaration which contains this element ", "modifier": "", "signature": "fun getStructureElementFor(element: KtElement): FileStructureElement", "body": "{<EOL> val container = getContainerKtElement(element)<EOL> return structureElements.getOrPut(container) { createStructureElement(container) }"}
{"docstring": " The LLFirSession must be strongly reachable from the resolvable session and ultimately the KtFirAnalysisSession so that soft reference garbage collection doesnt collect the LLFirSession without collecting its dependent KtFirAnalysisSession See LLFirSession for more details val useSiteSession LLFirSession by lazyLazyThreadSafetyModePUBLICATION useSiteSessionFactoryuseSiteModule Returns an LLFirSession for the module For a binary module the resulting session will be a binary nonresolvable one ", "modifier": "", "signature": "fun getSession(module: KtModule): LLFirSession", "body": "{<EOL> return getSession(module, preferBinary = true)<EOL> }"}
{"docstring": " Returns an analyzable LLFirSession for the module For a binary module the resulting session will still be a resolvable one Note prefer using getSession unless you need to perform resolution actively Resolvable sessions for libraries are much less performant ", "modifier": "", "signature": "fun getResolvableSession(module: KtModule): LLFirResolvableModuleSession", "body": "{<EOL> return getSession(module, preferBinary = false) as LLFirResolvableModuleSession<EOL> }"}
{"docstring": " Returns a KtModule for a given element in context of the current session See ProjectStructureProvider for more information on contextual modules ", "modifier": "", "signature": "fun getModule(element: PsiElement): KtModule", "body": "{<EOL> return ProjectStructureProvider.getModule(useSiteModule.project, element, useSiteModule)<EOL> }"}
{"docstring": " Returns the existing session if found or creates a new session and caches it Analyzable session will be returned for a library module Must be called from a read action ", "modifier": "", "signature": "fun getSession(module: KtModule, preferBinary: Boolean = false): LLFirSession", "body": "{<EOL> if (module is KtBinaryModule && (preferBinary || module is KtSdkModule)) {<EOL> return getCachedSession(module, binaryCache) {<EOL> createPlatformAwareSessionFactory(module).createBinaryLibrarySession(module)<EOL> }"}
{"docstring": " Returns a session without caching it Note that session dependencies are still cached internal fun getSessionNoCachingmodule KtModule LLFirSession return createSessionmodule private fun getDanglingFileCachedSessionmodule KtDanglingFileModule LLFirSession if moduleisStable return getCachedSessionmodule danglingFileSessionCache createSession checkCanceled val session unstableDanglingFileSessionCachecomputemodule _ existingSession if existingSession is LLFirDanglingFileSession existingSessionmodificationStamp modulefilemodificationStamp existingSession else createSessionmodule requireNotNullsession checkSessionValiditysession return session private fun T KtModule getCachedSessionmodule T storage SessionStorage factory T LLFirSession LLFirSession checkCanceled val session if modulesupportsIsolatedSessionCreation storagecomputeIfAbsentmodule factorymodule else Nonisolated session creation may need to access other sessions so we should create the session outside computeIfAbsent to avoid recursive update exceptions storagemodule run val newSession factorymodule storagecomputeIfAbsentmodule newSession checkSessionValiditysession return session private fun checkSessionValiditysession LLFirSession requiresessionisValid A session acquired via getSession should always be valid Module sessionktModule Removes the sessions associated with module after it has been invalidated Must be called in a write action return true if any sessions were removed ", "modifier": "", "signature": "fun removeSession(module: KtModule): Boolean", "body": "{<EOL> ApplicationManager.getApplication().assertWriteAccessAllowed()<EOL><EOL> val didSourceSessionExist = removeSessionFrom(module, sourceCache)<EOL> val didBinarySessionExist = module is KtBinaryModule && removeSessionFrom(module, binaryCache)<EOL> val didDanglingFileSessionExist = module is KtDanglingFileModule && removeSessionFrom(module, danglingFileSessionCache)<EOL> val didUnstableDanglingFileSessionExist = module is KtDanglingFileModule && removeSessionFrom(module, unstableDanglingFileSessionCache)<EOL><EOL> return didSourceSessionExist || didBinarySessionExist || didDanglingFileSessionExist || didUnstableDanglingFileSessionExist<EOL> }"}
{"docstring": " Postprocessors run after arrangers but before the action block It is a workaround for cases when an arranger cannot properly tweak the state by itself for instance when such tweak depends on a nonlocal mutation internal typealias PostProcessor UnitStateKeeperDslinternal interface StateKeeperBuilder fun registerstate PreservedStateJvmInlineStateKeeperDslinternal value class StateKeeperScopeOwner Any Context Anyprivate val owner Owner Defines an entity state preservation rule param provider a function that returns the current entity state a getter param mutator a function that modifies the entity state a setter param arranger a function that provides a tweaked entity state Such a state is then applied using a mutator contextStateKeeperBuilder inline fun Value addprovider Owner Value crossinline mutator Owner Value Unit arranger Value Any Value val owner thisStateKeeperScopeowner val storedValue providerowner if storedValue null val arrangedValue arrangerstoredValue if arrangedValue storedValue mutatorowner arrangedValue registerobject PreservedState override fun restore mutatorowner storedValue override fun postProcess Defines an entity state preservation rule param provider a function that returns the current entity state a getter param mutator a function that modifies the entity state a setter contextStateKeeperBuilder inline fun Value addprovider Owner Value crossinline mutator Owner Value Unit val owner thisStateKeeperScopeowner val storedValue providerowner registerobject PreservedState override fun restore mutatorowner storedValue override fun postProcess Defines an entity state preservation rule by delegating to a given keeper In other words applies all rules defined in the keeper to the current entity contextStateKeeperBuilder fun addkeeper StateKeeperOwner Context context Context val owner thisStateKeeperScopeowner registerkeeperprepareowner context Defines a postprocessor contextStateKeeperBuilder fun postProcessblock PostProcessor registerobject PreservedState override fun postProcess block override fun restore Registers a given entity using the delegate keeper Does nothing if the entity is null contextStateKeeperBuilderinternal fun Entity Any Context Any entityentity Entity keeper StateKeeperEntity Context context Context if entity null StateKeeperScopeEntity Contextentityaddkeeper context Registers a given entity using the building block Does nothing if the entity is null contextStateKeeperBuilderinternal inline fun Entity Any Context Any entity entity Entity context Context block StateKeeperScopeEntity ContextEntity Context Unit if entity null StateKeeperScopeEntity Contextentityblockentity context Registers all entities in a given list sequentially using the delegate keeper Does nothing if the list is null Skips null elements in the list contextStateKeeperBuilderinternal fun Entity Any Context Any entityListlist ListEntity keeper StateKeeperEntity Context context Context if list null for entity in list if entity null StateKeeperScopeEntity Contextentityaddkeeper context Registers all entities in a given list sequentially using the building block Does nothing if the list is null Skips null elements in the list contextStateKeeperBuilderinternal inline fun Entity Any Context Any entityList list ListEntity context Context block StateKeeperScopeEntity ContextEntity Context Unit if list null for entity in list if entity null StateKeeperScopeEntity Contextentityblockentity context Defines a StateKeeper using a builder DSL This function is supposed to be the main entry point for StateKeeper creation param block a function that defines state preservation rules The function collects rules for each individual owner separately Nested owners can be handled inside entity or entityList blocks internal fun Owner Any Context Any stateKeeperblock contextStateKeeperBuilder StateKeeperScopeOwner ContextOwner Context Unit StateKeeperOwner Context return StateKeeper owner context val states mutableListOfPreservedState val builder object StateKeeperBuilder override fun registerstate PreservedState states state val scope StateKeeperScopeOwner Contextowner blockbuilder scope owner context object PreservedState private var isPostProcessed false private var isRestored false override fun postProcess if isPostProcessed return isPostProcessed true statesforEach itpostProcess override fun restore if isRestored return isRestored true statesforEach itrestore StateKeeper backs up parts of an object state and allows to restore it if errors occur during that object mutation This is not a complete object dumper All preservation rules are explicitly defined usually in the stateKeeper DSL State keeper provides the following life cycle 1 Preparation Back up the state 2 Arrangement For rules with arrangers use the state provider by the arranger 3 Postprocessing Call supplied postprocessors for additional state tweaks 4 Action Perform the potentially failing action 5 Restoration optional Restore the state if the action failed Preparation and arrangement steps are run by calling the prepare function Postprocessing is run by calling PreservedStatepostProcess potentially after some manual tweaks Restoration is run by calling PreservedStaterestore if the action failed sample var state PreservedState null try state keeperprepareowner statepostProcess actionowner catch e Throwable staterestore internal class StateKeeperin Owner Any Context Anyval provider Owner Context PreservedState Backs up the owner state by calling providers and potentially tweaks the object state with arrangers Note that postprocessors are not run during preparation ", "modifier": "", "signature": "fun prepare(owner: Owner, context: Context): PreservedState", "body": "{<EOL> return provider(owner, context)<EOL> }"}
{"docstring": " This class represents the resolver for each FirResolvePhase Usually such the resolver extends the corresponding compiler phase transformer or delegates to it The main difference with original compiler transformers is that we can transform declarations only under the lock of the declaration see LLFirLockProvider for locks implementation Eg to avoid contract violationsorgjetbrainskotlinanalysislowlevelapifirlazyresolveLLFirLazyResolveContractChecker we cannot transform class member declaration under the class lock we have to take the corresponding declaration lock to avoid concurrent issues So at least we have a different implementation for transformations of such declarations as FirFile FirScript and FirRegularClass Due to lazy resolution we have to maintain the resolution order explicitly in some cases as we are not guaranteed by default that all dependencies or outer declarations are resolved before the target one We have resolveDependencies method which describes common dependencies between declarations Also each LLFirResolveTarget can define phasespecific rules Implementations COMPILER_REQUIRED_ANNOTATIONSFirResolvePhaseCOMPILER_REQUIRED_ANNOTATIONS LLFirCompilerRequiredAnnotationsTargetResolver COMPANION_GENERATIONFirResolvePhaseCOMPANION_GENERATION LLFirCompanionGenerationTargetResolver SUPER_TYPESFirResolvePhaseSUPER_TYPES LLFirSuperTypeTargetResolver SEALED_CLASS_INHERITORSFirResolvePhaseSEALED_CLASS_INHERITORS LLFirSealedClassInheritorsLazyResolver TYPESFirResolvePhaseTYPES LLFirTypeTargetResolver STATUSFirResolvePhaseSTATUS LLFirStatusTargetResolver EXPECT_ACTUAL_MATCHINGFirResolvePhaseEXPECT_ACTUAL_MATCHING LLFirExpectActualMatchingTargetResolver CONTRACTSFirResolvePhaseCONTRACTS LLFirContractsTargetResolver IMPLICIT_TYPES_BODY_RESOLVEFirResolvePhaseIMPLICIT_TYPES_BODY_RESOLVE LLFirImplicitBodyTargetResolver CONSTANT_EVALUATIONFirResolvePhaseCONSTANT_EVALUATION LLFirConstantEvaluationTargetResolver ANNOTATION_ARGUMENTSFirResolvePhaseANNOTATION_ARGUMENTS LLFirAnnotationArgumentsTargetResolver BODY_RESOLVEFirResolvePhaseBODY_RESOLVE LLFirBodyTargetResolver see LLFirLockProvider see FirResolvePhase internal sealed class LLFirTargetResolver protected val resolveTarget LLFirResolveTarget val resolverPhase FirResolvePhase LLFirResolveTargetVisitor val resolveTargetSession LLFirSession get resolveTargetsession val resolveTargetScopeSession ScopeSession get resolveTargetSessiongetScopeSession private val lockProvider LLFirLockProvider get LLFirGlobalResolveComponentsgetInstanceresolveTargetSessionlockProvider private val requiresJumpingLock Boolean get resolverPhaseisItAllowedToCallLazyResolveToTheSamePhase private val _containingDeclarations mutableListOfFirDeclaration val containingDeclarations ListFirDeclaration get _containingDeclarations param context used as a context in the case of exception return the last class from containingDeclarations ", "modifier": "", "signature": "fun containingClass(context: FirElement): FirRegularClass", "body": "{<EOL> val containingDeclaration = containingDeclarations.lastOrNull() ?: errorWithAttachment(\"Containing declaration is not found\") {<EOL> withFirEntry(\"context\", context)<EOL> withFirDesignationEntry(\"designation\", resolveTarget.designation)<EOL> }"}
{"docstring": " Replaces the current value at key with a new value computed by computeValue computeValue is invoked exactly once Must be called in a read action If the cache already contains a value v at key cleanup will be performed on it unless the result of the computation is referentially equal to v This behavior enables computation functions to decide to retain an existing value without triggering cleanup computeValue should not modify the cache during computation return The computed value now associated with key fun computekey K computeValue K V V V We need to keep a potentially newly computed value on the stack so that it isnt accidentally garbagecollected before the end of this function Without this variable after backingMapcompute and before the end of this function the soft reference kept in the cache might be the only reference to the new value With unlucky GC timing it might be collected var newValue V null If we replace an existing reference we need to clean it up per the contract of the cache var removedRef SoftReferenceWithCleanupK V null val newRef backingMapcomputekey _ currentRef If currentRef exists but its value is null to the outside it will look like no value existed in the cache It will be cleaned up at the end of compute val currentValue currentRefget newValue computeValuekey currentValue when newValue null removedRef currentRef null Avoid creating another soft reference for the same value for example if f doesnt need to change the cached value though it isnt necessary for correct functioning of the cache If there are multiple soft references for the same value they will all remain valid until the value itself is garbagecollected Cleanup in processQueue will be performed once for each such soft reference which will result in multiple cleanup calls This is legal given the contract of SoftValueCleaner but wasteful and thus best to avoid Also we shouldnt clean up such a reference as per the contract of the compute function newValue currentValue currentRef else removedRef currentRef createSoftReferencekey newValue removedRefperformCleanup processQueue requirenewRefget newValue The newly computed value was already garbagecollected before the end of the compute function return newValue Adds or replaces value toin the cache at the given key Must be called in a read action As replacement constitutes removal cleanup will be performed on the replaced value When the existing value and the new value are the same referentially equal cleanup will not be performed because the existing value effectively wasnt removed from the cache return The old value that has been replaced if any fun putkey K value V V We implement put in terms of backingMapcompute to avoid creation of a new soft reference when the old and the new value are referentially equal A combination of backingMapget and backingMapput would not be atomic because the existing value fetched with backingMapget might be outdated by the time we invoke backingMapput based on the old new comparison This functions implementation is different from CleanableSoftValueCachecompute because put needs to return the old value not the new value var oldValue V null var removedRef SoftReferenceWithCleanupK V null See compute for additional comments on the implementation as it is similar to this implementation backingMapcomputekey _ currentRef val currentValue currentRefget oldValue currentValue if value currentValue returncompute currentRef removedRef currentRef createSoftReferencekey value removedRefperformCleanup processQueue return oldValue Removes the value associated with key from the cache performs cleanup on it and returns it if it exists Must be called in a read action fun removekey K V val ref backingMapremovekey refperformCleanup processQueue return refget Removes all values from the cache and performs cleanup on them Must be called in a write action The write action requirement is due to the complexity associated with atomically clearing a concurrent cache while also performing cleanup on exactly the cleared values Because this cache implementation is used by components which operate in read and write actions requiring a write action is more economical than synchronizing on some cachewide lock fun clear ApplicationManagergetApplicationassertWriteAccessAllowed The backing map will not be modified by other threads during clean because it is executed in a write action backingMapvaluesforEach itperformCleanup backingMapclear processQueue Returns the number of elements in the cache Must be called in a read action val size Int get Process the reference queue first to remove values which have already been garbagecollected to get a more accurate size Still an accurate size is not fully guaranteed as additional garbage collection may occur between processQueue and the end of the function processQueue return backingMapsize Returns whether the cache is empty Must be called in a read action ", "modifier": "", "signature": "fun isEmpty(): Boolean", "body": "{<EOL> // Process the reference queue first to remove values which have already been garbage-collected to get a more accurate answer.<EOL> // Still, accuracy is not fully guaranteed, as additional garbage collection may occur between `processQueue` and the end of the<EOL> // function.<EOL> processQueue()<EOL> return backingMap.isEmpty()<EOL> }"}
{"docstring": " If class is declared in some strange context for example in expression like 10 class A we dont want to try to build a light class for it The expression itself is incorrect and wont compile but the parser is able the parse the class nonetheless This does not concern objects since object literals are expressions and can be used almost anywhere ", "modifier": "private ", "signature": "fun classDeclaredInUnexpectedPosition(classOrObject: KtClassOrObject): Boolean", "body": "{<EOL> if (classOrObject is KtObjectDeclaration) return false<EOL><EOL> val classParent = classOrObject.parent<EOL><EOL> return classParent !is KtBlockExpression &&<EOL> classParent !is KtDeclarationContainer<EOL>}"}
{"docstring": " Returns an extension applicability checker for the given context nameExpression The function is meant to only be used for providing autocompletion for Kotlin in IntelliJ IDEA The returned checker does not cache the results for individual callable candidates param originalFile The file being edited param nameExpression The expression under the caret in an inmemory copy of originalFile with a dummy identifier inserted Also see CompletionUtilCoreDUMMY_IDENTIFIER in IntelliJ IDEA param explicitReceiver A receiver expression if available also from the inmemory copy of originalFile ", "modifier": "public ", "signature": "fun createExtensionCandidateChecker(\n        originalFile: KtFile,\n        nameExpression: KtSimpleNameExpression,\n        explicitReceiver: KtExpression?\n    ): KtCompletionExtensionCandidateChecker", "body": "{<EOL> return analysisSession.completionCandidateChecker.createExtensionCandidateChecker(<EOL> originalFile,<EOL> nameExpression,<EOL> explicitReceiver<EOL> )<EOL> }"}
{"docstring": " Check that given method is a synthetic componentN method of a data class ", "modifier": "private ", "signature": "fun isComponentNMethod(method: CallableMemberDescriptor): Boolean", "body": "{<EOL> if ((method as? FunctionDescriptor)?.isOperator != true) return false<EOL> val parent = method.containingDeclaration<EOL> if (parent is ClassDescriptor && parent.isData && DataClassResolver.isComponentLike(method.name)) {<EOL> // componentN method of data class.<EOL> return true<EOL> }"}
{"docstring": " Combines several implementations to a single KtObjCExportModuleNaming The order of implementations matters The first implementation to resopnd with a module name will win ", "modifier": "", "signature": "fun KtObjCExportModuleNaming(implementations: List<KtObjCExportModuleNaming>): KtObjCExportModuleNaming", "body": "{<EOL> return KtCompositeObjCExportModuleNaming(implementations)<EOL>}"}
{"docstring": " Encapsulates the dynamic nature of the ObjCExport where only during the export phase decisions about 1 Which symbols are to be exported 2 In which order symbols are to be exported can be made Functions inside this class will have side effects such as mutating the classDeque or adding results to the objCStubs private class KtObjCExportHeaderGenerator private val withObjCBaseDeclarations Boolean Represents a queue containing pointers to all classes that are to be translated later This happens eg when a class is referenced inside a callable signature Such dependency types are to be translated private val classDeque ArrayDequeClassId The mutable aggregate of the already translated elements private val objCStubs mutableListOfObjCTopLevel An index of all already translated classes All classes here are also present in objCStubs private val objCStubsByClassId hashMapOfClassId ObjCClass An index of already translated classes by ObjC name private val objCStubsByClassName hashMapOfString ObjCClass The mutable aggregate of all protocol names that shall later be rendered as forward declarations private val objCProtocolForwardDeclarations mutableSetOfString The mutable aggregate of all class names that shall later be rendered as forward declarations private val objCClassForwardDeclarations mutableSetOfString contextKtAnalysisSession KtObjCExportSession fun translateAllfiles ListKtObjCExportFile Step 1 Translate classifiers class interface object filesforEach file translateFileClassifiersfile Step 2 Translate file facades see translateToTopLevelFileFacade translateToExtensionFacade This step has to be done after all classifiers were translated to match the translation order of K1 filesforEach file translateFileFacadesfile Step 3 Translate dependency classes referenced by Step 1 and Step 2 Note Transitive dependencies will still add to this queue and will be processed until were finished while true translateClassclassDequeremoveFirstOrNull break contextKtAnalysisSession KtObjCExportSession private fun translateClassclassId ClassId val classOrObjectSymbol getClassOrObjectSymbolByClassIdclassId return translateClassOrObjectSymbolclassOrObjectSymbol contextKtAnalysisSession KtObjCExportSession private fun translateFileClassifiersfile KtObjCExportFile val resolvedFile fileresolve resolvedFileclassifierSymbolssortedWithStableClassifierOrderforEach classOrObjectSymbol translateClassOrObjectSymbolclassOrObjectSymbol contextKtAnalysisSession KtObjCExportSession private fun translateFileFacadesfile KtObjCExportFile val resolvedFile fileresolve resolvedFiletranslateToObjCExtensionFacadesforEach facade objCStubs facade enqueueDependencyClassesfacade objCClassForwardDeclarations facadename resolvedFiletranslateToObjCTopLevelFacadelet topLevelFacade objCStubs topLevelFacade enqueueDependencyClassestopLevelFacade contextKtAnalysisSession KtObjCExportSession private fun translateClassOrObjectSymbolsymbol KtClassOrObjectSymbol ObjCClass No classId no stubs _\u30c4_ val classId symbolclassIdIfNonLocal return null Already processed this class therefore nothing to do if classId in objCStubsByClassId return objCStubsByClassIdclassId Translate Note Even if the result was null the classId will still be marked as handled by adding it to the objCStubsByClassId index val objCClass symboltranslateToObjCExportStub objCStubsByClassIdclassId objCClass objCClass return null To replicate the translation and result stub order of the K1 implementation 1 Super interface superclass symbols have to be translated right away 2 Super interface superclass symbol export stubs result of translation have to be present in the stubs list before the original stub symbolgetDeclaredSuperInterfaceSymbolsfilter itisVisibleInObjC forEach superInterfaceSymbol translateClassOrObjectSymbolsuperInterfaceSymbollet objCProtocolForwardDeclarations itname symbolgetSuperClassSymbolNotAnytakeIf itisVisibleInObjC let superClassSymbol translateClassOrObjectSymbolsuperClassSymbollet objCClassForwardDeclarations itname Note It is important to add this stub to the result list only after translatingprocessing the superclass symbols objCStubs objCClass objCStubsByClassNameobjCClassname objCClass enqueueDependencyClassesobjCClass return objCClass Will introspect the given stub to collect all used dependency typesclasses Example Usage of Kotlin Stdlib Type Array class Foo fun createArray ArrayString errorstub The given symbol Foo will reference Array Therefore the Array class has to be translated as well later and Array has to be registered as forward declaration private fun enqueueDependencyClassesstub ObjCExportStub classDeque stubclosureSequence flatMap child childthrowsAnnotationClassIdsorEmpty classDeque stubclosureSequence mapNotNull child when child is ObjCMethod childreturnType is ObjCParameter childtype is ObjCProperty childtype is ObjCTopLevel null flatMap type if type is ObjCClassType typetypeArguments type else listOftype filterIsInstanceObjCReferenceType onEach type if typerequiresForwardDeclaration returnonEach val nonNullType if type is ObjCNullableReferenceType typenonNullType else type if nonNullType is ObjCClassType objCClassForwardDeclarations nonNullTypeclassName if nonNullType is ObjCProtocolType objCProtocolForwardDeclarations nonNullTypeprotocolName mapNotNull itoriginClassId objCClassForwardDeclarations are recorded by their respective class name This method will resolve the objc interface that was translated which is associated with the className and build the respective ObjCClassForwardDeclaration from it If no such class was explicitly translated a simple ObjCClassForwardDeclaration will be emitted that does not carry any generics ", "modifier": "private ", "signature": "fun resolveObjCClassForwardDeclaration(className: String): ObjCClassForwardDeclaration", "body": "{<EOL> objCStubsByClassName[className]<EOL> .let { it as? ObjCInterface }"}
{"docstring": " The resolved version of the KtObjCExportFile Resolved means that all symbols associated with the file are loaded and available under classifierSymbols and callableSymbols data class KtResolvedObjCExportFile val fileName String val packageFqName FqName val classifierSymbols ListKtClassOrObjectSymbol val callableSymbols ListKtCallableSymbol Factory functions ", "modifier": "", "signature": "fun KtObjCExportFile(file: KtFile): KtObjCExportFile", "body": "{<EOL> return KtPsiObjCExportFile(file)<EOL>}"}
{"docstring": " Here we only check that we are casting to a forward declaration to suppress a CAST_NEVER_SUCCEEDS warning The cast is further checked in NativeForwardDeclarationRttiChecker ", "modifier": "private ", "signature": "fun isCastToAForwardDeclaration(forwardDeclarationType: KotlinType): Boolean", "body": "{<EOL> val forwardDeclarationClassDescriptor = forwardDeclarationType.constructor.declarationDescriptor<EOL> if (forwardDeclarationClassDescriptor !is ClassDescriptor) return false<EOL> return forwardDeclarationClassDescriptor.getForwardDeclarationKindOrNull() != null<EOL> }"}
{"docstring": " Redownload the file and replace the existing one REPLACE Throw FileAlreadyExistsException THROW Dont download the file and return the existing one RETURN_EXISTING class HTTPResponseExceptionval url URL val responseCode Int IOExceptionServer returned HTTP response code responseCode for URL url class DownloadingProgressVolatile var currentBytes Long fun updatereadBytes Int currentBytes readBytes private fun HttpURLConnectioncheckHTTPResponseexpected Int originalUrl URL url if responseCode expected throw HTTPResponseExceptionoriginalUrl responseCode private fun HttpURLConnectioncheckHTTPResponseoriginalUrl URL predicate Int Boolean if predicateresponseCode throw HTTPResponseExceptionoriginalUrl responseCode private fun doDownloadoriginalUrl URL connection URLConnection tmpFile File currentBytes Long totalBytes Long append Boolean val progress DownloadingProgresscurrentBytes TODO Implement multithread downloading executorsubmit connectiongetInputStreamuse from FileOutputStreamtmpFile appenduse to val buffer ByteArrayDEFAULT_BUFFER_SIZE var read fromreadbuffer while read 1 if Threadinterrupted throw InterruptedException towritebuffer 0 read progressupdateread read fromreadbuffer if progresscurrentBytes totalBytes throw EOFExceptionThe stream closed before end of downloading var result FutureUnit do progressCallbackoriginalUrltoString progresscurrentBytes totalBytes result executorpoll1 TimeUnitSECONDS whileresult null progressCallbackoriginalUrltoString progresscurrentBytes totalBytes try resultget catch e ExecutionException throw ecause e private fun resumeDownloadoriginalUrl URL originalConnection HttpURLConnection tmpFile File originalConnectionconnect val totalBytes originalConnectioncontentLengthLong val currentBytes tmpFilelength if currentBytes totalBytes originalConnectiongetHeaderFieldAcceptRanges bytes The temporary file is bigger then expected or the server doesnt support resuming downloading Download the file from scratch doDownloadoriginalUrl originalConnection tmpFile 0 totalBytes false else originalConnectiondisconnect val rangeConnection originalUrlopenConnection as HttpURLConnection rangeConnectionsetRequestPropertyrange bytescurrentBytes rangeConnectionconnect rangeConnectioncheckHTTPResponseoriginalUrl it HttpURLConnectionHTTP_PARTIAL it HttpURLConnectionHTTP_OK doDownloadoriginalUrl rangeConnection tmpFile currentBytes totalBytes true Performs an attempt to download a specified file into the specified location private fun tryDownloadurl URL tmpFile File val connection urlopenConnection connection as HttpURLConnectioncheckHTTPResponseHttpURLConnectionHTTP_OK url if connection is HttpURLConnection tmpFileexists resumeDownloadurl connection tmpFile else connectionconnect val totalBytes connectioncontentLengthLong doDownloadurl connection tmpFile 0 totalBytes false Downloads a file from source url to destination Returns destination ", "modifier": "", "signature": "fun download(source: URL,\n                 destination: File,\n                 replace: ReplacingMode = ReplacingMode.RETURN_EXISTING): File", "body": "{<EOL><EOL> if (destination.exists()) {<EOL> when (replace) {<EOL> ReplacingMode.RETURN_EXISTING -> return destination<EOL> ReplacingMode.THROW -> throw FileAlreadyExistsException(destination)<EOL> ReplacingMode.REPLACE -> Unit // Just continue with downloading.<EOL> }"}
{"docstring": " Classical way to describe a target platform Despite its name may contain more or less than 3 components Example arm64appleiossimulator arm64 target hardware apple vendor ios operating system simulator environment see a hrefhttpsclangllvmorgdocsCrossCompilationhtmltargettripleClang documentation for target triplea data class TargetTriple val architecture String val vendor String val os String val environment String companion object Parse archvendorosenvironment tripleString TODO Support normalization like LLVMs Triplenormalize ", "modifier": "", "signature": "fun fromString(tripleString: String): TargetTriple", "body": "{<EOL> val components = tripleString.split('-')<EOL> // TODO: There might be other cases (e.g. of size 2 or 5),<EOL> // but let's support only these for now.<EOL> require(components.size == 3 || components.size == 4) {<EOL> \"Malformed target triple: $tripleString. Expected format: <arch>-<vendor>-<os>-<environment?>.\"<EOL> }"}
{"docstring": " Path to the executable var executableAbsolutePath String Command line args val args MutableListString mutableListOf Optional working directory By default its the parent directory of executableAbsolutePath var workingDirectory File null Will be sent to the executable input and then closed By default an empty stream var stdin InputStream ByteArrayInputStreambyteArrayOf The output stream of the executable will be sent to this stream and then this stream will be closed By default stdout of current process var stdout OutputStream CloseProtectedOutputStreamSystemout The error stream of the executable will be sent to this stream and then this stream will be closed By default stderr of current process var stderr OutputStream CloseProtectedOutputStreamSystemerr Additional environment variables val environment MutableMapString String mutableMapOf Bound execution time of the process By default its DurationINFINITE meaning its unbounded var timeout Duration DurationINFINITE Create a copy of this ExecuteRequest modify the copy by running block on it and return that copy inline fun copyingblock ExecuteRequest Unit ExecuteRequest copyapplyblockdata class ExecuteResponse Process exit code if it exited by itself or null if it was killed by a timeout val exitCode Int Execution time of the process Can be a bit bigger than ExecuteRequesttimeout val executionTime Duration Checks that exitCode is 0 throws IllegalStateException if exitCode is not 0 ", "modifier": "", "signature": "fun assertSuccess(): ExecuteResponse", "body": "{<EOL> check(exitCode == 0) {<EOL> if (exitCode == null) {<EOL> \"Timed out in $executionTime\"<EOL> }"}
{"docstring": " Executor that runs the process using Apples Rosetta 2 param configurables Configurables for target class RosettaExecutor private val configurables AppleConfigurables Executor companion object Returns true if running via Rosetta 2 can be made available for given configurables This does not check that Rosetta 2 is installed ", "modifier": "", "signature": "fun availableFor(configurables: AppleConfigurables): Boolean", "body": "{<EOL> return HostManager.host is KonanTarget.MACOS_ARM64 && configurables.target is KonanTarget.MACOS_X64<EOL> }"}
{"docstring": " Compares two strings assuming that both are representing numeric version strings Examples of numeric version strings 12412 9 05 ", "modifier": "private ", "signature": "fun compareStringsAsVersions(version1: String, version2: String): Int", "body": "{<EOL> val splitVersion1 = version1.split('.').map { it.toInt() }"}
{"docstring": " Returns parsed output of xcrun simctl list runtimes j private fun XcodegetSimulatorRuntimeDescriptors ListSimulatorRuntimeDescriptor gsonfromJsonsimulatorRuntimes ListRuntimesReportclassjavaruntimesprivate fun getSimulatorRuntimeDescriptorsjson String ListSimulatorRuntimeDescriptor gsonfromJsonjson ListRuntimesReportclassjavaruntimesprivate fun getLatestSimulatorRuntimeFor descriptors ListSimulatorRuntimeDescriptor family Family osMinVersion String SimulatorRuntimeDescriptor val osName simulatorOsNamefamily return descriptorsfirstOrNull itcheckAvailability itnamestartsWithosName compareStringsAsVersionsitversion osMinVersion 0 private fun getSimulatorRuntimesFor descriptors ListSimulatorRuntimeDescriptor family Family osMinVersion String ListSimulatorRuntimeDescriptor val osName simulatorOsNamefamily return descriptorsfilter itcheckAvailability itnamestartsWithosName compareStringsAsVersionsitversion osMinVersion 0 Returns first available simulator runtime for target with at least osMinVersion OS version fun XcodegetLatestSimulatorRuntimeForfamily Family osMinVersion String SimulatorRuntimeDescriptor getLatestSimulatorRuntimeForgetSimulatorRuntimeDescriptors family osMinVersionfun getLatestSimulatorRuntimeForjson String family Family osMinVersion String SimulatorRuntimeDescriptor getLatestSimulatorRuntimeForgetSimulatorRuntimeDescriptorsjson family osMinVersionfun getSimulatorRuntimesForjson String family Family osMinVersion String ListSimulatorRuntimeDescriptor getSimulatorRuntimesForgetSimulatorRuntimeDescriptorsjson family osMinVersion Result of xcrun simctl list runtimes jdata class ListRuntimesReport Expose val runtimes ListSimulatorRuntimeDescriptordata class SimulatorRuntimeDescriptor Expose val version String bundlePath field may not exist in the old Xcode prior to 103 Expose val bundlePath String null Expose val isAvailable Boolean null Expose val availability String null Expose val name String Expose val identifier String Expose val buildversion String Expose val supportedDeviceTypes ListDeviceType Different XcodemacOS combinations give different fields that checks runtime availability This method is an umbrella for these fields ", "modifier": "", "signature": "fun checkAvailability(): Boolean", "body": "{<EOL> if (isAvailable == true) return true<EOL> if (availability?.contains(\"unavailable\") == true) return false<EOL> return false<EOL> }"}
{"docstring": " Description of a Kotlin function for which we are creating the bridge param callable SIR function we are generating bridge for param bridgeName C name of the bridge public class BridgeRequest public val callable SirCallable public val bridgeName String public val fqName ListString Generates the body of a function from a given request param request the BridgeRequest object that contains information about the function and the bridge return the generated SirFunctionBody object representing the body of the function ", "modifier": "public ", "signature": "fun createFunctionBodyFromRequest(request: BridgeRequest): SirFunctionBody", "body": "{<EOL> val callee = request.cDeclarationName()<EOL> val calleeArguments = request.callable.allParameters.map { it.name }"}
{"docstring": " Should SirInit node be marked as override For now the implementation is rather trivial it just checks that the superclass has an init method with the same list of parameters ", "modifier": "public ", "signature": "fun computeIsOverrideForDesignatedInit(parent: SirDeclarationParent, parameters: List<SirParameter>): Boolean", "body": "{<EOL> if (parent !is SirClass) return false<EOL> val superClass = (parent.superClass as? SirNominalType)?.type<EOL> ?: return false<EOL> require(superClass is SirClass)<EOL> val overridesDesignatedInitFromSuper = superClass.declarations<EOL> .filterIsInstance<SirInit>()<EOL> .filter { it.initKind == SirInitializerKind.ORDINARY }"}
{"docstring": " Will load all forward declarations provided by all modules into a flat CirProvidedClassifiers Note This builds a union not an intersection of forward declarations ", "modifier": "", "signature": "fun loadExportedForwardDeclarations(modulesProviders: List<ModulesProvider>): CirProvidedClassifiers", "body": "{<EOL> val classifiers = CommonizerMap<CirEntityId, CirProvided.Classifier>()<EOL><EOL> modulesProviders.flatMap { moduleProvider -> moduleProvider.moduleInfos }"}
{"docstring": " Mostly mimics orgjetbrainskotlinbackendkonanpsiToIr since direct call is impossible due to prohibited import of module kotlinnativebackendnative here to nativenativetests invocation via reflection is complicated due to moving comintellijopenapiprojectProject to another subpackage during compiler JAR embedding Its unlikely that orgjetbrainskotlinbackendkonanpsiToIr would be ever significantly changed before reaching its endoflife so its plausible to have a reduced copy here in the test pipeline ", "modifier": "private ", "signature": "fun transformToNativeIr(module: TestModule, inputArtifact: ClassicFrontendOutputArtifact): IrBackendInput", "body": "{<EOL> val (psiFiles, analysisResult, project, _) = inputArtifact<EOL><EOL> val configuration = testServices.compilerConfigurationProvider.getCompilerConfiguration(module)<EOL><EOL> val sourceFiles: List<KtFile> = psiFiles.values.toList()<EOL> val translator = Psi2IrTranslator(<EOL> configuration.languageVersionSettings,<EOL> Psi2IrConfiguration(<EOL> ignoreErrors = CodegenTestDirectives.IGNORE_ERRORS in module.directives,<EOL> configuration.partialLinkageConfig.isEnabled<EOL> ),<EOL> configuration.irMessageLogger::checkNoUnboundSymbols<EOL> )<EOL> val manglerDesc = KonanManglerDesc<EOL> val konanIdSignaturerClass = kotlinNativeClass(\"org.jetbrains.kotlin.backend.konan.serialization.KonanIdSignaturer\")<EOL> val konanIdSignaturerConstructor = konanIdSignaturerClass.constructors.single()<EOL> val konanIdSignaturerClassInstance = konanIdSignaturerConstructor.call(manglerDesc) as IdSignatureComposer<EOL> val symbolTable = SymbolTable(konanIdSignaturerClassInstance, IrFactoryImpl)<EOL> val generatorContext = translator.createGeneratorContext(<EOL> analysisResult.moduleDescriptor,<EOL> analysisResult.bindingContext,<EOL> symbolTable<EOL> )<EOL><EOL> val konanStubGeneratorExtensionsClass = kotlinNativeClass(\"org.jetbrains.kotlin.backend.konan.KonanStubGeneratorExtensions\")<EOL> val stubGenerator = DeclarationStubGeneratorImpl(<EOL> analysisResult.moduleDescriptor, symbolTable,<EOL> generatorContext.irBuiltIns,<EOL> DescriptorByIdSignatureFinderImpl(analysisResult.moduleDescriptor, manglerDesc),<EOL> konanStubGeneratorExtensionsClass.objectInstance as StubGeneratorExtensions<EOL> ).apply {<EOL> unboundSymbolGeneration = true<EOL> }"}
{"docstring": " Test class settings common part private fun ExtensionContextaddCommonTestClassSettingsTo enclosingTestClass Class output MutableCollectionAny KotlinNativeTargets val enforcedProperties EnforcedPropertiesenclosingTestClass val optimizationMode computeOptimizationModeenforcedProperties val threadStateChecker computeThreadStateCheckerenforcedProperties if threadStateChecker ThreadStateCheckerENABLED assertEqualsOptimizationModeDEBUG optimizationMode Thread state checker can be enabled only with debug optimization mode val sanitizer computeSanitizerenforcedProperties val gcType computeGCTypeenforcedProperties val gcScheduler computeGCSchedulerenforcedProperties val allocator computeAllocatorenforcedProperties val nativeHome getOrCreateTestProcessSettingsgetKotlinNativeHome val distribution DistributionnativeHomedirpath val hostManager HostManager val nativeTargets computeNativeTargetsenforcedProperties hostManager val cacheMode computeCacheModeenforcedProperties distribution nativeTargets optimizationMode if cacheMode CacheModeWithoutCache assertEqualsThreadStateCheckerDISABLED threadStateChecker Thread state checker can not be used with cache assertEqualsSanitizerNONE sanitizer Sanitizer can not be used with cache output optimizationMode output threadStateChecker output gcType output gcScheduler output allocator output nativeTargets output sanitizer output CacheModeclass to cacheMode output computeTestModeenforcedProperties output computeCompilerPluginsenforcedProperties output computeCustomKlibsenforcedProperties output computeTestKindenforcedProperties output computeForcedNoopTestRunnerenforcedProperties output computeSharedExecutionTestRunnerenforcedProperties output computeTimeoutsenforcedProperties Parse annotations of current class since theres no way to put annotations to upperlevel enclosing class output computePipelineTypeenforcedProperties testClassget output computeUsedPartialLinkageConfigenclosingTestClass output computeCompilerOutputInterceptorenforcedProperties output computeBinaryLibraryKindenforcedProperties output computeCInterfaceModeenforcedProperties return nativeTargets private fun computeOptimizationModeenforcedProperties EnforcedProperties OptimizationMode ClassLevelPropertyOPTIMIZATION_MODEreadValue enforcedProperties OptimizationModevalues default OptimizationModeDEBUG private fun computeThreadStateCheckerenforcedProperties EnforcedProperties ThreadStateChecker val useThreadStateChecker ClassLevelPropertyUSE_THREAD_STATE_CHECKERreadValueenforcedProperties StringtoBooleanStrictOrNull default false return if useThreadStateChecker ThreadStateCheckerENABLED else ThreadStateCheckerDISABLED private fun computeSanitizerenforcedProperties EnforcedProperties Sanitizer ClassLevelPropertySANITIZERreadValueenforcedProperties Sanitizervalues default SanitizerNONE private fun computeCompilerOutputInterceptorenforcedProperties EnforcedProperties CompilerOutputInterceptor ClassLevelPropertyCOMPILER_OUTPUT_INTERCEPTORreadValue enforcedProperties CompilerOutputInterceptorvalues default CompilerOutputInterceptorDEFAULT private fun computeGCTypeenforcedProperties EnforcedProperties GCType ClassLevelPropertyGC_TYPEreadValueenforcedProperties GCTypevalues default GCTypeUNSPECIFIED private fun computeGCSchedulerenforcedProperties EnforcedProperties GCScheduler ClassLevelPropertyGC_SCHEDULERreadValueenforcedProperties GCSchedulervalues default GCSchedulerUNSPECIFIED private fun computeAllocatorenforcedProperties EnforcedProperties Allocator ClassLevelPropertyALLOCATORreadValueenforcedProperties Allocatorvalues default AllocatorUNSPECIFIED private fun computeNativeTargetsenforcedProperties EnforcedProperties hostManager HostManager KotlinNativeTargets val hostTarget HostManagerhost return KotlinNativeTargets testTarget ClassLevelPropertyTEST_TARGETreadValue enforcedProperties hostManagertargetByName default hostTarget hostTarget hostTarget private fun computeCacheMode enforcedProperties EnforcedProperties distribution Distribution kotlinNativeTargets KotlinNativeTargets optimizationMode OptimizationMode CacheMode val defaultCache CacheModedefaultForTestTargetdistribution kotlinNativeTargets val cacheMode ClassLevelPropertyCACHE_MODEreadValue enforcedProperties CacheModeAliasvalues default if optimizationMode OptimizationModeOPT defaultCache else CacheModeAliasNO val useStaticCacheForUserLibraries when cacheMode CacheModeAliasNO return CacheModeWithoutCache CacheModeAliasSTATIC_ONLY_DIST false CacheModeAliasSTATIC_EVERYWHERE true CacheModeAliasSTATIC_PER_FILE_EVERYWHERE true CacheModeAliasSTATIC_USE_HEADERS_EVERYWHERE true val makePerFileCaches cacheMode CacheModeAliasSTATIC_PER_FILE_EVERYWHERE val useHeaders cacheMode CacheModeAliasSTATIC_USE_HEADERS_EVERYWHERE return if defaultCache CacheModeAliasNO CacheModeWithoutCache else CacheModeWithStaticCache distribution kotlinNativeTargets optimizationMode useStaticCacheForUserLibraries makePerFileCaches useHeaders cacheMode private fun computeTestModeenforcedProperties EnforcedProperties TestMode ClassLevelPropertyTEST_MODEreadValueenforcedProperties TestModevalues default TestModeTWO_STAGE_MULTI_MODULE private fun computeCompilerPluginsenforcedProperties EnforcedProperties CompilerPlugins CompilerPlugins ClassLevelPropertyCOMPILER_PLUGINSreadValue enforcedProperties itsplitFilepathSeparatorCharmapToSetFile default emptySet private fun computeCustomKlibsenforcedProperties EnforcedProperties CustomKlibs CustomKlibs ClassLevelPropertyCUSTOM_KLIBSreadValue enforcedProperties itsplitFilepathSeparatorCharmapToSetFile default emptySet private fun computeTestKindenforcedProperties EnforcedProperties TestKind ClassLevelPropertyTEST_KINDreadValue enforcedProperties TestKindvalues default TestKindREGULAR private fun computeForcedNoopTestRunnerenforcedProperties EnforcedProperties ForcedNoopTestRunner ForcedNoopTestRunner ClassLevelPropertyCOMPILE_ONLYreadValue enforcedProperties StringtoBooleanStrictOrNull default false private fun computeSharedExecutionTestRunnerenforcedProperties EnforcedProperties SharedExecutionTestRunner SharedExecutionTestRunner ClassLevelPropertySHARED_TEST_EXECUTIONreadValue enforcedProperties StringtoBooleanStrictOrNull default false private fun computeTimeoutsenforcedProperties EnforcedProperties Timeouts val executionTimeout ClassLevelPropertyEXECUTION_TIMEOUTreadValue enforcedProperties DurationparseOrNullit default TimeoutsDEFAULT_EXECUTION_TIMEOUT return TimeoutsexecutionTimeout Test class settings for black box tests only private fun ExtensionContextgetOrCreateTestClassSettings TestClassSettings rootgetStoreNAMESPACEgetOrComputeIfAbsenttestClassKeyForTestClassSettings val enclosingTestClass enclosingTestClass val testProcessSettings getOrCreateTestProcessSettings val computedTestConfiguration computeTestConfigurationenclosingTestClassrun if TestGroupCreationgetFromProperty TestGroupCreationEAGER configurationproviderClass ExtTestCaseGroupProviderclass val annotation UseEagerExtTestCaseGroupProvider val testConfiguration annotationannotationClassfindAnnotationTestConfiguration errorUnable to find annotation for Eager test group creation ComputedTestConfigurationtestConfiguration annotation else this val settings buildList Put common settings val nativeTargets addCommonTestClassSettingsToenclosingTestClass this Put settings that are always required this computedTestConfiguration this computeBinariesForBlackBoxTeststestProcessSettingsget nativeTargets enclosingTestClass Add custom settings computedTestConfigurationconfigurationrequiredSettingsforEach clazz this when clazz TestRootsclass computeTestRootsenclosingTestClass GeneratedSourcesclass computeGeneratedSourceDirstestProcessSettingsget nativeTargets enclosingTestClass DisabledTestDataFilesclass computeDisabledTestDataFilesenclosingTestClass else fail Unknown test class setting type clazz TestClassSettingsparent testProcessSettings settings as TestClassSettings private fun computeTestConfigurationenclosingTestClass Class ComputedTestConfiguration val findTestConfiguration Class ComputedTestConfiguration annotationsasSequencemapNotNull annotation val testConfiguration annotationannotationClassfindAnnotationTestConfiguration returnmapNotNull null ComputedTestConfigurationtestConfiguration annotation firstOrNull return enclosingTestClassfindTestConfiguration enclosingTestClassdeclaredClassesfirstNotNullOfOrNull itfindTestConfiguration fail No TestConfigurationclasssimpleName annotation found on test classes private fun computeDisabledTestDataFilesenclosingTestClass Class DisabledTestDataFiles val filesAndDirectories buildSet fun contributeSourceLocationssourceLocations ArrayString sourceLocationsforEach expandGlobTogetAbsoluteFileit this fun recurseclazz Class clazzallInheritedAnnotationsforEach annotation when annotation is DisabledTests contributeSourceLocationsannotationsourceLocations is DisabledTestsIfProperty if SystemgetPropertyannotationpropertypropertyName annotationpropertyValue contributeSourceLocationsannotationsourceLocations clazzdeclaredClassesforEachrecurse recurseenclosingTestClass return DisabledTestDataFilesfilesAndDirectories private fun computeTestRootsenclosingTestClass Class TestRoots fun TestMetadatatestRoot getAbsoluteFilelocalPath value val testRoots SetFile when val outermostTestMetadata enclosingTestClassgetAnnotationTestMetadataclassjava null enclosingTestClassdeclaredClassesmapNotNullToSet nestedClass nestedClassgetAnnotationTestMetadataclassjavatestRoot else setOfoutermostTestMetadatatestRoot val baseDir File when testRootssize 0 fail No test roots found for enclosingTestClass test class 1 testRootsfirstparentFile else val baseDirs testRootsmapToSet itparentFile assertEquals1 baseDirssize Controversial base directories computed for test roots for enclosingTestClass test class baseDirs baseDirsfirst return TestRootstestRoots baseDir private fun computeGeneratedSourceDirs baseDirs BaseDirs targets KotlinNativeTargets enclosingTestClass Class GeneratedSources val testSourcesDir baseDirstestBuildDir resolvebbsrc bb for black box resolvetargetstestTargetcompressedName_enclosingTestClasscompressedSimpleName ensureExistsAndIsEmptyDirectory Cleanup the directory with all potentially stale generated sources val sharedSourcesDir testSourcesDir resolveSHARED_MODULES_DIR_NAME ensureExistsAndIsEmptyDirectory return GeneratedSourcestestSourcesDir sharedSourcesDir See also computeBinariesForSimpleTests ", "modifier": "private ", "signature": "fun computeBinariesForBlackBoxTests(\n        baseDirs: BaseDirs,\n        targets: KotlinNativeTargets,\n        enclosingTestClass: Class<*>\n    ): Binaries", "body": "{<EOL> val testBinariesDir = baseDirs.testBuildDir<EOL> .resolve(\"bb.out\") // \"bb\" for black box<EOL> .resolve(\"${targets.testTarget.compressedName}"}
{"docstring": " Required because kotlincompilerembeddable performs package relocation If theres a kotlinxcollectionsimmutable string literal in bytecode it becomes orgjetbrainskotlinkotlinxcollectionsimmutable thus breaking target project class name matching ", "modifier": "", "signature": "fun kotlinxImmutable(name: String? = null): String", "body": "{<EOL> return listOfNotNull(\"kotlinx\", \"collections\", \"immutable\", name).joinToString(\".\")<EOL>}"}
{"docstring": " Resolve the given irType to a corresponding IrParcelSerializer This depends on the TypeParcelers which are currently in scope as well as the type of the enclosing Parceleable class parcelizeType which is needed to get a class loader for reflection based serialization Beyond this we need to know whether to allow using readwriteValue for serialization if strict is false Beyond this we need to know whether we are producing parcelers for properties of a Parcelable if toplevel is true or for a complete Parcelable ", "modifier": "", "signature": "fun get(\n        irType: IrType,\n        scope: IrParcelerScope?,\n        parcelizeType: IrType,\n        strict: Boolean = false,\n        toplevel: Boolean = false\n    ): IrParcelSerializer", "body": "{<EOL> fun strict() = strict && !irType.hasAnyAnnotation(RAW_VALUE_ANNOTATION_FQ_NAMES)<EOL><EOL> scope.getCustomSerializer(irType)?.let { parceler -><EOL> return IrCustomParcelSerializer(parceler)<EOL> }"}
{"docstring": " Responsible for determining the diagram display offset of the expression beginning from the startOffset of the expression Equality number 42 startOffset display offset 7 Arithmetic i 2 startOffset display offset 2 Infix 1 shl 2 startOffset display offset 2 Standard 1shl2 startOffset display offset 0 ", "modifier": "private ", "signature": "fun findDisplayOffset(\n    expression: IrExpression,\n    sourceRangeInfo: SourceRangeInfo,\n    source: String,\n): Int", "body": "{<EOL> return when (expression) {<EOL> is IrMemberAccessExpression<*> -> memberAccessOffset(expression, sourceRangeInfo, source)<EOL> is IrTypeOperatorCall -> typeOperatorOffset(expression, sourceRangeInfo, source)<EOL> else -> 0<EOL> }"}
{"docstring": " The offset of the infix operatorfunction token itself param lhs The lefthand side expression of the operator param wholeOperatorSourceRangeInfo The source range of the whole operator expression param wholeOperatorSource The source text of the whole operator expression ", "modifier": "private ", "signature": "fun binaryOperatorOffset(lhs: IrExpression, wholeOperatorSourceRangeInfo: SourceRangeInfo, wholeOperatorSource: String): Int", "body": "{<EOL> val offset = lhs.endOffset - wholeOperatorSourceRangeInfo.startOffset<EOL> if (offset < 0 || offset >= wholeOperatorSource.length) return 0 // infix function called using non-infix syntax<EOL><EOL> KotlinLexer().run {<EOL> start(wholeOperatorSource, offset, wholeOperatorSource.length)<EOL> while (tokenType != null && tokenType != KtTokens.EOF && (tokenType == KtTokens.DOT || tokenType !in KtTokens.OPERATIONS)) {<EOL> advance()<EOL> }"}
{"docstring": " Provides synthetic parts to java classes from current compilation unit which will be generated by lombok AnnotationProcessor So kotlin can reference lombok members SuppressIncorrectFormatting KTIJ22227class LombokSyntheticJavaPartsProviderconfig LombokConfig SyntheticJavaPartsProvider private val processors listOf GetterProcessorconfig SetterProcessorconfig WithProcessor NoArgsConstructorProcessor AllArgsConstructorProcessor RequiredArgsConstructorProcessor BuilderProcessorconfig private val valueFieldModifier ValueFieldModifierconfig kotlin resolve references in two calls first it gets names then actual member descriptor but for us it is much easier to run full generation for class once hence we cache results and reuse it private val partsCache MutableMapClassDescriptor SyntheticParts HashMap override fun getMethodNamesthisDescriptor ClassDescriptor c LazyJavaResolverContext ListName cgetSyntheticPartsthisDescriptormethodsmap itname override fun generateMethods thisDescriptor ClassDescriptor name Name result MutableCollectionSimpleFunctionDescriptor c LazyJavaResolverContext val methods cgetSyntheticPartsthisDescriptormethodsfilter itname name addNonExistentresult methods override fun getStaticFunctionNamesthisDescriptor ClassDescriptor c LazyJavaResolverContext ListName cgetSyntheticPartsthisDescriptorstaticFunctionsmap itname override fun generateStaticFunctions thisDescriptor ClassDescriptor name Name result MutableCollectionSimpleFunctionDescriptor c LazyJavaResolverContext val functions cgetSyntheticPartsthisDescriptorstaticFunctionsfilter itname name addNonExistentresult functions override fun generateConstructors thisDescriptor ClassDescriptor result MutableListClassConstructorDescriptor c LazyJavaResolverContext val constructors cgetSyntheticPartsthisDescriptorconstructors addNonExistentresult constructors override fun getNestedClassNamesthisDescriptor ClassDescriptor c LazyJavaResolverContext ListName return cgetSyntheticPartsthisDescriptorclassesmap itname override fun generateNestedClass thisDescriptor ClassDescriptor name Name result MutableListClassDescriptor c LazyJavaResolverContext result cgetSyntheticPartsthisDescriptorclassesfilter itname name private fun LazyJavaResolverContextgetSyntheticPartsdescriptor ClassDescriptor SyntheticParts if descriptor is LazyJavaClassDescriptor descriptor is SyntheticJavaClassDescriptor return SyntheticPartsEmpty return partsCachegetOrPutdescriptor computeSyntheticPartsdescriptor private fun LazyJavaResolverContextcomputeSyntheticPartsdescriptor ClassDescriptor SyntheticParts val builder SyntheticPartsBuilder processorsforEach itcontributedescriptor builder this return builderbuild override fun modifyField thisDescriptor ClassDescriptor propertyDescriptor PropertyDescriptorImpl c LazyJavaResolverContext PropertyDescriptorImpl return valueFieldModifiermodifyFieldthisDescriptor propertyDescriptor propertyDescriptor Deduplicates generated functions using name and argument counts as lombok does private fun T FunctionDescriptor addNonExistentresult MutableCollectionT toAdd ListT toAddforEach f if resultnone sameSignatureit f result f companion object Lombok treat functions as having the same signature by arguments count only Corresponding code in lombok httpsgithubcomprojectlomboklombokblobv11820srccorelombokjavachandlersJavacHandlerUtiljavaL752 ", "modifier": "private ", "signature": "fun sameSignature(a: FunctionDescriptor, b: FunctionDescriptor): Boolean", "body": "{<EOL> val aVararg = a.valueParameters.any { it.varargElementType != null }"}
{"docstring": " Lombok treat functions as having the same signature by arguments count only Corresponding code in lombok httpsgithubcomprojectlomboklombokblobv11820srccorelombokjavachandlersJavacHandlerUtiljavaL752 ", "modifier": "private ", "signature": "fun sameSignature(a: FirFunction, b: FirFunction): Boolean", "body": "{<EOL> if (a is FirConstructor && b !is FirConstructor || a !is FirConstructor && b is FirConstructor) return false<EOL> if (a.symbol.callableId.callableName != b.symbol.callableId.callableName) return false<EOL> val aVararg = a.valueParameters.any { it.isVararg }"}
{"docstring": " Returns total number of declared types in java source files that were processed ", "modifier": "", "signature": "fun getSourceFileDefinedTypesCount(): Int", "body": "{<EOL> return sourceCache.values.sumOf {<EOL> val structure = it as? SourceFileStructure ?: return@sumOf 0<EOL> if (structure.declaredTypes.size == 1 && structure.declaredTypes.single() == \"error.NonExistentClass\") {<EOL> // never report package for error.NonExistentClass, as it is never compiled by javac/kotlinc<EOL> return@sumOf 0<EOL> }"}
{"docstring": " This has to invoked only once the processors has been initialized because this accesses ProcessorgetSupportedOptions ", "modifier": "private ", "signature": "fun createDependencyCollector(): AnnotationProcessorDependencyCollector", "body": "{<EOL> val type = if (kind == DeclaredProcType.DYNAMIC) {<EOL> val fromOptions = supportedOptions.singleOrNull { it.startsWith(\"org.gradle.annotation.processing.\") }"}
{"docstring": " From set of changed sources get list of files to recompile using structural information and dependency information from annotation processing ", "modifier": "", "signature": "fun invalidateAndGetDirtyFiles(\n        changedSources: Collection<File>,\n        dirtyClasspathJvmNames: Collection<String>,\n        compiledSources: List<File>\n    ): SourcesToReprocess", "body": "{<EOL> if (!aptCache.isIncremental) {<EOL> return SourcesToReprocess.FullRebuild<EOL> }"}
{"docstring": " Incremental annotation processing tries to limit the number of java files that are passes to annotation processors and it uses already existing class files to resolve types This relies on outputs of kotlinc and javac being present The check below verifies that the number of types defined in the processed java files matches the number of class files in the compiled sources This check does not guarantee that class file will indeed exist for every defined type but even if such check is introduced there is no guarantee that the actual content of the source file matches the class file Eg clean build ie nonincremental KAPT modify Bjava with error in the method body KAPT runs successfully but java compilation will fail assume old Bclass is kept add Cjava that references B as method parameter type KAPT wil only process Cjava and it will use old version of B To properly fix this KAPT needs to keep track of kotlinc and javac compilation outcome and there is no clean API to do that However comparing total numbers is probably good enough and it should eliminate most of the issues See KT41456 for details val totalDeclaredTypes javaCachegetSourceFileDefinedTypesCount val compileOutputHasEnoughClassFiles checkMinNumberOfClassFilescompiledSources totalDeclaredTypes if compileOutputHasEnoughClassFiles return SourcesToReprocessFullRebuild val dirtyClasspathFqNames HashSetStringdirtyClasspathJvmNamessize dirtyClasspathJvmNamesforEach dirtyClasspathFqNamesadditreplace replace val changes ChangeschangedSources dirtyClasspathFqNamestoSet val aggregatingGeneratedTypes aptCachegetAggregatingGeneratedTypesjavaCachegetTypesForFiles val impactedTypes getAllImpactedTypeschanges aggregatingGeneratedTypes val isolatingGeneratedTypes aptCachegetIsolatingGeneratedTypesjavaCachegetTypesForFiles val sourcesToReprocess changedSourcestoMutableSet val classNamesToReprocess mutableListOfString if changedSourcesisNotEmpty impactedTypesisNotEmpty for aggregatingOrigin in aptCachegetAggregatingOrigins if aggregatingOrigin in impactedTypes continue val originSource javaCachegetSourceForTypeaggregatingOrigin if originSourceextension java sourcesToReprocessaddoriginSource else if originSourceextension class This is a generated class file that we need to reprocess classNamesToReprocessaddaggregatingOrigin for impactedType in impactedTypes if impactedType in isolatingGeneratedTypes impactedType in aggregatingGeneratedTypes sourcesToReprocessaddjavaCachegetSourceForTypeimpactedType else if impactedType in isolatingGeneratedTypes this is a generated type by isolating AP val isolatingOrigin aptCachegetOriginForGeneratedIsolatingTypeimpactedType javaCachegetSourceForType if isolatingOrigin in impactedTypes isolatingOrigin in dirtyClasspathFqNames continue val originSource javaCachegetSourceForTypeisolatingOrigin if originSourceextension java sourcesToReprocessaddoriginSource else if originSourceextension class classNamesToReprocessaddisolatingOrigin if sourcesToReprocessisNotEmpty classNamesToReprocessisNotEmpty Invalidate state only if there are some files that will be reprocessed javaCacheinvalidateDataForTypesimpactedTypes aptCacheinvalidateAggregating for isolating invalidate both own types and classpath types aptCacheinvalidateIsolatingForOriginTypesimpactedTypes dirtyClasspathFqNames return SourcesToReprocessIncrementalsourcesToReprocesstoList impactedTypes classNamesToReprocess private fun getAllImpactedTypeschanges Changes aggregatingGeneratedTypes SetString MutableSetString val impactedTypes javaCachegetAllImpactedTypeschanges check isolating with origins from the classpath impactedTypesaddAllaptCachegetIsolatingGeneratedTypesForOriginschangesdirtyFqNamesFromClasspath javaCachegetTypesForFiles if changessourceChangesisNotEmpty impactedTypesisNotEmpty Any source change or any source impacted by type change invalidates aggregating APs generated types impactedTypesaddAllaggregatingGeneratedTypes now check isolating with origins in any of the impacted types aptCachegetIsolatingGeneratedTypesForOriginsimpactedTypes javaCachegetTypesForFileslet impactedTypesaddAllit return impactedTypes private fun maybeGetAptCacheFromFile IncrementalAptCache return if aptCacheFileexists try ObjectInputStreamBufferedInputStreamaptCacheFileinputStreamuse itreadObject as IncrementalAptCache catch e Throwable cache corrupt IncrementalAptCache else IncrementalAptCache private fun maybeGetJavaCacheFromFile JavaClassCache return if javaCacheFileexists try ObjectInputStreamBufferedInputStreamjavaCacheFileinputStreamuse itreadObject as JavaClassCache catch e Throwable JavaClassCache else JavaClassCache override fun close if closed return withjavaCacheFile delete parentFilemkdirs ObjectOutputStreamBufferedOutputStreamoutputStreamuse itwriteObjectjavaCache withaptCacheFile delete parentFilemkdirs ObjectOutputStreamBufferedOutputStreamoutputStreamuse itwriteObjectaptCache closed true sealed class SourcesToReprocess class Incremental val toReprocess ListFile val dirtyTypes SetString val unchangedAggregatedTypes ListString SourcesToReprocess object FullRebuild SourcesToReprocess Returns if specified root dirs have at least required number of class files ", "modifier": "private ", "signature": "fun checkMinNumberOfClassFiles(roots: List<File>, required: Int): Boolean", "body": "{<EOL> var currentlyMissing = required<EOL> roots.filter { it.isDirectory }"}
{"docstring": " Check if expression a call to a composable function or access to a composable property is allowed in the current context It is allowed if It is executed as part of the body of a composable function It is not executed as part of the body of a lambda annotated with DisallowComposableCalls It is not inside of a try block It is a call to a readonly composable function if it is executed in the body of a function that is annotated with ReadOnlyComposable A function is composable if It is annotated with Composable It is a lambda whose type is inferred to be ComposableFunction It is an inline lambda whose enclosing function is composable private fun checkComposableCall expression FirQualifiedAccessExpression calleeFunction FirCallableSymbol context CheckerContext reporter DiagnosticReporter contextvisitCurrentScope visitInlineLambdaParameter parameter if parameterreturnTypeRefhasDisallowComposableCallsAnnotationcontextsession reporterreportOn expressioncalleeReferencesource ComposeErrorsCAPTURED_COMPOSABLE_INVOCATION parametersymbol parametercontainingFunctionSymbol context visitAnonymousFunction function if functiontypeRefconeTypefunctionTypeKindcontextsession ComposableFunction return val functionPsi functionpsi if functionPsi is KtFunctionLiteral functionPsi is KtLambdaExpression functionPsi is KtFunction returnvisitCurrentScope val nonReadOnlyCalleeReference if calleeFunctionisReadOnlyComposablecontextsession expressioncalleeReferencesource else null if checkComposableFunction function nonReadOnlyCalleeReference context reporter ComposableCheckForScopeStatusSTOP return visitFunction function val nonReadOnlyCalleeReference if calleeFunctionisReadOnlyComposablecontextsession expressioncalleeReferencesource else null if checkComposableFunction function nonReadOnlyCalleeReference context reporter ComposableCheckForScopeStatusSTOP return visitTryExpression tryExpression container Only report an error if the composable call happens inside of the try block Composable calls are allowed inside of catch and finally blocks if container is FirCatch tryExpressionfinallyBlock container reporterreportOn tryExpressionsource ComposeErrorsILLEGAL_TRY_CATCH_AROUND_COMPOSABLE context reporterreportOn expressioncalleeReferencesource ComposeErrorsCOMPOSABLE_INVOCATION context private enum class ComposableCheckForScopeStatus STOP CONTINUE This function will be called by visitCurrentScope and this function determines whether it will continue the composable element check for the scope or not by returning ComposableCheckForScopeStatus ", "modifier": "private ", "signature": "fun checkComposableFunction(\n    function: FirFunction,\n    nonReadOnlyCallInsideFunction: KtSourceElement?,\n    context: CheckerContext,\n    reporter: DiagnosticReporter,\n): ComposableCheckForScopeStatus", "body": "{<EOL> // [function] is a function with \"read-only\" composable annotation, but it has a call<EOL> // without \"read-only\" composable annotation.<EOL> // -> report NONREADONLY_CALL_IN_READONLY_COMPOSABLE.<EOL> if (function.hasComposableAnnotation(context.session)) {<EOL> if (<EOL> function.hasReadOnlyComposableAnnotation(context.session) &&<EOL> nonReadOnlyCallInsideFunction != null<EOL> ) {<EOL> reporter.reportOn(<EOL> nonReadOnlyCallInsideFunction,<EOL> ComposeErrors.NONREADONLY_CALL_IN_READONLY_COMPOSABLE,<EOL> context<EOL> )<EOL> }"}
{"docstring": " Find the description value from ComposableTargetMarker if the token refers to an annotation with the marker or just return token if it cannot be found ", "modifier": "private ", "signature": "fun descriptionFrom(token: String): String", "body": "{<EOL> val fqName = FqName(token)<EOL> val cls = callContext.moduleDescriptor.findClassAcrossModuleDependencies(<EOL> ClassId.topLevel(fqName)<EOL> )<EOL> return cls?.let {<EOL> it.annotations.findAnnotation(<EOL> ComposeFqNames.ComposableTargetMarker<EOL> )?.let { marker -><EOL> marker.allValueArguments.firstNotNullOfOrNull { entry -><EOL> val name = entry.key<EOL> if (<EOL> !name.isSpecial &&<EOL> name.identifier == ComposeFqNames.ComposableTargetMarkerDescription<EOL> ) {<EOL> (entry.value as? StringValue)?.value<EOL> }"}
{"docstring": " A LazyScheme is a scheme that is lazily and progressively inferred by ApplierInferencer and is used to store the current inference state for a function type Scheme is used to control the shape and initial values of the lazy scheme Bound appliers are not changed but open types are inferred or bound together if possible by ApplierInferencer class LazyScheme scheme Scheme context MutableListBinding mutableListOf val bindings Bindings Bindings val target Binding schemetargettoBindingbindings context val anyParameters schemeanyParameters val parameters schemeparametersmap LazySchemeit context bindings val result schemeresultlet LazySchemeit context bindings val closed Boolean get targettoken null result null resultclosed parametersall itclosed Create a Scheme from the current state of this ", "modifier": "", "signature": "fun toScheme(): Scheme", "body": "{<EOL> val context: MutableMap<Value, Int> = mutableMapOf()<EOL> var uniqueNumber = 0<EOL> fun mapValues(scheme: LazyScheme) {<EOL> val target = scheme.target<EOL> if (target.token == null) {<EOL> val value = target.value<EOL> val index = context[value]<EOL> if (index == -1) {<EOL> context[value] = uniqueNumber++<EOL> }"}
{"docstring": " The value of a binding If token is not null the binding is bound to token size is the number of Binding instances that share this value This is used to optimize unifying open bindings index is not used directly but makes debugging easier class Valuevar token String var observers SetBindings var size Int 1 val index valueIndexprivate var valueIndex 0 A binding that is either closed with a nonnull token or open Unified bindings are linked together in a circular list by Bindings All linked bindings are all closed simultaneously when anyone of them is unified to a closed binding param token the applier token the binding is bound to if it is closed class Bindingtoken String null observers SetBindings The token that is bound to this binding If token is null then the binding is still open val token String get valuetoken The value of the binding All linked bindings share the same value which also maintains the count of linked bindings var value Value Valuetoken observers The linked list next pointer The list is circular an always nonempty as a binding will always at least contain itself in its own list All linked Binding are in the same circular list Open bindings that are unified together are linked var next this override fun toString String return valuetokenlet Bindingtoken it Bindingvalueindex Bindings can create open or closed bindings and can unify bindings together A binding is either bound to an applier token or it is open All open bindings of the same value are linked together in a circular list When variables from different groups are unified their lists are merged and they are all given the lower of the two groups value Bindings of different values with the same token are considered unified but there is no need to link them as neither will ever change class Bindings private val listeners mutableListOf Unit Create a fresh open applier binding variable fun open Bindingobservers setOfthis Create a closed applier binding variable fun closedtarget String Bindingtoken target emptySet Listen for when a unification closed a binding or bound two binding groups together fun onChangecallback Unit Unit listenersaddcallback return listenersremovecallback Unify a and b returns true if the unification succeeded If both a and b are unbound they will be bound together and will simultaneously be bound if either is later bound If only one is bound the other will be bound to the bound token If a and b are bound already unify returns true if they are bound to the same token or false if they are not Binding two open bindings that are already bound together is a noop and succeeds param a an applier binding variable param b an applier binding variable return true if a and b can be unified together ", "modifier": "", "signature": "fun unify(a: Binding, b: Binding): Boolean", "body": "{<EOL> val at = a.value.token<EOL> val bt = b.value.token<EOL> return when {<EOL> at != null && bt == null -> bind(b, at)<EOL> at == null && bt != null -> bind(a, bt)<EOL> at != null && bt != null -> at == bt<EOL> else -> bind(a, b)<EOL> }"}
{"docstring": " Both hashCode and equals are in terms of alpha rename equivalents That means that the scheme 0 0 and 2 2 should be treated as equal even though they have different indexes because they are alpha rename equivalent This method will rename all variables consistently so that if they are alpha equivalent then they will have the same open indexes in the same location If the scheme is already alpha rename consistent then this is returned ", "modifier": "private ", "signature": "fun alphaRename(): Scheme", "body": "{<EOL> // Special case where the scheme would always be renamed to itself.<EOL> if ((target !is Open || target.index in -1..0) && parameters.isEmpty()) return this<EOL><EOL> // Calculate what the renames should be<EOL> val alphaRenameMap = mutableMapOf<Int, Int>()<EOL> var next = 0<EOL> fun scan(scheme: Scheme) {<EOL> val target = scheme.target<EOL> val parameters = scheme.parameters<EOL> val result = scheme.result<EOL> if (target is Open) {<EOL> val index = target.index<EOL> if (index in alphaRenameMap) {<EOL> if (index >= 0 && alphaRenameMap[index] == -1)<EOL> alphaRenameMap[index] = next++<EOL> }"}
{"docstring": " Compare lhs and rhs using structural equality ", "modifier": "protected ", "signature": "fun irEqual(lhs: IrExpression, rhs: IrExpression): IrExpression", "body": "{<EOL> return irCall(<EOL> context.irBuiltIns.eqeqSymbol,<EOL> null,<EOL> null,<EOL> null,<EOL> lhs,<EOL> rhs<EOL> )<EOL> }"}
{"docstring": " Compare lhs and rhs using structural inequality ", "modifier": "protected ", "signature": "fun irNotEqual(lhs: IrExpression, rhs: IrExpression): IrExpression", "body": "{<EOL> return irNot(irEqual(lhs, rhs))<EOL> }"}
{"docstring": " An enum of the different states a parameter of a composable function can have relating to comparison propagation Each state is represented by two bits in the changed bitmask enum class ParamStateval bits Int Indicates that nothing is certain about the current state of the parameter It could be different than it was during the last execution or it could be the same but it is not known so the current function looking at it must call equals on it in order to find out This is the only state that can cause the function to spend slot table space in order to look at it Uncertain0b000 This indicates that the value is known to be the same since the last time the function was executed There is no need to store the value in the slot table in this case because the calling function will always know whether the value was the same or different as it was in the previous execution Same0b001 This indicates that the value is known to be different since the last time the function was executed There is no need to store the value in the slot table in this case because the calling function will always know whether the value was the same or different as it was in the previous execution Different0b010 This indicates that the value is known to never change for the duration of the running program Static0b011 Unknown0b100 Mask0b111 fun bitsForSlotslot Int Int bitsForSlotbits slotconst val BITS_PER_INT 31const val SLOTS_PER_INT 10const val BITS_PER_SLOT 3fun bitsForSlotbits Int slot Int Int val realSlot slotremSLOTS_PER_INT return bits shl realSlot BITS_PER_SLOT 1fun defaultsParamIndexindex Int Int index BITS_PER_INTfun defaultsBitIndexindex Int Int indexremBITS_PER_INT The number of implicit this parameters the function has Note that extension and dispatch receiver params will not show up in IrFunctionvalueParameters but context receiver parameter IrFunctioncontextReceiverParametersCount will val IrFunctionthisParamCount get contextReceiverParametersCount if dispatchReceiverParameter null 1 else 0 if extensionReceiverParameter null 1 else 0 Calculates the number of changed params needed based on the functions parameters param realValueParams The number of params defined by the user those that are not implicit no extension or context receivers or synthetic no composer changed or defaults param thisParams The number of implicit params ie IrFunctionthisParamCount ", "modifier": "", "signature": "fun changedParamCount(realValueParams: Int, thisParams: Int): Int", "body": "{<EOL> val totalParams = realValueParams + thisParams<EOL> if (totalParams == 0) return 1 // There is always at least 1 changed param<EOL> return ceil(<EOL> totalParams.toDouble() / SLOTS_PER_INT.toDouble()<EOL> ).toInt()<EOL>}"}
{"docstring": " Calculates the number of changed params needed based on the functions total amount of parameters param totalParamsIncludingThisParams The total number of parameter including implicit and synthetic ones ", "modifier": "", "signature": "fun changedParamCountFromTotal(totalParamsIncludingThisParams: Int): Int", "body": "{<EOL> var realParams = totalParamsIncludingThisParams<EOL> realParams-- // composer param<EOL> realParams-- // first changed param (always present)<EOL> var changedParams = 0<EOL> do {<EOL> realParams -= SLOTS_PER_INT<EOL> changedParams++<EOL> }"}
{"docstring": " Calculates the number of defaults params needed based on the functions parameters param valueParams The numbers of params usually the size of IrFunctionvalueParameters Which includes context receivers params but not extension param nor synthetic params ", "modifier": "", "signature": "fun defaultParamCount(valueParams: Int): Int", "body": "{<EOL> return ceil(<EOL> valueParams.toDouble() / BITS_PER_INT.toDouble()<EOL> ).toInt()<EOL>}"}
{"docstring": " Test rule that helps to setup android project in tests that run gradle It should be used along side with SdkResourceGenerator in your buildgradle file class ProjectSetupRuleparentFolder File null ExternalResource val testProjectDir TemporaryFolderparentFolder val props ProjectProps by lazy ProjectPropsload val rootDir File get testProjectDirroot val buildFile File get FilerootDir buildgradle val gradlePropertiesFile File get FilerootDir gradleproperties Combined list of local build repo and remote repositories prebuilts etc Local build repo is the first in line to ensure it is prioritized val allRepositoryPaths ListString by lazy listOfpropstipOfTreeMavenRepoPath propsrepositoryUrls A repositories gradle block that contains all default repositories for inclusion in gradle configurations val repositories String get buildString appendLinerepositories appenddefaultRepoLines appendLine val defaultRepoLines get buildString propsrepositoryUrlsforEach appendLine maven url it val androidProject String get android compileSdk propscompileSdk buildToolsVersion propsbuildToolsVersion defaultConfig minSdkVersion propsminSdkVersion signingConfigs debug storeFile filepropsdebugKeystore trimIndent private val defaultBuildGradle String get nrepositoriesnnandroidProjectnn fun writeDefaultBuildGradleprefix String suffix String buildFilewriteTextprefix buildFileappendTextdefaultBuildGradle buildFileappendTextsuffix override fun applybase Statement description Description Statement return testProjectDirapplysuperapplybase description description override fun before buildFilecreateNewFile copyLocalProperties copyLibsVersionsToml writeGradleProperties fun getSdkDirectory String val localProperties FilepropsrootProjectPath localproperties when localPropertiesexists val stream localPropertiesinputStream val properties Properties propertiesloadstream return propertiesgetPropertysdkdir SystemgetenvANDROID_HOME null return SystemgetenvANDROID_HOME SystemgetenvANDROID_SDK_ROOT null return SystemgetenvANDROID_SDK_ROOT else throw IllegalStateException ProjectSetupRule did find localproperties at localProperties and neither ANDROID_HOME or ANDROID_SDK_ROOT was set Gets the latest version of a published library Note that the library must have been locally published to locate its latest version this can be done in test by adding publish as a test dependency for example tasksfindByPathtest dependsOntasksfindByPathroomroomcompilerpublish param path The library m2 path eg androidxroomroomcompiler ", "modifier": "", "signature": "fun getLibraryLatestVersionInLocalRepo(path: String): String", "body": "{<EOL> val metadataFile = File(props.tipOfTreeMavenRepoPath)<EOL> .resolve(path)<EOL> .resolve(\"maven-metadata.xml\")<EOL> check(metadataFile.exists()) {<EOL> \"Cannot find room metadata file in ${metadataFile.absolutePath}"}
{"docstring": " Resolve the given irType to a corresponding IrParcelSerializer This depends on the TypeParcelers which are currently in scope as well as the type of the enclosing Parceleable class parcelizeType which is needed to get a class loader for reflection based serialization Beyond this we need to know whether to allow using readwriteValue for serialization if strict is false Beyond this we need to know whether we are producing parcelers for properties of a Parcelable if toplevel is true or for a complete Parcelable ", "modifier": "", "signature": "fun get(\n        irType: IrType,\n        scope: IrParcelerScope?,\n        parcelizeType: IrType,\n        strict: Boolean = false,\n        toplevel: Boolean = false\n    ): IrParcelSerializer", "body": "{<EOL> fun strict() = strict && !irType.hasAnnotation(RAWVALUE_ANNOTATION_FQNAME)<EOL><EOL> scope.getCustomSerializer(irType)?.let { parceler -><EOL> return IrCustomParcelSerializer(parceler)<EOL> }"}
{"docstring": " Gets invocation qualifier name returns f for _foof call fun getSimpleNamecall JsInvocation JsName val qualifier callqualifier return qualifier as JsNameRefname Tries to get ident for call returns first name ident iterating through qualifier chain fun getSimpleIdentcall JsInvocation String var qualifier JsExpression callqualifier qualifiers while qualifier null when qualifier is JsInvocation val callableQualifier qualifier qualifier callableQualifierqualifier if isCallInvocationcallableQualifier qualifier qualifier as JsNameRefqualifier is HasName return qualifiernameident else breakqualifiers return null Tests if invocation is JavaScript call function return true if invocation is something like xcallthisReplacement false otherwise ", "modifier": "", "signature": "fun isCallInvocation(invocation: JsInvocation): Boolean", "body": "{<EOL> val qualifier = invocation.qualifier as? JsNameRef<EOL> val arguments = invocation.arguments<EOL><EOL> if (qualifier.name?.descriptor != null) return false<EOL><EOL> return qualifier?.ident == Namer.CALL_FUNCTION && arguments.isNotEmpty() && qualifier.qualifier != null<EOL>}"}
{"docstring": " Checks if invocation has qualifier before call return true if invocation is similar to somethingf false if invocation is similar to f ", "modifier": "", "signature": "fun hasCallerQualifier(invocation: JsInvocation): Boolean", "body": "{<EOL> return getCallerQualifierImpl(invocation) != null<EOL>}"}
{"docstring": " Gets qualifier preceding call return caller for invocation of type callerf where caller is any JsNameRef for example abc etc throws AssertionError if invocation does not have caller qualifier ", "modifier": "", "signature": "fun getCallerQualifier(invocation: JsInvocation): JsExpression", "body": "{<EOL> return getCallerQualifierImpl(invocation) ?:<EOL> throw AssertionError(\"must check hasQualifier() before calling getQualifier\")<EOL><EOL>}"}
{"docstring": " Removes initializers for default parameters with defined arguments given Expands initializers for default parameters with undefined arguments given fun removeDefaultInitializersarguments ListJsExpression parameters ListJsParameter body JsBlock val toRemove getDefaultParamsNamesarguments parameters initialized true val toExpand getDefaultParamsNamesarguments parameters initialized false val statements bodystatements val newStatements statementsflatMap val name getNameFromInitializerit if name null isNameInitializedname it throw AssertionErrorUnexpected initializer structure when name null name in toRemove listOfJsStatement name null name in toExpand val thenStatement it as JsIfthenStatement markAssignmentAsStaticRefname thenStatement flattenStatementthenStatement else listOfit statementsclear statementsaddAllnewStatementsprivate fun markAssignmentAsStaticRefname JsName node JsNode nodeacceptobject RecursiveJsVisitor override fun visitBinaryExpressionx JsBinaryOperation decomposeAssignmentToVariablexlet assignmentTarget assignmentExpr if assignmentTarget name assignmentTargetstaticRef assignmentExpr supervisitBinaryExpressionx private fun getNameFromInitializerstatement JsStatement JsName val ifStmt statement as JsIf val testExpr ifStmtifExpression val elseStmt ifStmtelseStatement if elseStmt null testExpr is JsBinaryOperation return getNameFromInitializertestExpr return nullprivate fun getNameFromInitializerisInitializedExpr JsBinaryOperation JsName val arg1 isInitializedExprarg1 val arg2 isInitializedExprarg2 val op isInitializedExproperator if arg1 null arg2 null return null if op JsBinaryOperatorREF_EQ JsAstUtilsisUndefinedExpressionarg2 return arg1 as JsNameRefname return null Tests if the last statement of initializer is name assignment ", "modifier": "private ", "signature": "fun isNameInitialized(\n    name: JsName,\n    initializer: JsStatement\n): Boolean", "body": "{<EOL> val thenStmt = (initializer as JsIf).thenStatement<EOL> val lastThenStmt = flattenStatement(thenStmt).last()<EOL><EOL> val expr = (lastThenStmt as? JsExpressionStatement)?.expression<EOL> if (expr !is JsBinaryOperation) return false<EOL><EOL> val op = expr.operator<EOL> if (!op.isAssignment) return false<EOL><EOL> val arg1 = expr.arg1<EOL> if (arg1 is HasName && arg1.name === name) return true<EOL><EOL> return false<EOL>}"}
{"docstring": " This is a straightforward implementation of The Game of Life See httpenwikipediaorgwikiConways_Game_of_Life A field where cells live Effectively immutable class Field val width Int val height Int This function tells the constructor which cells are alive if initi j is true the cell i j is alive init Int Int Boolean private val live ArrayArrayBoolean Arrayheight i Arraywidth j initi j private fun liveCounti Int j Int if i in 0height 1 j in 0width 1 liveij 1 else 0 How many neighbors of i j are alive fun liveNeighborsi Int j Int liveCounti 1 j 1 liveCounti 1 j liveCounti 1 j 1 liveCounti j 1 liveCounti j 1 liveCounti 1 j 1 liveCounti 1 j liveCounti 1 j 1 You can say fieldi j and this function gets called operator fun geti Int j Int liveij This function takes the present state of the field and return a new field representing the next moment of time ", "modifier": "", "signature": "fun next(field: Field): Field", "body": "{<EOL> return Field(field.width, field.height) { i, j -><EOL> val n = field.liveNeighbors(i, j)<EOL> if (field[i, j])<EOL> // (i, j) is alive<EOL> n in 2..3 // It remains alive iff it has 2 or 3 neighbors<EOL> else<EOL> // (i, j) is dead<EOL> n == 3 // A new cell is born if there are 3 neighbors alive<EOL> }"}
{"docstring": " Lets Walk Through a Maze Imagine there is a maze whose walls are the big O letters Now I stand where a big I stands and some cool prize lies somewhere marked with a sign Like this OOOOOOOOOOOOOOOOO O O O O O OOOOO O O O O OOOOOOOOOOOOOO O O I O O O OOOOOOOOOOOOOOOOO I want to get the prize and this program helps me do so as soon as I possibly can by finding a shortest path through the maze fun E MutableListEofferelement E thisaddelementfun E MutableListEpoll thisremoveAt0 This function looks for a path from maxstart to mazeend through free space a path does not go through walls One can move only straightly up down left or right no diagonal moves allowed fun findPathmaze Maze ListPairInt Int val previous HashMapPairInt Int PairInt Int val queue ArrayDequePairInt Int val visited HashSetPairInt Int queueoffermazestart visitedaddmazestart while queueisEmpty val cell queuepoll if cell mazeend break for newCell in mazeneighborscellfirst cellsecond if newCell in visited continue previousnewCell cell queueoffernewCell visitedaddcell if previousmazeend null return null val path ArrayListPairInt Int var current previousmazeend while current mazestart pathadd0 current current previouscurrent return path Find neighbors of the i j cell that are not walls fun Mazeneighborsi Int j Int ListPairInt Int val result ArrayListPairInt Int addIfFreei 1 j result addIfFreei j 1 result addIfFreei 1 j result addIfFreei j 1 result return resultfun MazeaddIfFreei Int j Int result MutableListPairInt Int if i in 0height 1 return if j in 0width 1 return if wallsij return resultaddPairi j A data class that represents a maze class Maze Number or columns val width Int Number of rows val height Int true for a wall false for free space val walls Arrayout Arrayout Boolean The starting point must not be a wall val start PairInt Int The target point must not be a wall val end PairInt Int A few maze examples here fun mainargs ArrayString printMazeI printMazeI O printMaze O O O O O I trimIndent printMaze OOOOOOOOOOO O O OOOOOOO OOO O O OOOOO OOOOO O O O OOOOOOOOO O OO OOOOOO IO trimIndent printMaze OOOOOOOOOOOOOOOOO O O O O O OOOOO O O O O OOOOOOOOOOOOOO O O I O O O OOOOOOOOOOOOOOOOO trimIndent UTILITIESfun printMazestr String val maze makeMazestr printlnMaze val path findPathmaze for i in 0mazeheight 1 for j in 0mazewidth 1 val cell Pairi j print if mazewallsij O else if cell mazestart I else if cell mazeend else if path null pathcontainscell else println printlnResult if path null No path else Path found println A maze is encoded in the string s the big O letters are walls I stand where a big I stands and the prize is marked with a sign Example OOOOOOOOOOOOOOOOO O O O O O OOOOO O O O O OOOOOOOOOOOOOO O O I O O O OOOOOOOOOOOOOOOOO ", "modifier": "", "signature": "fun makeMaze(s: String): Maze", "body": "{<EOL> val lines = s.split(\"\\n\")!!<EOL> val w = lines.maxWithOrNull(Comparator { o1, o2 -><EOL> val l1: Int = o1?.length ?: 0<EOL> val l2 = o2?.length ?: 0<EOL> l1 - l2<EOL> }"}
{"docstring": " We shouldnt capture current this or outer this Assuming C is current translating class we have descriptor Athis in the following cases A C C in inner class of A A C among outer classes of C there is T such that A T If fact the latter case is the generalization of all previous cases assuming that is inner class of and relations are reflective All this cases allow to refer to this directly or via sequence of outer fields Note that the continuous sequence of inner classes may be interrupted by nonclass descriptor This means that the last class of the sequence if a local class We stop there since this means that the next class in the sequence is referred by closure variable rather than by dedicated outer field The nested classes are out of scope since nested class cant refer to outers class this thus frontend will never generate ReceiverParameterDescriptor for this case ", "modifier": "private ", "signature": "fun isReceiverAncestor(descriptor: DeclarationDescriptor): Boolean", "body": "{<EOL> if (descriptor !is ReceiverParameterDescriptor) return false<EOL> if (containingDescriptor !is ClassDescriptor && containingDescriptor !is ConstructorDescriptor) return false<EOL><EOL> // Class in which we are trying to capture variable<EOL> val containingClass = getParentOfType(containingDescriptor, ClassDescriptor::class.java, false) ?: return false<EOL><EOL> // Class which instance we are trying to capture<EOL> val currentClass = descriptor.containingDeclaration as? ClassDescriptor ?: return false<EOL><EOL> for (outerDeclaration in generateSequence(containingClass) { it.containingDeclaration as? ClassDescriptor }"}
{"docstring": " Test for the case like this object A var x Int class B fun foo x We dont want to capture Athis since we always can refer A by its FQN ", "modifier": "private ", "signature": "fun isSingletonReceiver(descriptor: DeclarationDescriptor): Boolean", "body": "{<EOL> if (descriptor !is ReceiverParameterDescriptor) return false<EOL><EOL> val container = descriptor.containingDeclaration<EOL> if (!DescriptorUtils.isObject(container)) return false<EOL><EOL> // This code is necessary for one use case. If we don't treat `O::this` as a free variable of lambda, we'll get<EOL> // `this` in generated JS. `this` is generated since it's placed in aliasing context for `O::this`, so we will get<EOL> // it instead of generating FQN. However, we can't refer to `this` from lambda, since `this` points not to an instance of `C`,<EOL> // but to lambda function itself. We avoid it by treating `O::this` as a free variable.<EOL> // Example is:<EOL> //<EOL> // object A(val x: Int) {<EOL> // fun foo() = { x }"}
{"docstring": " Moves captured local inline function inside capturing function For example var inc _fooincclosure local fun that captures closure capturingFunctioninc Is transformed to capturingFunctionclosure var inc _fooincclosure is moved inside capturingFunction private fun moveCapturedLocalInsidecapturingFunction JsFunction capturedName JsName localFunAlias JsExpression CapturedArgsParams when localFunAlias is JsNameRef Local inline function does not capture anything so just move alias inside declareAliasInsideFunctioncapturingFunction capturedName localFunAlias CapturedArgsParams is JsInvocation moveCapturedLocalInsidecapturingFunction capturedName localFunAlias else throw AssertionErrorLocal function reference has wrong alias localFunAlias Processes case when local inline function with capture is captured by capturingFunction In this case capturingFunction should capture arguments captured by localFunAlias and localFunAlias declaration is moved inside For example val x 0 inline fun id x val lambda printlnid lambda should capture x in this case ", "modifier": "private ", "signature": "fun moveCapturedLocalInside(capturingFunction: JsFunction, capturedName: JsName, localFunAlias: JsInvocation): CapturedArgsParams", "body": "{<EOL> val capturedArgs = localFunAlias.arguments<EOL><EOL> val freshNames = getTemporaryNamesInScope(capturedArgs)<EOL><EOL> val aliasCallArguments = freshNames.map(JsName::makeRef)<EOL> val alias = JsInvocation(localFunAlias.qualifier, aliasCallArguments)<EOL> declareAliasInsideFunction(capturingFunction, capturedName, alias)<EOL><EOL> val capturedParameters = freshNames.map(::JsParameter)<EOL> return CapturedArgsParams(capturedArgs, capturedParameters)<EOL>}"}
{"docstring": " Returns true if given function is static as defined in staticCFunction ", "modifier": "private ", "signature": "fun isStatic(function: Function<*>): Boolean", "body": "{<EOL> // TODO: revise<EOL> try {<EOL> with(function.javaClass.getDeclaredField(\"INSTANCE\")) {<EOL> if (!java.lang.reflect.Modifier.isStatic(modifiers) || !java.lang.reflect.Modifier.isFinal(modifiers)) {<EOL> return false<EOL> }"}
{"docstring": " Describes the bridge between Kotlin type T and the corresponding C type of a functions parameter or return value It is supposed to be constructed using the primitive types such as SInt32 the Struct combinator and the CEnumType wrapper This description omits the details that are irrelevant for the ABI internal abstract class CTypeT constructorval ffiType ffi_type constructorffiTypePtr Long thisinterpretPointedffi_typeffiTypePtr abstract fun readlocation NativePtr T abstract fun writelocation NativePtr value T Unitprivate object Void CTypeAnyffiTypeVoid override fun readlocation NativePtr throw UnsupportedOperationException override fun writelocation NativePtr value Any nothing to do private object SInt8 CTypeByteffiTypeSInt8 override fun readlocation NativePtr interpretPointedByteVarlocationvalue override fun writelocation NativePtr value Byte interpretPointedByteVarlocationvalue value private object SInt16 CTypeShortffiTypeSInt16 override fun readlocation NativePtr interpretPointedShortVarlocationvalue override fun writelocation NativePtr value Short interpretPointedShortVarlocationvalue value private object SInt32 CTypeIntffiTypeSInt32 override fun readlocation NativePtr interpretPointedIntVarlocationvalue override fun writelocation NativePtr value Int interpretPointedIntVarlocationvalue value private object SInt64 CTypeLongffiTypeSInt64 override fun readlocation NativePtr interpretPointedLongVarlocationvalue override fun writelocation NativePtr value Long interpretPointedLongVarlocationvalue value private object Pointer CTypeCPointerffiTypePointer override fun readlocation NativePtr interpretPointedCPointerVarlocationvalue override fun writelocation NativePtr value CPointer interpretPointedCPointerVarlocationvalue value private class Structval size Long val align Int elementTypes ListCType CTypeCValue ffiTypeStruct elementTypesmap itffiType override fun readlocation NativePtr interpretPointedByteVarlocationreadValueCStructVarsize align override fun writelocation NativePtr value CValue valuewritelocationSuppressDEPRECATIONprivate class CEnumTypeprivate val rawValueCType CTypeAny CTypeCEnumrawValueCTypeffiType override fun readlocation NativePtr CEnum TODOenumtyped callback parameters override fun writelocation NativePtr value CEnum rawValueCTypewritelocation valuevalue private typealias FfiClosureImpl LongConsumerprivate typealias UserData FfiClosureImplprivate val topLevelInitializer loadKonanLibrarycallbacks Reference to ffi_type struct instance internal class ffi_typerawPtr NativePtr COpaquerawPtr Reference to ffi_cif struct instance private class ffi_cifrawPtr NativePtr COpaquerawPtrprivate external fun ffiTypeVoid Longprivate external fun ffiTypeUInt8 Longprivate external fun ffiTypeSInt8 Longprivate external fun ffiTypeUInt16 Longprivate external fun ffiTypeSInt16 Longprivate external fun ffiTypeUInt32 Longprivate external fun ffiTypeSInt32 Longprivate external fun ffiTypeUInt64 Longprivate external fun ffiTypeSInt64 Longprivate external fun ffiTypePointer Longprivate external fun ffiTypeStruct0elements Long Longprivate external fun ffiFreeTypeStruct0ptr Long Allocates and initializes ffi_type describing the struct param elements types of the struct elements ", "modifier": "private ", "signature": "fun ffiTypeStruct(elementTypes: List<ffi_type>): ffi_type", "body": "{<EOL> val elements = nativeHeap.allocArrayOfPointersTo(*elementTypes.toTypedArray(), null)<EOL> val res = ffiTypeStruct0(elements.rawValue)<EOL> if (res == 0L) {<EOL> throw OutOfMemoryError()<EOL> }"}
{"docstring": " Creates and prepares an ffi_cif param returnType native function return value type param paramTypes native function parameter types return the initialized ffi_cif ", "modifier": "private ", "signature": "fun ffiCreateCif(returnType: ffi_type, paramTypes: List<ffi_type>): ffi_cif", "body": "{<EOL> val nArgs = paramTypes.size<EOL> val argTypes = nativeHeap.allocArrayOfPointersTo(*paramTypes.toTypedArray(), null)<EOL> val res = ffiCreateCif0(nArgs, returnType.rawPtr, argTypes.rawValue)<EOL><EOL> when (res) {<EOL> 0L -> throw OutOfMemoryError()<EOL> -1L -> throw Error(\"FFI_BAD_TYPEDEF\")<EOL> -2L -> throw Error(\"FFI_BAD_ABI\")<EOL> -3L -> throw Error(\"libffi error occurred\")<EOL> }"}
{"docstring": " Uses libffi to allocate a native function which will call impl when invoked param ffiCif describes the type of the function to create ", "modifier": "private ", "signature": "fun ffiCreateClosure(ffiCif: ffi_cif, impl: FfiClosureImpl): NativePtr", "body": "{<EOL> val ffiClosure = nativeHeap.alloc(Long.SIZE_BYTES, 8)<EOL><EOL> try {<EOL> val res = ffiCreateClosure0(ffiCif.rawPtr, ffiClosure.rawPtr, userData = impl)<EOL><EOL> when (res) {<EOL> 0L -> throw OutOfMemoryError()<EOL> -1L -> throw Error(\"libffi error occurred\")<EOL> }"}
{"docstring": " The name to be used for this struct in Kotlin ", "modifier": "", "signature": "fun getKotlinName(decl: StructDecl): String", "body": "{<EOL> val spelling = decl.spelling<EOL> if (decl.isAnonymous) {<EOL> val names = anonymousStructKotlinNames<EOL> return names.getOrPut(decl) {<EOL> \"anonymousStruct${names.size + 1}"}
{"docstring": " Wrapper over Classifier class ClassifierStubType val classifier Classifier override val typeArguments ListTypeArgument emptyList override val nullable Boolean false StubType fun nestedname String ClassifierStubType ClassifierStubTypeclassifiernestedname override fun toString String classifiertopLevelNametypeArgumentsifNotEmpty joinToStringprefix postfix class AbbreviatedType val underlyingType StubType val abbreviatedClassifier Classifier override val typeArguments ListTypeArgument override val nullable Boolean false StubType override fun toString String abbreviatedClassifiertopLevelNametypeArgumentsifNotEmpty joinToStringprefix postfix return type from kotlinxcinterop package fun KotlinPlatformgetRuntimeTypename String nullable Boolean false StubType val classifier ClassifiertopLevelcinteropPackage name PredefinedTypesHandlertryExpandPlatformDependentTypealiasclassifier this nullablelet return it return ClassifierStubTypeclassifier nullable nullable Functional type from kotlin package parameterTypes returnType class FunctionalType val parameterTypes ListStubType TODO Use TypeArguments val returnType StubType override val nullable Boolean false StubType val classifier Classifier ClassifiertopLevelkotlin FunctionparameterTypessize override val typeArguments ListTypeArgument by lazy listOfparameterTypestoTypedArray returnTypemap TypeArgumentStubit class TypeParameterType val name String override val nullable Boolean val typeParameterDeclaration TypeParameterStub StubType override val typeArguments ListTypeArgument emptyListfun KotlinTypetoStubIrType StubType when this is KotlinFunctionType thistoStubIrType is KotlinClassifierType thistoStubIrType else errorUnexpected KotlinType thisprivate fun KotlinFunctionTypetoStubIrType StubType FunctionalTypeparameterTypesmapKotlinTypetoStubIrType returnTypetoStubIrType nullableprivate fun KotlinClassifierTypetoStubIrType StubType val typeArguments argumentsmapKotlinTypeArgumenttoStubIrType PredefinedTypesHandlertryExpandPredefinedTypealiasclassifier nullable typeArgumentslet return it return if underlyingType null ClassifierStubTypeclassifier typeArguments nullable else AbbreviatedTypeunderlyingTypetoStubIrType classifier typeArguments nullable private fun KotlinTypeArgumenttoStubIrType TypeArgument when this is KotlinType TypeArgumentStubthistoStubIrType StarProjection TypeArgumentStarProjection else errorUnexpected KotlinTypeArgument this Types that come from kotlinxcinterop require special handling because we dont have explicit information about their structure For example to be able to produce metadatabased interop library we need to know that ByteVar is a typealias to ByteVarOfByte private object PredefinedTypesHandler private const val cInteropPackage kotlinxcinterop private val nativePtrClassifier ClassifiertopLevelcInteropPackage NativePtr private val primitives setOf KotlinTypesboolean KotlinTypesbyte KotlinTypesshort KotlinTypesint KotlinTypeslong KotlinTypesuByte KotlinTypesuShort KotlinTypesuInt KotlinTypesuLong KotlinTypesfloat KotlinTypesdouble KotlinTypesvector128 kotlinxcinteropprimitiveVar kotlinprimitive private val primitiveVarClassifierToPrimitiveType MapClassifier KotlinClassifierType primitivesassociateBy val typeVar itclassifiertopLevelNameVar ClassifiertopLevelcInteropPackage typeVar param primitiveType primitive type from kotlin package return kotlinxcinteropprimitiveTypeVarOfprimitiveType ", "modifier": "private ", "signature": "fun getVarOfTypeFor(primitiveType: KotlinClassifierType, nullable: Boolean): ClassifierStubType", "body": "{<EOL> val typeVarOf = \"${primitiveType.classifier.topLevelName}"}
{"docstring": " param primitiveVarType one of kotlinxcinteropprimitiveVar types return typealias in terms of StubIR types ", "modifier": "private ", "signature": "fun expandPrimitiveVarType(primitiveVarClassifier: Classifier, nullable: Boolean): AbbreviatedType", "body": "{<EOL> val primitiveType = primitiveVarClassifierToPrimitiveType.getValue(primitiveVarClassifier)<EOL> val underlyingType = getVarOfTypeFor(primitiveType, nullable)<EOL> return AbbreviatedType(underlyingType, primitiveVarClassifier, listOf(), nullable)<EOL> }"}
{"docstring": " Operating system family ExperimentalNativeApipublic enum class OsFamily UNKNOWN MACOSX IOS LINUX WINDOWS ANDROID WASM TVOS WATCHOS Central Processor Unit architecture ExperimentalNativeApipublic enum class CpuArchitecturepublic val bitness Int UNKNOWN1 ARM3232 ARM6464 X8632 X6464 MIPS3232 MIPSEL3232 WASM3232 Memory model NOTE Must match MemoryModel in MemoryhExperimentalNativeApipublic enum class MemoryModel STRICT RELAXED EXPERIMENTAL Object describing the current platform program executes upon ExperimentalNativeApipublic object Platform Check if current architecture allows unaligned access to wider than byte locations public val canAccessUnaligned Boolean get Platform_canAccessUnaligned 0 Check if byte order of the current platform is least significant byte LSB first aka little endian public val isLittleEndian Boolean get Platform_isLittleEndian 0 Operating system family program executes upon public val osFamily OsFamily get OsFamilyvaluesPlatform_getOsFamily Architecture of the CPU program executes upon public val cpuArchitecture CpuArchitecture get CpuArchitecturevaluesPlatform_getCpuArchitecture Memory model binary was compiled with public val memoryModel MemoryModel get MemoryModelvaluesPlatform_getMemoryModel If binary was compiled in debug mode public val isDebugBinary Boolean get Platform_isDebugBinary If freezing is enabled This value would be false only if binary option freezing is equal to disabled This is default when memoryModel is equal to MemoryModelEXPERIMENTAL public val isFreezingEnabled Boolean get Platform_isFreezingEnabled If the memory leak checker is activated by default true in debug mode false in release When memory leak checker is activated and leak is detected during last Kotlin context deinitialization process error message with leak information is printed and application execution is aborted see isDebugBinary public var isMemoryLeakCheckerActive Boolean get Platform_getMemoryLeakChecker setvalue Platform_setMemoryLeakCheckervalue public var isCleanersLeakCheckerActive Boolean get Platform_getCleanersLeakChecker setvalue Platform_setCleanersLeakCheckervalue The number of logical processors available Can be not equal to the number of processors in the system if some restrictions on processor usage were successfully detected Some kinds of processor usage restrictions are not detected for now eg CPU quotas in containers The value is computed on each usage It can change if some OS scheduler API restricts the process during runtime Also value can differ on different threads if some threadspecific scheduler API was used If one considers the value to be inaccurate and wants another one to be used it can be overridden by KOTLIN_NATIVE_AVAILABLE_PROCESSORS environment variable When the variable is set and contains a value that is not positive Int IllegalStateException will be thrown ", "modifier": "public ", "signature": "fun getAvailableProcessors() : Int", "body": "{<EOL> val fromEnv = Platform_getAvailableProcessorsEnv()<EOL> if (fromEnv == null) {<EOL> return Platform_getAvailableProcessors()<EOL> }"}
{"docstring": " A vector of bits growing if necessary and allowing one to setclearread bits from it by a bit index constructor creates an empty bit set with the specified size param size the size of one element in the array used to store bits ObsoleteNativeApipublic class BitSetsize Int ELEMENT_SIZE kotlinnativeinternalCanBePrecreated public companion object Default size of one element in the array used to store bits private const val ELEMENT_SIZE 64 private const val MAX_BIT_OFFSET ELEMENT_SIZE 1 private const val ALL_TRUE 1L 0xFFFF_FFFF_FFFF_FFFF private const val ALL_FALSE 0L 0x0000_0000_0000_0000 private var bits LongArray LongArraybitToElementSizesize private val lastIndex Int get size 1 Returns an index of the last bit that has true value Returns 1 if the set is empty public val lastTrueIndex Int get previousSetBitsize True if this BitSet contains no bits set to true public val isEmpty Boolean get bitsall it ALL_FALSE Actual number of bits available in the set All bits with indices size assumed to be 0 public var size Int size private set Creates a bit set of given length filling elements using initializer public constructorlength Int initializer Int Boolean thislength for i in 0 until length seti initializeri Transforms a bit index into an element index in the bits array private val IntelementIndex Int get this ELEMENT_SIZE Transforms a bit index in the set into a bit in the element of the bits array private val IntbitOffset Int get this ELEMENT_SIZE Transforms a bit index in the set into pair of a bits element index and a bit index in the element private val IntasBitCoordinates PairInt Int get PairelementIndex bitOffset Transforms a bit offset to the mask with only bit set corresponding to the offset private val IntasMask Long get 0x1L shl this Transforms a bit offset to the mask with only bits before the index inclusive set private val IntasMaskBefore Long get getMaskBetween0 this Transforms a bit offset to the mask with only bits after the index inclusive set private val IntasMaskAfter Long get getMaskBetweenthis MAX_BIT_OFFSET Builds a masks with 1 between fromOffset and toOffset both inclusive private fun getMaskBetweenfromOffset Int toOffset Int Long var res 0L val maskToAdd fromOffsetasMask for i in fromOffsettoOffset res res shl 1 or maskToAdd return res Transforms a size in bits to a size in elements of the bits array private fun bitToElementSizebitSize Int Int bitSize ELEMENT_SIZE 1 ELEMENT_SIZE Transforms a pair of an element index and a bit offset to a bit index private fun bitIndexelementIndex Int bitOffset Int elementIndex ELEMENT_SIZE bitOffset Sets all bits after the last available bit size 1 to 0 private fun clearUnusedTail val lastElementIndex lastBitOffset lastIndexasBitCoordinates bitsbitslastIndex bitsbitslastIndex and lastBitOffsetasMaskBefore for i in lastElementIndex 1 until bitssize bitsi ALL_FALSE Internal function Sets bits specified by the element index and the given mask to value private fun setBitsWithMaskelementIndex Int mask Long value Boolean val element bitselementIndex if value bitselementIndex element or mask else bitselementIndex element and maskinv Internal function Flips bits specified by the element index and the given mask private fun flipBitsWithMaskelementIndex Int mask Long val element bitselementIndex bitselementIndex element xor mask Checks if index is valid and extends the bits array if the index exceeds its size throws IndexOutOfBoundsException if index 0 private fun ensureCapacityindex Int if index 0 throw IndexOutOfBoundsException if index size size index 1 if indexelementIndex bitssize Create a new array containing the indexth bit bits bitscopyOfbitToElementSizeindex 1 Set all bits after the index to 0 TODO We can remove it clearUnusedTail Set the bit specified to the specified value public fun setindex Int value Boolean true ensureCapacityindex val elementIndex offset indexasBitCoordinates setBitsWithMaskelementIndex offsetasMask value Sets the bits with indices between from inclusive and to exclusive to the specified value public fun setfrom Int to Int value Boolean true Unit setfrom until to value Sets the bits from the range specified to the specified value public fun setrange IntRange value Boolean true if rangestart 0 rangeendInclusive 0 throw IndexOutOfBoundsException if rangestart rangeendInclusive Empty range return ensureCapacityrangeendInclusive val fromIndex fromOffset rangestartasBitCoordinates val toIndex toOffset rangeendInclusiveasBitCoordinates if toIndex fromIndex val mask getMaskBetweenfromOffset toOffset setBitsWithMaskfromIndex mask value else Set bits in the first element setBitsWithMaskfromIndex fromOffsetasMaskAfter value Set all bits of all elements excluding border ones to 0 or 1 depending for index in fromIndex 1 until toIndex bitsindex if value ALL_TRUE else ALL_FALSE Set bits in the last element setBitsWithMasktoIndex toOffsetasMaskBefore value Clears the bit specified public fun clearindex Int Unit setindex false Clears the bits with indices between from inclusive and to exclusive to the specified value public fun clearfrom Int to Int Unit setfrom to false Clears the bit specified public fun clearrange IntRange Unit setrange false Sets all bits in the BitSet to false public fun clear for i in bitsindices bitsi ALL_FALSE Reverses the bit specified public fun flipindex Int ensureCapacityindex val elementIndex offset indexasBitCoordinates flipBitsWithMaskelementIndex offsetasMask Reverses the bits with indices between from inclusive and to exclusive public fun flipfrom Int to Int Unit flipfrom until to Reverses the bits from the range specified public fun fliprange IntRange if rangestart 0 rangeendInclusive 0 throw IndexOutOfBoundsException if rangestart rangeendInclusive Empty range return ensureCapacityrangeendInclusive val fromIndex fromOffset rangestartasBitCoordinates val toIndex toOffset rangeendInclusiveasBitCoordinates if toIndex fromIndex val mask getMaskBetweenfromOffset toOffset flipBitsWithMaskfromIndex mask else Flip bits in the first element flipBitsWithMasktoIndex toOffsetasMaskAfter Flip bits between the first and the last elements for index in fromIndex 1 until toIndex bitsindex bitsindexinv Flip bits in the last element flipBitsWithMasktoIndex toOffsetasMaskBefore Returns an index of a next set if lookFor true or clear if lookFor false bit after startIndex inclusive Returns 1 for lookFor true or size for lookFor false if there is no such bits between startIndex and size 1 throws IndexOutOfBoundException if startIndex 0 ", "modifier": "private ", "signature": "fun nextBit(startIndex: Int, lookFor: Boolean): Int", "body": "{<EOL> if (startIndex < 0) {<EOL> throw IndexOutOfBoundsException()<EOL> }"}
{"docstring": " Returns an index of a next bit which value is true after startIndex inclusive Returns 1 if there is no such bits after startIndex throws IndexOutOfBoundException if startIndex 0 public fun nextSetBitstartIndex Int 0 Int nextBitstartIndex true Returns an index of a next bit which value is false after startIndex inclusive Returns size if there is no such bits between startIndex and size 1 assuming that the set has an infinite sequence of false bits after size 1th throws IndexOutOfBoundException if startIndex 0 public fun nextClearBitstartIndex Int 0 Int nextBitstartIndex false Returns the biggest index of a bit which value is lookFor before startIndex inclusive Returns 1 if there is no such bits before startIndex If startIndex size returns 1 ", "modifier": "public ", "signature": "fun previousBit(startIndex: Int, lookFor: Boolean): Int", "body": "{<EOL> var correctStartIndex = startIndex<EOL> if (startIndex >= size) {<EOL> // We assume that all bits after `size - 1` are 0. So we can return the start index if we are looking for 0.<EOL> if (!lookFor) {<EOL> return startIndex<EOL> }"}
{"docstring": " To unify the logic of Double and Float parsing we need a common method to calculate a negative value Unfortunately in this case we need to make uncheck cast to generic type T to have a proper return type SuppressUNCHECKED_CAST private inline fun reified T unaryMinusvalue T T return when value is Float value as T is Double value as T else throw NumberFormatException Takes a String and does some initial parsing Should return a StringExponentPair containing a String with no leading or trailing white space and trailing zeroes eliminated The exponent of the StringExponentPair will be used to calculate the floating point number by taking the positive integer the String represents and multiplying by 10 raised to the power of the exponent This method is not optimal can cause performance issues This logic can be done in one single run It also violates Kotlin coding practices and should be refactored in the future after stabilizing the logic param string the String that will be parsed to a floating point return a StringExponentPair with necessary values exception NumberFormatException if the String doesnt pass basic tests ", "modifier": "private ", "signature": "fun initialParse(string: String): StringExponentPair", "body": "{<EOL> var s = string<EOL> var length = s.length<EOL> var negative = false<EOL> val decimal: Int<EOL> var shift: Int<EOL> var e = 0<EOL> var start = 0<EOL> var c: Char = s[length - 1]<EOL><EOL> // Checking that the initial string ends with one of valid prefixes(D/d/F/f) and skipping it.<EOL> if (c == 'D' || c == 'd' || c == 'F' || c == 'f') {<EOL> length--<EOL> if (length == 0)<EOL> throw NumberFormatException(s)<EOL> }"}
{"docstring": " Test execution settings ExperimentalNativeApiinternal data class TestSettings val testSuites ListTestSuite val listeners SetTestListener val logger TestLogger val runTests Boolean val iterations Int val useExitCode Boolean Test processor that initializes the TestSettings using the command line options passed in args See the help for the description of arguments ExperimentalNativeApiinternal class TestProcessorval suites ListTestSuite val args ArrayString Processes given arguments to set test settings and filter tests to be run see TestSettings ", "modifier": "", "signature": "fun process(): TestSettings", "body": "{<EOL> val listeners = mutableSetOf<TestListener>()<EOL> val filters = mutableListOf<TestFilter>()<EOL> var logger: TestLogger = GTestLogger()<EOL> var runTests = true<EOL> var useExitCode = true<EOL> var iterations = 1<EOL><EOL> args.filter {<EOL> it.startsWith(\"--gtest_\") || it.startsWith(\"--ktest_\") || it == \"--help\" || it == \"-h\"<EOL> }"}
{"docstring": " Atomically decrements the current value by one DeprecatedUse decrementAndGet or getAndDecrement instead ReplaceWiththisdecrementAndGet DeprecationLevelERROR public fun decrement Unit addAndGet1L Returns the string representation of this object public override fun toString String valuetoString An object reference that is always updated atomically DeprecatedUse kotlinconcurrentAtomicReference instead ReplaceWithkotlinconcurrentAtomicReference DeprecationLevelERRORpublic class AtomicReferenceTpublic Volatile var value T Atomically sets the value to the given new valuenewValue and returns the old value public fun getAndSetnewValue T T thisvaluegetAndSetFieldnewValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected returns true if the operation was successful and false only if the current value was not equal to the expected value Provides sequential consistent ordering guarantees and cannot fail spuriously Comparison of values is done by reference public fun compareAndSetexpected T newValue T Boolean thisvaluecompareAndSetFieldexpected newValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected and returns the old value in any case Provides sequential consistent ordering guarantees and cannot fail spuriously Comparison of values is done by reference public fun compareAndSwapexpected T newValue T T thisvaluecompareAndExchangeFieldexpected newValue Returns the string representation of this object public override fun toString String debugStringthis debugStringvalue A kotlinxcinteropNativePtr value that is always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile kotlinxcinteropNativePtr is a value type hence it is stored in AtomicNativePtr without boxing and compareAndSet compareAndSwap operations perform comparison by value DeprecatedUse kotlinconcurrentAtomicNativePtr instead ReplaceWithkotlinconcurrentAtomicNativePtr DeprecationLevelERRORpublic class AtomicNativePtrpublic Volatile var value NativePtr Atomically sets the value to the given new valuenewValue and returns the old value ", "modifier": "public ", "signature": "fun getAndSet(newValue: NativePtr): NativePtr", "body": "{<EOL> // Pointer types are allowed for atomicrmw xchg operand since LLVM 15.0,<EOL> // after LLVM version update, it may be implemented via getAndSetField intrinsic.<EOL> // Check: https://youtrack.jetbrains.com/issue/KT-57557<EOL> while (true) {<EOL> val old = value<EOL> if (this::value.compareAndSetField(old, newValue)) {<EOL> return old<EOL> }"}
{"docstring": " Process pending jobs on the queue of this worker Note that jobs scheduled with executeAfter using nonzero timeout are not processed this way If termination request arrives while processing the queue via this API worker is marked as terminated and will exit once the current request is done with throws IllegalStateException if this request is executed on noncurrent Worker return true if requests was processed and false otherwise public fun processQueue Boolean processQueueInternalid Park execution of the current worker until a new request arrives or timeout specified in timeoutMicroseconds elapsed If process is true pending queue elements are processed including delayed requests Note that multiple requests could be processed this way param timeoutMicroseconds defines how long to park worker if no requests arrive waits forever if 1 param process defines if arrived requests shall be processed return if process is true if requests was processed true and false otherwise if process is false true if requests has arrived and false if timeout happens throws IllegalStateException if this request is executed on noncurrent Worker throws IllegalArgumentException if timeout value is incorrect ", "modifier": "public ", "signature": "fun park(timeoutMicroseconds: Long, process: Boolean = false): Boolean", "body": "{<EOL> if (timeoutMicroseconds < -1) throw IllegalArgumentException()<EOL> return parkInternal(id, timeoutMicroseconds, process)<EOL> }"}
{"docstring": " An IntArray in which elements are always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile SinceKotlin19RequireKotlinversion 1920 versionKind RequireKotlinVersionKindCOMPILER_VERSIONExperimentalStdlibApipublic class AtomicIntArray private val array IntArray Creates a new AtomicIntArray of the given size with all elements initialized to zero throws RuntimeException if the specified size is negative public constructorsize Int array IntArraysize Creates a new AtomicIntArray filled with elements of the given array PublishedApi internal constructorarray IntArray thisarray arraycopyOf Returns the number of elements in the array public val length Int get arraysize Atomically gets the value of the element at the given index Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun getindex Int Int checkBoundsindex return arrayatomicGetindex Atomically sets the value of the element at the given index to the new valuenewValue Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun setindex Int newValue Int Unit checkBoundsindex arrayatomicSetindex newValue Atomically sets the value of the element at the given index to the new valuenewValue and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndSet(index: Int, newValue: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndSet(index, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue Returns true if the operation was successful and false only if the current value of the element was not equal to the expected value Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndSet(index: Int, expectedValue: Int, newValue: Int): Boolean", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndSet(index, expectedValue, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue and returns the old value of the element in any case Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndExchange(index: Int, expectedValue: Int, newValue: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndExchange(index, expectedValue, newValue)<EOL> }"}
{"docstring": " Atomically adds the given delta to the element at the given index and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndAdd(index: Int, delta: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, delta)<EOL> }"}
{"docstring": " Atomically adds the given delta to the element at the given index and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun addAndGet(index: Int, delta: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, delta) + delta<EOL> }"}
{"docstring": " Atomically increments the element at the given index by one and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndIncrement(index: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, 1)<EOL> }"}
{"docstring": " Atomically increments the element at the given index by one and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun incrementAndGet(index: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, 1) + 1<EOL> }"}
{"docstring": " Atomically decrements the element at the given index by one and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndDecrement(index: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, -1)<EOL> }"}
{"docstring": " Atomically decrements the element at the given index by one and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun decrementAndGet(index: Int): Int", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, -1) - 1<EOL> }"}
{"docstring": " Returns the string representation of the underlying IntArrayarray public override fun toString String arraytoString private fun checkBoundsindex Int if index 0 index arraysize throw IndexOutOfBoundsExceptionThe index index is out of the bounds of the AtomicIntArray with size arraysize Creates a new AtomicIntArray of the given size where each element is initialized by calling the given init function The function init is called for each array element sequentially starting from the first one It should return the value for an array element given its index throws RuntimeException if the specified size is negative SinceKotlin19RequireKotlinversion 1920 versionKind RequireKotlinVersionKindCOMPILER_VERSIONExperimentalStdlibApipublic inline fun AtomicIntArraysize Int init Int Int AtomicIntArray val inner IntArraysize for index in 0 until size innerindex initindex return AtomicIntArrayinner An LongArray in which elements are always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile SinceKotlin19RequireKotlinversion 1920 versionKind RequireKotlinVersionKindCOMPILER_VERSIONExperimentalStdlibApipublic class AtomicLongArray private val array LongArray Creates a new AtomicLongArray of the given size with all elements initialized to zero throws RuntimeException if the specified size is negative public constructorsize Int array LongArraysize Creates a new AtomicLongArray filled with elements of the given array PublishedApi internal constructorarray LongArray thisarray arraycopyOf Returns the number of elements in the array public val length Int get arraysize Atomically gets the value of the element at the given index Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun getindex Int Long checkBoundsindex return arrayatomicGetindex Atomically sets the value of the element at the given index to the new valuenewValue Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun setindex Int newValue Long Unit checkBoundsindex arrayatomicSetindex newValue Atomically sets the value of the element at the given index to the new valuenewValue and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndSet(index: Int, newValue: Long): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndSet(index, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue Returns true if the operation was successful and false only if the current value of the element was not equal to the expected value Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndSet(index: Int, expectedValue: Long, newValue: Long): Boolean", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndSet(index, expectedValue, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue and returns the old value of the element in any case Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndExchange(index: Int, expectedValue: Long, newValue: Long): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndExchange(index, expectedValue, newValue)<EOL> }"}
{"docstring": " Atomically adds the given delta to the element at the given index and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndAdd(index: Int, delta: Long): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, delta)<EOL> }"}
{"docstring": " Atomically adds the given delta to the element at the given index and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun addAndGet(index: Int, delta: Long): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, delta) + delta<EOL> }"}
{"docstring": " Atomically increments the element at the given index by one and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndIncrement(index: Int): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, 1L)<EOL> }"}
{"docstring": " Atomically increments the element at the given index by one and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun incrementAndGet(index: Int): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, 1L) + 1L<EOL> }"}
{"docstring": " Atomically decrements the element at the given index by one and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndDecrement(index: Int): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, -1L)<EOL> }"}
{"docstring": " Atomically decrements the element at the given index by one and returns the new value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun decrementAndGet(index: Int): Long", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndAdd(index, -1L) - 1L<EOL> }"}
{"docstring": " Returns the string representation of the underlying IntArrayarray public override fun toString String arraytoString private fun checkBoundsindex Int if index 0 index arraysize throw IndexOutOfBoundsExceptionThe index index is out of the bounds of the AtomicLongArray with size arraysize Creates a new AtomicLongArray of the given size where each element is initialized by calling the given init function The function init is called for each array element sequentially starting from the first one It should return the value for an array element given its index throws RuntimeException if the specified size is negative SinceKotlin19RequireKotlinversion 1920 versionKind RequireKotlinVersionKindCOMPILER_VERSIONExperimentalStdlibApipublic inline fun AtomicLongArraysize Int init Int Long AtomicLongArray val inner LongArraysize for index in 0 until size innerindex initindex return AtomicLongArrayinner An ArrayT in which elements are always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile SinceKotlin19RequireKotlinversion 1920 versionKind RequireKotlinVersionKindCOMPILER_VERSIONExperimentalStdlibApipublic class AtomicArrayT private val array ArrayT Creates a new AtomicArrayT filled with elements of the given array PublishedApi internal constructorarray ArrayT thisarray arraycopyOf Returns the number of elements in the array public val length Int get arraysize Atomically gets the value of the element at the given index Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun getindex Int T checkBoundsindex return arrayatomicGetindex Atomically sets the value of the element at the given index to the new valuenewValue Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array public operator fun setindex Int newValue T Unit checkBoundsindex arrayatomicSetindex newValue Atomically sets the value of the element at the given index to the new valuenewValue and returns the old value of the element Provides sequential consistent ordering guarantees throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun getAndSet(index: Int, newValue: T): T", "body": "{<EOL> checkBounds(index)<EOL> return array.getAndSet(index, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue Returns true if the operation was successful and false only if the current value of the element was not equal to the expected value Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndSet(index: Int, expectedValue: T, newValue: T): Boolean", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndSet(index, expectedValue, newValue)<EOL> }"}
{"docstring": " Atomically sets the value of the element at the given index to the new valuenewValue if the current value equals the expected valueexpectedValue and returns the old value of the element in any case Provides sequential consistent ordering guarantees and never fails spuriously throws IndexOutOfBoundsException if the index is out of bounds of this array ", "modifier": "public ", "signature": "fun compareAndExchange(index: Int, expectedValue: T, newValue: T): T", "body": "{<EOL> checkBounds(index)<EOL> return array.compareAndExchange(index, expectedValue, newValue)<EOL> }"}
{"docstring": " An Int value that is always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile SinceKotlin19public class AtomicIntVolatile public var value Int Atomically sets the value to the given new valuenewValue and returns the old value public fun getAndSetnewValue Int Int thisvaluegetAndSetFieldnewValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected returns true if the operation was successful and false only if the current value was not equal to the expected value Provides sequential consistent ordering guarantees and cannot fail spuriously public fun compareAndSetexpected Int newValue Int Boolean thisvaluecompareAndSetFieldexpected newValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected and returns the old value in any case Provides sequential consistent ordering guarantees and cannot fail spuriously public fun compareAndExchangeexpected Int newValue Int Int thisvaluecompareAndExchangeFieldexpected newValue Atomically adds the given valuedelta to the current value and returns the old value public fun getAndAdddelta Int Int thisvaluegetAndAddFielddelta Atomically adds the given valuedelta to the current value and returns the new value public fun addAndGetdelta Int Int thisvaluegetAndAddFielddelta delta Atomically increments the current value by one and returns the old value public fun getAndIncrement Int thisvaluegetAndAddField1 Atomically increments the current value by one and returns the new value public fun incrementAndGet Int thisvaluegetAndAddField1 1 Atomically decrements the current value by one and returns the new value public fun decrementAndGet Int thisvaluegetAndAddField1 1 Atomically decrements the current value by one and returns the old value public fun getAndDecrement Int thisvaluegetAndAddField1 Returns the string representation of the current value public override fun toString String valuetoString A Long value that is always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile SinceKotlin19public class AtomicLongVolatile public var value Long Atomically sets the value to the given new valuenewValue and returns the old value public fun getAndSetnewValue Long Long thisvaluegetAndSetFieldnewValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected returns true if the operation was successful and false only if the current value was not equal to the expected value Provides sequential consistent ordering guarantees and cannot fail spuriously public fun compareAndSetexpected Long newValue Long Boolean thisvaluecompareAndSetFieldexpected newValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected and returns the old value in any case Provides sequential consistent ordering guarantees and cannot fail spuriously public fun compareAndExchangeexpected Long newValue Long Long thisvaluecompareAndExchangeFieldexpected newValue Atomically adds the given valuedelta to the current value and returns the old value public fun getAndAdddelta Long Long thisvaluegetAndAddFielddelta Atomically adds the given valuedelta to the current value and returns the new value public fun addAndGetdelta Long Long thisvaluegetAndAddFielddelta delta Atomically increments the current value by one and returns the old value public fun getAndIncrement Long thisvaluegetAndAddField1L Atomically increments the current value by one and returns the new value public fun incrementAndGet Long thisvaluegetAndAddField1L 1L Atomically decrements the current value by one and returns the new value public fun decrementAndGet Long thisvaluegetAndAddField1L 1L Atomically decrements the current value by one and returns the old value public fun getAndDecrement Long thisvaluegetAndAddField1L Returns the string representation of the current value public override fun toString String valuetoString An object reference that is always updated atomically SinceKotlin19public class AtomicReferenceTpublic Volatile var value T Atomically sets the value to the given new valuenewValue and returns the old value public fun getAndSetnewValue T T thisvaluegetAndSetFieldnewValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected returns true if the operation was successful and false only if the current value was not equal to the expected value Provides sequential consistent ordering guarantees and cannot fail spuriously Comparison of values is done by reference public fun compareAndSetexpected T newValue T Boolean thisvaluecompareAndSetFieldexpected newValue Atomically sets the value to the given new valuenewValue if the current value equals the expected valueexpected and returns the old value in any case Provides sequential consistent ordering guarantees and cannot fail spuriously Comparison of values is done by reference public fun compareAndExchangeexpected T newValue T T thisvaluecompareAndExchangeFieldexpected newValue Returns the string representation of the current value public override fun toString String debugStringthis debugStringvalue A kotlinxcinteropNativePtr value that is always updated atomically For additional details about atomicity guarantees for reads and writes see kotlinconcurrentVolatile kotlinxcinteropNativePtr is a value type hence it is stored in AtomicNativePtr without boxing and compareAndSet compareAndExchange operations perform comparison by value SinceKotlin19ExperimentalForeignApipublic class AtomicNativePtrVolatile public var value NativePtr Atomically sets the value to the given new valuenewValue and returns the old value ", "modifier": "public ", "signature": "fun getAndSet(newValue: NativePtr): NativePtr", "body": "{<EOL> // Pointer types are allowed for atomicrmw xchg operand since LLVM 15.0,<EOL> // after LLVM version update, it may be implemented via getAndSetField intrinsic.<EOL> // Check: https://youtrack.jetbrains.com/issue/KT-57557<EOL> while (true) {<EOL> val old = value<EOL> if (this::value.compareAndSetField(old, newValue)) {<EOL> return old<EOL> }"}
{"docstring": " Runs this task if it is ready to be run and returns the next task to run fun run TaskControlBlock val packet Packet if thisstate STATE_SUSPENDED_RUNNABLE packet thisqueue thisqueue packetlink if thisqueue null thisstate STATE_RUNNING else thisstate STATE_RUNNABLE else packet null return thistaskrunpacket Adds a packet to the work list of this blocks task marks this as runnable if necessary and returns the next runnable object to run the one with the highest priority ", "modifier": "", "signature": "fun checkPriorityAdd(task: TaskControlBlock, packet: Packet): TaskControlBlock", "body": "{<EOL> if (this.queue == null) {<EOL> this.queue = packet<EOL> this.markAsRunnable()<EOL> if (this.priority > task.priority) return this<EOL> }"}
{"docstring": " The task is running and is currently scheduled var STATE_RUNNING 0 The task has packets left to process var STATE_RUNNABLE 1 The task is not currently running The task is not blocked as such and may be started by the scheduler var STATE_SUSPENDED 2 The task is blocked and cannot be run until it is explicitly released var STATE_HELD 4var STATE_SUSPENDED_RUNNABLE STATE_SUSPENDED or STATE_RUNNABLEvar STATE_NOT_HELD STATE_HELDinvinterface Task fun runpacket Packet TaskControlBlock An idle task doesnt do any work itself but cycles control between the two device tasks param Scheduler scheduler the scheduler that manages this task param int v1 a seed value that controls how the device tasks are scheduled param int count the number of times this task should be scheduled constructor class IdleTaskvar scheduler Scheduler var v1 Int var count Int Task override fun runpacket Packet TaskControlBlock thiscount if thiscount 0 return thisschedulerholdCurrent if thisv1 and 1 0 thisv1 thisv1 shr 1 return thisschedulerreleaseID_DEVICE_A else thisv1 thisv1 shr 1 xor 0xD008 return thisschedulerreleaseID_DEVICE_B override fun toString String return IdleTask A task that suspends itself after each time it has been run to simulate waiting for data from an external device param Scheduler scheduler the scheduler that manages this task constructor class DeviceTaskvar scheduler Scheduler Task var v1 Packet null override fun runpacket Packet TaskControlBlock if packet null if thisv1 null return thisschedulersuspendCurrent val v thisv1 thisv1 null return thisschedulerqueuev else thisv1 packet return thisschedulerholdCurrent override fun toString String return DeviceTask A task that manipulates work packets param Scheduler scheduler the scheduler that manages this task param int v1 a seed used to specify how work packets are manipulated param int v2 another seed used to specify how work packets are manipulated constructor class WorkerTaskvar scheduler Scheduler var v1 Int var v2 Int Task override fun runpacket Packet TaskControlBlock if packet null return thisschedulersuspendCurrent else if thisv1 ID_HANDLER_A thisv1 ID_HANDLER_B else thisv1 ID_HANDLER_A packetid thisv1 packeta1 0 for i in 0 until DATA_SIZE thisv2 if thisv2 26 thisv2 1 packeta2i thisv2 return thisschedulerqueuepacket override fun toString String return WorkerTask A task that manipulates work packets and then suspends itself param Scheduler scheduler the scheduler that manages this task constructor class HandlerTaskvar scheduler Scheduler Task var v1 Packet null var v2 Packet null override fun runpacket Packet TaskControlBlock if packet null if packetkind KIND_WORK thisv1 packetaddTothisv1 else thisv2 packetaddTothisv2 thisv1let v1 val count thisv1a1 if count DATA_SIZE thisv2let v2 val v v2 thisv2 v2link va1 v1a2count v1a1 count 1 return thisschedulerqueuev else val v v1 thisv1 v1link return thisschedulerqueuev return thisschedulersuspendCurrent override fun toString String return HandlerTask P a c k e t var DATA_SIZE 4 A simple package of data that is manipulated by the tasks The exact layout of the payload data carried by a packet is not important and neither is the nature of the work performed on packets by the tasks Besides carrying data packets form linked lists and are hence used both as data and work lists param Packet link the tail of the linked list of packets param int id an ID for this packet param int kind the type of this packet constructor class Packetvar link Packet var id Int var kind Int var a1 Int 0 var a2 IntArrayDATA_SIZE Add this packet to the end of a work list and return the work list param Packet queue the work list to add this packet to ", "modifier": "", "signature": "fun addTo(queue: Packet?): Packet", "body": "{<EOL> this.link = null<EOL> if (queue == null) return this<EOL> var next: Packet = queue<EOL> var peek = next.link<EOL> while (peek != null) {<EOL> next = peek<EOL> peek = next.link<EOL> }"}
{"docstring": " Relates two variables by the linear scaling relationship v2 v1 scale offset Either v1 or v2 may be changed to maintain this relationship but the scale factor and offset are considered readonly class ScaleConstraintsrc Variable val scale Variable val offset Variable dest Variable strength Strength BinaryConstraintsrc dest strength Adds this constraint to the constraint graph override fun addToGraph superaddToGraph scaleaddConstraintthis offsetaddConstraintthis override fun removeFromGraph superremoveFromGraph if thisscale null scaleremoveConstraintthis if thisoffset null offsetremoveConstraintthis override fun markInputsmark Int supermarkInputsmark scalemark mark offsetmark mark Enforce this constraint Assume that it is satisfied override fun execute if direction DirectionFORWARD v2value v1value scalevalue offsetvalue else v1value v2value offsetvalue scalevalue Calculate the walkabout strength the stay flag and if it is stay the value for the current output of this constraint Assume this constraint is satisfied override fun recalculate val ihn input val out output outwalkStrength StrengthweakestOfstrength ihnwalkStrength outstay ihnstay scalestay offsetstay if outstay execute E q u a l i t y C o n s t r a i n t Constrains two variables to have the same value class EqualityConstraintvar1 Variable var2 Variable strength Strength BinaryConstraintvar1 var2 strength Enforce this constraint Assume that it is satisfied override fun execute outputvalue inputvalue V a r i a b l e A constrained variable In addition to its value it maintain the structure of the constraint graph the current dataflow graph and various parameters of interest to the DeltaBlue incremental constraint solver class Variableval name String var value Int 0 val constraints OrderedCollectionConstraint var determinedBy Constraint null var mark 0 var walkStrength StrengthWEAKEST var stay true Add the given constraint to the set of all constraints that refer this variable fun addConstraintc Constraint constraintsaddc Removes all traces of c from this variable fun removeConstraintc Constraint constraintsremovec if determinedBy c determinedBy null P l a n n e r The DeltaBlue planner class Planner var currentMark 0 Activate the constraint and attempt to satisfy it fun addc Constraint caddToGraph incrementalAddc Attempt to satisfy the given constraint and if successful incrementally update the dataflow graph Details If satifying the constraint is successful it may override a weaker constraint on its output The algorithm attempts to resatisfy that constraint using some other method This process is repeated until either a it reaches a variable that was not previously determined by any constraint or b it reaches a constraint that is too weak to be satisfied using any of its methods The variables of constraints that have been processed are marked with a unique mark value so that we know where weve been This allows the algorithm to avoid getting into an infinite loop even if the constraint graph has an inadvertent cycle fun incrementalAddc Constraint val mark newMark var overridden csatisfymark this while overridden null overridden overriddensatisfymark this Entry point for retracting a constraint Remove the given constraint and incrementally update the dataflow graph Details Retracting the given constraint may allow some currently unsatisfiable downstream constraint to be satisfied We therefore collect a list of unsatisfied downstream constraints and attempt to satisfy each one in turn This list is traversed by constraint strength strongest first as a heuristic for avoiding unnecessarily adding and then overriding weak constraints Assume c is satisfied fun incrementalRemovec Constraint val out coutput cmarkUnsatisfied cremoveFromGraph var unsatisfied removePropagateFromout var strength StrengthREQUIRED do for u in unsatisfied if ustrength strength thisincrementalAddu strength strengthnextWeaker while strength StrengthWEAKEST Select a previously unused mark value fun newMark currentMark Extract a plan for resatisfaction starting from the given source constraints usually a set of input constraints This method assumes that stay optimization is desired the plan will contain only constraints whose output variables are not stay Constraints that do no computation such as stay and edit constraints are not included in the plan Details The outputs of a constraint are marked when it is added to the plan under construction A constraint may be appended to the plan when all its input variables are known A variable is known if either a the variable is marked indicating that has been computed by a constraint appearing earlier in the plan b the variable is stay ie it is a constant at plan execution time or c the variable is not determined by any constraint The last provision is for past states of history variables which are not stay but which are also not computed by any constraint Assume sources are all satisfied ", "modifier": "", "signature": "fun makePlan(sources: OrderedCollection<Constraint>): Plan", "body": "{<EOL> var mark = this.newMark()<EOL> var plan = Plan()<EOL> var todo = sources<EOL> while (todo.size() > 0) {<EOL> var c = todo.removeFirst()<EOL> if (c.output().mark != mark && c.inputsKnown(mark)) {<EOL> plan.addConstraint(c)<EOL> c.output().mark = mark<EOL> addConstraintsConsumingTo(c.output(), todo)<EOL> }"}
{"docstring": " Extract a plan for resatisfying starting from the output of the given constraints usually a set of input constraints ", "modifier": "", "signature": "fun extractPlanFromConstraints(constraints: OrderedCollection<Constraint>): Plan", "body": "{<EOL> val sources = OrderedCollection<Constraint>()<EOL> for (c in constraints) {<EOL> if (c.isInput() && c.isSatisfied())<EOL> // not in plan already and eligible for inclusion<EOL> sources.add(c)<EOL> }"}
{"docstring": " Recompute the walkabout strengths and stay flags of all variables downstream of the given constraint and recompute the actual values of all variables whose stay flag is true If a cycle is detected remove the given constraint and answer false Otherwise answer true Details Cycles are detected when a marked variable is encountered downstream of the given constraint The sender is assumed to have marked the inputs of the given constraint with the given mark Thus encountering a marked node downstream of the output constraint means that there is a path from the constraints output to one of its inputs ", "modifier": "", "signature": "fun addPropagate(c: Constraint, mark: Int): Boolean", "body": "{<EOL> val todo = OrderedCollection<Constraint>()<EOL> todo.add(c)<EOL> while (todo.size() > 0) {<EOL> var d = todo.removeFirst()<EOL> if (d.output().mark == mark) {<EOL> incrementalRemove(c)<EOL> return false<EOL> }"}
{"docstring": " Supposed to be true for a single LLVM module within final binary val KonanConfigisFinalBinary Boolean get when thisproduce CompilerOutputKindPROGRAM CompilerOutputKindDYNAMIC CompilerOutputKindSTATIC true CompilerOutputKindDYNAMIC_CACHE CompilerOutputKindSTATIC_CACHE CompilerOutputKindHEADER_CACHE CompilerOutputKindLIBRARY CompilerOutputKindBITCODE false CompilerOutputKindFRAMEWORK omitFrameworkBinary CompilerOutputKindTEST_BUNDLE true else errornot supported thisproduceval CompilerOutputKindisNativeLibrary Boolean get this CompilerOutputKindDYNAMIC this CompilerOutputKindSTATIC Return true if compiler has to generate a C API for dynamicstatic library val KonanConfigproduceCInterface Boolean get thisproduceisNativeLibrary thiscInterfaceGenerationMode CInterfaceGenerationModeNONEval CompilerOutputKindinvolvesBitcodeGeneration Boolean get this CompilerOutputKindLIBRARYinternal val CacheDeserializationStrategycontainsKFunctionImpl Boolean get thiscontainsKonanFqNamesinternalPackageName KFunctionImplkt falseinternal val NativeGenerationStateshouldDefineFunctionClasses Boolean get producedLlvmModuleContainsStdlib cacheDeserializationStrategycontainsKFunctionImplinternal val NativeGenerationStateshouldDefineCachedBoxes Boolean get producedLlvmModuleContainsStdlib cacheDeserializationStrategycontainsKonanFqNamesinternalPackageName Boxingkt falseinternal val CacheDeserializationStrategycontainsRuntime Boolean get thiscontainsKonanFqNamesinternalPackageName Runtimekt falseinternal val NativeGenerationStateshouldLinkRuntimeNativeLibraries Boolean get producedLlvmModuleContainsStdlib cacheDeserializationStrategycontainsRuntimeval CompilerOutputKindisFullCache Boolean get this CompilerOutputKindSTATIC_CACHE this CompilerOutputKindDYNAMIC_CACHEval CompilerOutputKindisHeaderCache Boolean get this CompilerOutputKindHEADER_CACHEval CompilerOutputKindisCache Boolean get thisisFullCache thisisHeaderCacheinternal fun produceCStubsgenerationState NativeGenerationState generationStatecStubsManagercompile generationStateconfigclang generationStatemessageCollector generationStateinVerbosePhase forEach parseAndLinkBitcodeFilegenerationState generationStatellvmmodule itabsolutePath private data class LlvmModules val runtimeModules ListLLVMModuleRef val additionalModules ListLLVMModuleRef Deserialize generate patch all bitcode dependencies and classify them into two sets Runtime modules These may be used as an input for a separate LTO eg for debug builds Everything else ", "modifier": "private ", "signature": "fun collectLlvmModules(generationState: NativeGenerationState, generatedBitcodeFiles: List<String>): LlvmModules", "body": "{<EOL> val config = generationState.config<EOL><EOL> val (bitcodePartOfStdlib, bitcodeLibraries) = generationState.dependenciesTracker.bitcodeToLink<EOL> .partition { it.isNativeStdlib && generationState.producedLlvmModuleContainsStdlib }"}
{"docstring": " Searches for an IR class for classDescriptor in symbol table Generates one if absent ", "modifier": "", "signature": "fun findOrGenerateCEnum(classDescriptor: ClassDescriptor, parent: IrDeclarationContainer): IrClass", "body": "{<EOL> val irClassSymbol = symbolTable.descriptorExtension.referenceClass(classDescriptor)<EOL> return if (!irClassSymbol.isBound) {<EOL> provideIrClassForCEnum(classDescriptor).also {<EOL> it.patchDeclarationParents(parent)<EOL> parent.declarations += it<EOL> }"}
{"docstring": " The main function that for given descriptor of the enum generates the whole IR tree including entries CEnumVar class and companion objects private fun provideIrClassForCEnumdescriptor ClassDescriptor IrClass createClassdescriptor enumIrClass enumIrClassaddMembercreateEnumPrimaryConstructordescriptor enumIrClassaddMembercreateValuePropertyenumIrClass descriptorenumEntriesmapToenumIrClassdeclarations entryDescriptor createEnumEntrydescriptor entryDescriptor enumClassMembersGeneratorgenerateSpecialMembersenumIrClass enumIrClassaddChildcEnumCompanionGeneratorgenerateenumIrClass enumIrClassaddChildcEnumVarClassGeneratorgenerateenumIrClass Creates value property that stores integral value of the enum ", "modifier": "private ", "signature": "fun createValueProperty(irClass: IrClass): IrProperty", "body": "{<EOL> val propertyDescriptor = irClass.descriptor<EOL> .findDeclarationByName<PropertyDescriptor>(\"value\")<EOL> ?: error(\"No `value` property in ${irClass.name}"}
{"docstring": " Provides utility methods to the implementer internal interface ContextUtils RuntimeAware val generationState NativeGenerationState val context Context get generationStatecontext override val runtime Runtime get generationStatellvmruntime val argumentAbiInfo TargetAbiInfo get contexttargetAbiInfo Describes the target platform TODO using llvmTargetData usually results in generating nonportable bitcode val llvmTargetData LLVMTargetDataRef get runtimetargetData val llvm CodegenLlvmHelpers get generationStatellvm val staticData KotlinStaticData get generationStatellvmstaticData TODO maybe itd be better to replace with IrDeclarationisEffectivelyExternal or just drop all else branches of corresponding conditionals ", "modifier": "", "signature": "fun isExternal(declaration: IrDeclaration): Boolean", "body": "{<EOL> return !generationState.llvmModuleSpecification.containsDeclaration(declaration)<EOL> }"}
{"docstring": " Provides utilities to create static data internal open class StaticDataval module LLVMModuleRef private val llvm CodegenLlvmHelpers Represents the LLVM global variable class Global private constructorval llvmGlobal LLVMValueRef companion object private fun createLlvmGlobalmodule LLVMModuleRef type LLVMTypeRef name String isExported Boolean LLVMValueRef if isExported LLVMGetNamedGlobalmodule name null throw IllegalArgumentExceptionGlobal name already exists Globals created with this API are not thread local val llvmGlobal LLVMAddGlobalmodule type name if isExported LLVMSetLinkagellvmGlobal LLVMLinkageLLVMInternalLinkage return llvmGlobal fun createstaticData StaticData type LLVMTypeRef name String isExported Boolean Global val isUnnamed name LLVM will select the unique index and represent the global as idx if isUnnamed isExported throw IllegalArgumentExceptionunnamed global cant be exported val llvmGlobal createLlvmGlobalstaticDatamodule type name isExported return GloballlvmGlobal fun getstaticData StaticData name String Global val llvmGlobal LLVMGetNamedGlobalstaticDatamodule name return null return GloballlvmGlobal fun getmodule LLVMModuleRef name String Global val llvmGlobal LLVMGetNamedGlobalmodule name return null return GloballlvmGlobal val type get getGlobalTypethisllvmGlobal fun getInitializer LLVMGetInitializerllvmGlobal fun setInitializervalue ConstValue LLVMSetInitializerllvmGlobal valuellvm fun setZeroInitializer LLVMSetInitializerllvmGlobal LLVMConstNullthistype fun setConstantvalue Boolean LLVMSetGlobalConstantllvmGlobal if value 1 else 0 Globals that are marked with unnamed_addr might be merged by LLVMs ConstantMerge pass fun setUnnamedAddrvalue Boolean LLVMSetUnnamedAddrllvmGlobal if value 1 else 0 fun setLinkagevalue LLVMLinkage LLVMSetLinkagellvmGlobal value fun setAlignmentvalue Int LLVMSetAlignmentllvmGlobal value fun setSectionname String LLVMSetSectionllvmGlobal name fun setExternallyInitializedvalue Boolean LLVMSetExternallyInitializedllvmGlobal if value 1 else 0 val pointer ConstPointer constPointerthisllvmGlobal Creates Global with given type and name It is external until explicitly initialized with GlobalsetInitializer ", "modifier": "", "signature": "fun createGlobal(type: LLVMTypeRef, name: String, isExported: Boolean = false): Global", "body": "{<EOL> return Global.create(this, type, name, isExported)<EOL> }"}
{"docstring": " Creates Global with given name and value ", "modifier": "", "signature": "fun placeGlobal(name: String, initializer: ConstValue, isExported: Boolean = false): Global", "body": "{<EOL> val global = createGlobal(initializer.llvmType, name, isExported)<EOL> global.setInitializer(initializer)<EOL> return global<EOL> }"}
{"docstring": " Creates arraytyped global with given name and value ", "modifier": "", "signature": "fun placeGlobalArray(name: String, elemType: LLVMTypeRef?, elements: List<ConstValue>, isExported: Boolean = false): Global", "body": "{<EOL> val initializer = ConstArray(elemType, elements)<EOL> val global = placeGlobal(name, initializer, isExported)<EOL><EOL> return global<EOL> }"}
{"docstring": " Creates static instance of konanImmutableByteArray with given values of elements param args data for constant creation ", "modifier": "", "signature": "fun createImmutableBlob(value: IrConst<String>): LLVMValueRef", "body": "{<EOL> val args = value.value.map { llvm.int8(it.code.toByte()) }"}
{"docstring": " Produces the name to be used for nonexported LLVM declarations corresponding to declaration Note since these declarations are going to be private the name is only required not to clash with any exported declarations ", "modifier": "private ", "signature": "fun qualifyInternalName(declaration: IrDeclaration): String", "body": "{<EOL> return getFqName(declaration).asString() + \"#internal\"<EOL> }"}
{"docstring": " For WHEN COND1 CASE1 COND2 CASE2 ELSE UNCONDITIONAL the following sequence of basic blocks is generated if COND1 CASE1 NEXT1if COND2 CASE2 NEXT2 UNCONDITIONAL EXIT ", "modifier": "private ", "signature": "fun evaluateWhen(expression: IrWhen, resultSlot: LLVMValueRef?): LLVMValueRef", "body": "{<EOL> context.log{\"evaluateWhen : ${ir2string(expression)}"}
{"docstring": " Formally this ordering is too weak and doesnt prevent data race with installing extra object Check comment in ObjHeadertype_info for details val memoryOrder LLVMAtomicOrderingLLVMAtomicOrderingMonotonic TODO Get rid of the bitcast here by supplying the type in the GEP above val typeInfoOrMetaPtrRaw bitcastpointerTypecodegenintPtrType typeInfoOrMetaPtr val typeInfoOrMetaWithFlags loadcodegenintPtrType typeInfoOrMetaPtrRaw memoryOrder memoryOrder Clear two lower bits val typeInfoOrMetaRaw andtypeInfoOrMetaWithFlags codegenimmTypeInfoMask val typeInfoOrMeta intToPtrtypeInfoOrMetaRaw kTypeInfoPtr val typeInfoPtrPtr structGepruntimetypeInfoType typeInfoOrMeta 0 typeInfo return loadcodegenkTypeInfoPtr typeInfoPtrPtr memoryOrder LLVMAtomicOrderingLLVMAtomicOrderingMonotonic SuppressUNUSED_PARAMETER fun getObjectValueirClass IrClass exceptionHandler ExceptionHandler startLocationInfo LocationInfo endLocationInfo LocationInfo null resultSlot LLVMValueRef null LLVMValueRef errorShould be lowered out irClassrender while generating irFunctiondump Note the same code is generated as IR in orgjetbrainskotlinbackendkonanlowerEnumUsageLowering ", "modifier": "", "signature": "fun getEnumEntry(enumEntry: IrEnumEntry, exceptionHandler: ExceptionHandler): LLVMValueRef", "body": "{<EOL> val enumClass = enumEntry.parentAsClass<EOL> val getterId = context.enumsSupport.enumEntriesMap(enumClass)[enumEntry.name]!!.getterId<EOL> return call(<EOL> context.enumsSupport.getValueGetter(enumClass).llvmFunction,<EOL> listOf(llvm.int32(getterId)),<EOL> Lifetime.GLOBAL,<EOL> exceptionHandler<EOL> )<EOL> }"}
{"docstring": " Takes a function DFGs node and creates a constraint graph node corresponding to it Also creates all necessary edges except for variable nodes For variable nodes edges must be created separately otherwise recursion can be too deep ", "modifier": "private ", "signature": "fun dfgNodeToConstraintNode(function: Function, node: DataFlowIR.Node): Node", "body": "{<EOL><EOL> fun edgeToConstraintNode(edge: DataFlowIR.Edge): Node =<EOL> edgeToConstraintNode(function, edge)<EOL><EOL> fun doCall(callee: DataFlowIR.FunctionSymbol, arguments: List<Node>,<EOL> returnType: DataFlowIR.Type.Declared) =<EOL> doCall(function, callee, arguments, returnType)<EOL><EOL> fun readField(field: DataFlowIR.Field, actualType: DataFlowIR.Type.Declared): Node {<EOL> val fieldNode = fieldNode(field)<EOL> val expectedType = field.type.resolved()<EOL> return if (!useTypes || actualType == expectedType)<EOL> fieldNode<EOL> else<EOL> doCast(function, fieldNode, actualType)<EOL> }"}
{"docstring": " Allows to distinguish external declarations to internal ABI internal val INTERNAL_ABI_ORIGIN IrDeclarationOriginImplINTERNAL_ABI Sometimes we need to reference symbols that are not declared in metadata For example symbol might be declared during lowering In case of compiler caches this means that it is not accessible as Lazy IR and we have to explicitly add an external declaration internal class CachesAbiSupportmapping NativeMapping private val irFactory IrFactory private val outerThisAccessors mappingouterThisCacheAccessors private val lateinitPropertyAccessors mappinglateinitPropertyCacheAccessors private val lateInitFieldToNullableField mappinglateInitFieldToNullableField fun getOuterThisAccessorirClass IrClass IrSimpleFunction requireirClassisInner Expected an inner class but was irClassrender return outerThisAccessorsgetOrPutirClass irFactorybuildFun name getMangledNameForouterThis irClass origin INTERNAL_ABI_ORIGIN returnType irClassparentAsClassdefaultType apply parent irClassgetPackageFragment attributeOwnerId irClass To be able to get the file addValueParameter name NameidentifierinnerClass origin INTERNAL_ABI_ORIGIN type irClassdefaultType fun getLateinitPropertyAccessorirProperty IrProperty IrSimpleFunction requireirPropertyisLateinit Expected a lateinit property but was irPropertyrender return lateinitPropertyAccessorsgetOrPutirProperty val backingField irPropertybackingField errorLateinit property irPropertyrender should have a backing field val actualField lateInitFieldToNullableFieldbackingField backingField val owner irPropertyparent irFactorybuildFun name getMangledNameForirPropertyname_field owner origin INTERNAL_ABI_ORIGIN returnType actualFieldtype apply parent irPropertygetPackageFragment attributeOwnerId irProperty To be able to get the file owner as IrClasslet addValueParameter name Nameidentifierowner origin INTERNAL_ABI_ORIGIN type itdefaultType Generate name for declaration that will be a part of internal ABI ", "modifier": "private ", "signature": "fun getMangledNameFor(declarationName: String, parent: IrDeclarationParent): Name", "body": "{<EOL> val prefix = parent.fqNameForIrSerialization<EOL> return \"$prefix.$declarationName\".synthesizedName<EOL> }"}
{"docstring": " This pass replaces calls to StringBuilderappendAny with StringBuilderappendString StringplusAny with StringplusImplString StringplusAny with StringplusImplString For this toString is called for nonString arguments This call can be later devirtualized improving escape analysis For nullable arguments the following snippet is used if argnull null else argtoString to pass to StringBuilderappendString if argnull null else argtoString to pass to other methods as nonnullable String internal class StringConcatenationTypeNarrowingval context Context FileLoweringPass IrBuildingTransformercontext private val string contextirsymbolsstringowner private val stringBuilder contextirsymbolsstringBuilderowner private val namePlusImpl NameidentifierplusImpl private val nameAppend Nameidentifierappend private val appendNullableStringFunction stringBuilderfunctionssingle StringBuilderappendString itname nameAppend itvalueParameterssingleOrNulltypeisNullableString true private val appendAnyFunction stringBuilderfunctionssingle StringBuilderappendAny itname nameAppend itvalueParameterssingleOrNulltypeisNullableAny true private val plusImplFunction stringfunctionssingle external fun StringplusImplString itname namePlusImpl itvalueParameterssize 1 itvalueParameterssingletypeisString override fun lowerirFile IrFile irFiletransformChildrenVoidthis override fun visitCallexpression IrCall IrExpression expressiontransformChildrenVoidthis return withexpression builderatthis when symbol appendAnyFunctionsymbol StringBuilderappendAny buildConcatenationCallappendNullableStringFunction dispatchReceiver buildArgForAppendgetValueArgument0 contextirBuiltInsmemberStringPlus buildConcatenationCallplusImplFunction dispatchReceiver buildNullableArgToStringgetValueArgument0 contextirBuiltInsextensionStringPlus buildConcatenationCallplusImplFunction buildNullableArgToStringextensionReceiver buildNullableArgToStringgetValueArgument0 else expression private fun buildConcatenationCallfunction IrSimpleFunction receiver IrExpression argument IrExpression IrExpression builderirCallfunctionsymbol functionreturnType valueArgumentsCount 1 typeArgumentsCount 0 apply putValueArgument0 argument dispatchReceiver receiver Builds snippet of type String ifargumentnull null else argumenttoString if arguments type is nullable Note fortunately all null string structures are unified argumenttoString otherwise Note should side effects are possible temporary val is introduced private fun buildNullableArgToStringargument IrExpression IrExpression if argumenttypeisNullable builderirBlock nullableArgToStringTypeargument contextirBuiltInsstringType irStringnull else buildNonNullableArgToStringargument Builds snippet of type String ifargumentnull null else argumenttoString that is similar to argumenttoString if arguments type is nullable argumenttoString otherwise Note should side effects are possible temporary val is introduced private fun buildArgForAppendargument IrExpression IrExpression if argumenttypeisNullable Transform argument of StringBuilderappendAny to ARGtoString of type String builderirBlock nullableArgToStringTypeargument contextirBuiltInsstringTypemakeNullable irNull else Transform argument of StringBuilderappendAny to ARGtoString of type String buildNonNullableArgToStringargument Builds snippet of type String val arg argument if argnull ifNull else argtoString In case argument is IrGetValue temporary val is omitted due to side effect absence private fun IrBlockBuildernullableArgToStringTypeargument IrExpression stringType IrType ifNull IrExpression val firstExpression secondExpression twoExpressionsForSubsequentUsagesargument irIfThenElse stringType condition irEqeqeqfirstExpression irNull thenPart ifNull elsePart buildNonNullableArgToStringsecondExpression origin null Builds snippet of type String argument in case arguments type is String since StringtoString is noop argument in case arguments type is String due to smartcast and noop argumenttoString otherwise ", "modifier": "private ", "signature": "fun buildNonNullableArgToString(argument: IrExpression): IrExpression", "body": "{<EOL> return if (argument.type.isString() || argument.type.isNullableString())<EOL> argument<EOL> else {<EOL> val calleeOrNull = argument.type.classOrNull?.owner?.functions?.singleOrNull {<EOL> it.name == OperatorNameConventions.TO_STRING && it.valueParameters.isEmpty()<EOL> }"}
{"docstring": " Checks if this or any of its parent functions has the annotation with the given testAnnotation If this contains the given annotation returns this If one of the parent functions contains the given annotation returns the IrFunctionSymbol for it If the annotation isnt found or found only in interface methods returns null fun IrFunctionSymbolfindAnnotatedFunctiontestAnnotation FqName IrFunctionSymbol val owner thisowner val parent ownerparent if parent is IrClass parentisInterface return null if hasAnnotationtestAnnotation return this return owner as IrSimpleFunction overriddenSymbols firstNotNullOfOrNull itfindAnnotatedFunctiontestAnnotation fun registerClassFunctionirClass IrClass function IrFunction kinds CollectionPairFunctionKind ignored Boolean fun warnmsg String contextreportWarningmsg irFile function kindsforEach kind ignored val annotation kindannotationFqName when kind in FunctionKindINSTANCE_KINDS withirClass when isInner warnAnnotation annotation is not allowed for methods of an inner class isAbstract We cannot create an abstract test class but its allowed to mark its methods as tests because the class can be extended So skip this case without warnings isCompanion warnAnnotation annotation is not allowed for methods of a companion object constructorsnone itvalueParameterssize 0 warnTest class has no default constructor fqNameForIrSerialization else testClassesgetTestClassirClassregisterFunctionfunction kind ignored in FunctionKindCOMPANION_KINDS when irClassisCompanion val containingClass irClassparentAsClass val testClass testClassesgetTestClasscontainingClass testClasscompanion irClass testClassregisterFunctionfunction kind ignored irClasskind ClassKindOBJECT testClassesgetTestClassirClassregisterFunctionfunction kind ignored else warnAnnotation annotation is only allowed for methods of an object named or companion or top level functions else throw IllegalStateExceptionUnreachable fun IrFunctioncheckFunctionSignature Test runner requires test functions to have the following signature Unit if returnTypeisUnit contextreportCompilationError Test function must return Unit fqNameForIrSerialization irFile this if valueParametersisNotEmpty contextreportCompilationError Test function must have no arguments fqNameForIrSerialization irFile this private fun warnAboutInheritedAnnotations kind FunctionKind function IrFunctionSymbol annotatedFunction IrFunctionSymbol if functionowner annotatedFunctionowner contextreportWarning Super method has a test annotation kindannotationFqName but the overriding method doesnt Note that the overriding method will still be executed irFile functionowner private fun warnAboutLoneIgnorefunctionSymbol IrFunctionSymbol Unit withfunctionSymbol if hasAnnotationIGNORE_FQ_NAME hasAnnotationFunctionKindTESTannotationFqName contextreportWarning Unused IGNORE_FQ_NAME annotation not paired with FunctionKindTESTannotationFqName irFile owner TODO Use symbols instead of containingDeclaration when such information is available override fun visitFunctiondeclaration IrFunction val symbol declarationsymbol val parent declarationparent warnAboutLoneIgnoresymbol val kinds FunctionKindvaluesmapNotNull kind symbolfindAnnotatedFunctionkindannotationFqNamelet annotatedFunction warnAboutInheritedAnnotationskind symbol annotatedFunction kind to kind FunctionKindTEST annotatedFunctionhasAnnotationIGNORE_FQ_NAME if kindsisEmpty return declarationcheckFunctionSignature when parent is IrPackageFragment topLevelFunctionsregisterFunctiondeclaration kinds is IrClass registerClassFunctionparent declaration kinds else UnsupportedOperationExceptionCannot create test function declaration defined in parent endregion region Symbol and IR builders Builds a method in owner class with name getterName returning a reference to an object represented by objectSymbol private fun buildObjectGetterobjectSymbol IrClassSymbol owner IrClass getterName Name IrSimpleFunction contextirFactorycreateSimpleFunction ownerstartOffset ownerendOffset TEST_SUITE_GENERATED_MEMBER getterName DescriptorVisibilitiesPROTECTED isInline false isExpect false objectSymbolstarProjectedType ModalityFINAL IrSimpleFunctionSymbolImpl isTailrec false isSuspend false isOperator false isInfix false apply parent owner val superFunction baseClassSuitesimpleFunctions single itname getterName itvalueParametersisEmpty createDispatchReceiverParameter overriddenSymbols superFunctionsymbol body contextcreateIrBuildersymbol symbolownerstartOffset symbolownerendOffsetirBlockBody irReturnirGetObjectValueobjectSymboltypeWithArgumentsemptyList objectSymbol Builds a method in testSuite class with name getterName returning a new instance of class referenced by classSymbol private fun buildInstanceGetterclassSymbol IrClassSymbol owner IrClass getterName Name IrSimpleFunction contextirFactorycreateSimpleFunction ownerstartOffset ownerendOffset TEST_SUITE_GENERATED_MEMBER getterName DescriptorVisibilitiesPROTECTED isInline false isExpect false classSymbolstarProjectedType ModalityFINAL IrSimpleFunctionSymbolImpl isTailrec false isSuspend false isOperator false isInfix false apply parent owner val superFunction baseClassSuitesimpleFunctions single itname getterName itvalueParametersisEmpty createDispatchReceiverParameter overriddenSymbols superFunctionsymbol body contextcreateIrBuildersymbol symbolownerstartOffset symbolownerendOffsetirBlockBody val constructor classSymbolownerconstructorssingle itvalueParametersisEmpty irReturnirCallconstructor private val baseClassSuiteConstructor baseClassSuiteconstructorssingle itvalueParameterssize 2 itvalueParameters0typeisString name String itvalueParameters1typeisBoolean ignored Boolean Builds a constructor for a test suite class representing a test class any class in the original IrFile with methods annotated with Test The test suite class is a subclass of ClassTestSuiteT where T is the test class private fun buildClassSuiteConstructorsuiteName String testClassType IrType testCompanionType IrType testSuite IrClassSymbol owner IrClass functions CollectionTestFunction ignored Boolean IrConstructor contextirFactorycreateConstructor testSuiteownerstartOffset testSuiteownerendOffset TEST_SUITE_GENERATED_MEMBER Namespecialinit DescriptorVisibilitiesPUBLIC isInline false isExpect false testSuitestarProjectedType IrConstructorSymbolImpl isPrimary true apply parent owner fun IrClassgetFunctionname String predicate IrSimpleFunction Boolean simpleFunctionssingle itnameasString name predicateit val registerTestCase baseClassSuitegetFunctionregisterTestCase itvalueParameterssize 3 itvalueParameters0typeisString name String itvalueParameters1typeisFunction function testClassType Unit itvalueParameters2typeisBoolean ignored Boolean val registerFunction baseClassSuitegetFunctionregisterFunction itvalueParameterssize 2 itvalueParameters0typeisTestFunctionKind kind TestFunctionKind itvalueParameters1typeisFunction function Unit body contextcreateIrBuildersymbol symbolownerstartOffset symbolownerendOffsetirBlockBody irDelegatingConstructorCallbaseClassSuiteConstructorapply putTypeArgument0 testClassType putTypeArgument1 testCompanionType putValueArgument0 irStringsuiteName putValueArgument1 irBooleanignored generateFunctionRegistrationtestSuiteownerthisReceiver registerTestCase registerFunction functions private val IrClassignored Boolean get annotationshasAnnotationIGNORE_FQ_NAME Builds a test suite class representing a test class any class in the original IrFile with methods annotated with Test The test suite class is a subclass of ClassTestSuiteT where T is the test class ", "modifier": "private ", "signature": "fun buildClassSuite(\n            suiteName: String,\n            testClass: IrClass,\n            testCompanion: IrClass?,\n            functions: Collection<TestFunction>,\n            irFile: IrFile\n    ): IrClass", "body": "{<EOL> return context.irFactory.createClass(<EOL> testClass.startOffset,<EOL> testClass.endOffset,<EOL> TEST_SUITE_CLASS,<EOL> testClass.name.synthesizeSuiteClassName(),<EOL> DescriptorVisibilities.PRIVATE,<EOL> IrClassSymbolImpl(),<EOL> ClassKind.CLASS,<EOL> Modality.FINAL,<EOL> ).apply {<EOL> irFile.addChild(this)<EOL> createParameterDeclarations()<EOL><EOL> val testClassType = testClass.defaultType<EOL> val testCompanionType = if (testClass.kind == ClassKind.OBJECT) {<EOL> testClassType<EOL> }"}
{"docstring": " Check if this fqName already used or not ", "modifier": "private ", "signature": "fun checkTopLevelSuiteName(irFile: IrFile, topLevelSuiteName: String): Boolean", "body": "{<EOL> if (topLevelSuiteNames.contains(topLevelSuiteName)) {<EOL> context.reportCompilationError(\"Package '${irFile.packageFqName}"}
{"docstring": " Transforms a function reference into a subclass of kotlinnativeinternalKFunctionImpl and kotlinFunctionN or kotlinnativeinternalKSuspendFunctionImpl and kotlinKSuspendFunctionN for suspend functionslambdas or Any for simple lamdbas or a custom superclass in case of SAM conversion For example barlambda0BarTP in the following code kotlin fun FooTP foov FooTP l FooTP String String return lv private fun T barlambda0t T String fun BarTP barv BarTP String return foov barlambda0BarTP is lowered into kotlin private class barlambda0FUNCTION_REFERENCE0T kotlinnativeinternalKFunctionImplString kotlinFunction1T String override fun invokep1 T String return barlambda0Tp1 fun BarTP barv BarTP String return foov barlambda0FUNCTION_REFERENCE0BarTP internal class FunctionReferenceLoweringval generationState NativeGenerationState FileLoweringPass companion object private val DECLARATION_ORIGIN_FUNCTION_REFERENCE_IMPL IrDeclarationOriginImplFUNCTION_REFERENCE_IMPL fun isLoweredFunctionReferencedeclaration IrDeclaration Boolean declarationorigin DECLARATION_ORIGIN_FUNCTION_REFERENCE_IMPL override fun lowerirFile IrFile var generatedClasses mutableListOfIrClass irFiletransformobject IrElementTransformerVoidWithContext private val stack mutableListOfIrElement override fun visitElementelement IrElement IrElement stackpushelement val result supervisitElementelement stackpop return result override fun visitExpressionexpression IrExpression IrExpression stackpushexpression val result supervisitExpressionexpression stackpop return result override fun visitDeclarationdeclaration IrDeclarationBase IrStatement lateinit var tempGeneratedClasses MutableListIrClass if declaration is IrClass tempGeneratedClasses generatedClasses generatedClasses mutableListOf stackpushdeclaration val result supervisitDeclarationdeclaration stackpop if declaration is IrClass declarationdeclarations generatedClasses generatedClasses tempGeneratedClasses return result override fun visitSpreadElementspread IrSpreadElement IrSpreadElement stackpushspread val result supervisitSpreadElementspread stackpop return result Handle SAM conversions which wrap a function reference class samnprivate val receiver R Interface override fun method receivertarget This avoids materializing an invokable KFunction representing thus producing one less class This is actually very common as Interface something is a local function a SAMconversion of a reference to it into an implementation override fun visitTypeOperatorexpression IrTypeOperatorCall IrExpression if expressionoperator IrTypeOperatorSAM_CONVERSION val invokable expressionargument val reference if invokable is IrFunctionReference invokable else if invokable is IrBlock invokableoriginisLambda invokablestatementslast is IrFunctionReference By this point the lambdas function has been replaced with empty IrComposite by LocalDeclarationsLowering val statements invokablestatements requirestatementssize 2 requirestatements0 as IrCompositestatementsisEmpty true statements1 as IrFunctionReference else return supervisitTypeOperatorexpression referencetransformChildrenVoid return transformFunctionReferencereference expressiontypeOperand return supervisitTypeOperatorexpression override fun visitFunctionReferenceexpression IrFunctionReference IrExpression expressiontransformChildrenVoidthis for i in stacksize 1 downTo 0 val cur stacki if cur is IrBlock continue if cur is IrCall break val argument if i stacksize 1 stacki 1 else expression val parameter cursymbolownervalueParameterssingleOrNull curgetValueArgumentitindex argument if parameterannotationsfindAnnotationVOLATILE_LAMBDA_FQ_NAME null return expression break if expressiontypeisFunction expressiontypeisKFunction expressiontypeisKSuspendFunction expressiontypeisSuspendFunction Not a subject of this lowering return expression return transformFunctionReferenceexpression fun transformFunctionReferenceexpression IrFunctionReference samSuperType IrType null IrExpression val parent IrDeclarationContainer currentClassirElement as IrClass irFile val irBuilder generationStatecontextcreateIrBuildercurrentScopescopescopeOwnerSymbol expressionstartOffset expressionendOffset val clazz newExpression FunctionReferenceBuilderirFile parent expression generationState irBuilder samSuperTypebuild generatedClassesaddclazz return newExpression data null irFiledeclarations generatedClasses private val VOLATILE_LAMBDA_FQ_NAME FqNamefromSegmentslistOfkotlin native internal VolatileLambda class FunctionReferenceBuilder val irFile IrFile val parent IrDeclarationParent val functionReference IrFunctionReference val generationState NativeGenerationState val irBuilder IrBuilderWithScope val samSuperType IrType null data class BuiltFunctionReferenceval functionReferenceClass IrClass val functionReferenceExpression IrExpression private val context generationStatecontext private val irBuiltIns contextirBuiltIns private val symbols contextirsymbols private val irFactory contextirFactory private val fileLowerState generationStatefileLowerState private val startOffset functionReferencestartOffset private val endOffset functionReferenceendOffset private val referencedFunction functionReferencesymbolowner private val functionParameters referencedFunctionexplicitParameters private val boundFunctionParameters functionReferencegetArgumentsWithIrmap itfirst private val unboundFunctionParameters functionParameters boundFunctionParameters private val isLambda functionReferenceoriginisLambda private val isK functionReferencetypeisKFunction functionReferencetypeisKSuspendFunction private val isSuspend functionReferencetypeisSuspendFunction functionReferencetypeisKSuspendFunction private val adaptedReferenceOriginalTarget referencedFunctiongetAdapteeFromAdaptedForReferenceFunction private val functionReferenceTarget adaptedReferenceOriginalTarget referencedFunction The first element of a pair is a type parameter of referencedFunction the second element is its argument in functionReference private val allTypeParametersAndArguments ListPairIrTypeParameterSymbol IrType referencedFunctiontypeParametersmap typeParam typeParamsymbol to functionReferencegetTypeArgumenttypeParamindex see allTypeParametersAndArguments private val allTypeParametersAndArgumentsMap MapIrTypeParameterSymbol IrType allTypeParametersAndArgumentstoMap The distinct type arguments of functionReference that are not concrete types but are themselves type parameters coming from an enclosing scope private val typeParametersFromEnclosingScope ListIrTypeParameter allTypeParametersAndArguments mapNotNull _ typeArgument typeArgumentclassifierOrNull as IrTypeParameterSymbolowner distinct private val functionReferenceClass irFactorybuildClass startOffset thisFunctionReferenceBuilderstartOffset endOffset thisFunctionReferenceBuilderendOffset origin DECLARATION_ORIGIN_FUNCTION_REFERENCE_IMPL name fileLowerStategetFunctionReferenceImplUniqueNamefunctionReferenceTargetsynthesizedName visibility DescriptorVisibilitiesPRIVATE apply parent thisFunctionReferenceBuilderparent The function reference class only needs to be generic over type parameters coming from an enclosing scope copyTypeParameterstypeParametersFromEnclosingScope createParameterDeclarations copy the generated name for IrClass partially solves KT47194 generationStatecopyLocalClassNamefunctionReference this Remaps typeParametersFromEnclosingScope to type parameters of functionReferenceClass private val typeParameterRemapper IrTypeParameterRemapper typeParametersFromEnclosingScopezipfunctionReferenceClasstypeParameterstoMap private fun IrTyperemappedTypeArguments ListIrType if this is IrSimpleType return emptyList return argumentsmapIndexed index typeArgument when typeArgument is IrTypeProjection typeParameterRemapperremapTypetypeArgumenttype is IrStarProjection classifier as IrClassSymbolownertypeParametersindexdefaultTypeerasure private val functionParameterAndReturnTypes functionReferencetyperemappedTypeArguments private val functionParameterTypes functionParameterAndReturnTypesdropLast1 private val functionReturnType functionParameterAndReturnTypeslast private val functionReferenceThis functionReferenceClassthisReceiver Replaces typeParameter of referencedFunction with the corresponding type parameter of functionReferenceClass if such correspondence takes place Otherwise just returns typeParameter as IrType ", "modifier": "private ", "signature": "fun substituteTypeParameterOfReferencedFunction(typeParameter: IrTypeParameter): IrType", "body": "{<EOL> if (typeParameter.parent != referencedFunction) {<EOL> // TODO: We might have references to off-scope type parameters (because of the inliner, see KT-56500 for details).<EOL> // Fixing inliner requires a lot of work, so just return the upper bound for now instead of throwing an error.<EOL> // compilationException(<EOL> // \"The type parameter ${typeParameter.render()}"}
{"docstring": " Queue of arguments descriptors Arguments can have several values so one descriptor can be returned several times internal class ArgumentsQueueargumentsDescriptors ListArgDescriptor Map of arguments descriptors and their current usage number private val argumentsUsageNumber linkedMapOfargumentsDescriptorsmap it to 0 toTypedArray Get next descriptor from queue fun pop String if argumentsUsageNumberisEmpty return null val currentDescriptor usageNumber argumentsUsageNumberiteratornext currentDescriptornumberlet Parse all arguments for current argument description if usageNumber 1 currentDescriptornumber All needed arguments were provided argumentsUsageNumberremovecurrentDescriptor else argumentsUsageNumbercurrentDescriptor usageNumber 1 return currentDescriptorfullName A property delegate that provides access to the argumentoption value interface ArgumentValueDelegateT The value of an option or argument parsed from command line Accessing this value before ArgParserparse method is called will result in an exception see CLIEntityvalue var value T Provides the value for the delegated property getter Returns the value property throws IllegalStateException in case of accessing the value before ArgParserparse method is called operator fun getValuethisRef Any property KProperty T value Sets the value to the ArgumentValueDelegatevalue property from the delegated property setter This operation is possible only after command line arguments were parsed with ArgParserparse throws IllegalStateException in case of resetting value before command line arguments are parsed operator fun setValuethisRef Any property KProperty value T thisvalue value Abstract base class for subcommands ExperimentalCliabstract class Subcommandval name String val actionDescription String ArgParsername Execute action if subcommand was provided abstract fun execute val helpMessage String get name actionDescriptionn Argument parsing result Contains name of subcommand which was called property commandName name of command which was called class ArgParserResultval commandName String Arguments parser property programName the name of the current program property useDefaultHelpShortName specifies whether to register h option for printing the usage information property prefixStyle the style of option prefixing property skipExtraArguments specifies whether the extra unmatched arguments in a command line string can be skipped without producing an error message open class ArgParser val programName String var useDefaultHelpShortName Boolean true var prefixStyle OptionPrefixStyle OptionPrefixStyleLINUX var skipExtraArguments Boolean false Map of options key full name of option value pair of descriptor and parsed values private val options mutableMapOfString ParsingValue Map of arguments key full name of argument value pair of descriptor and parsed values private val arguments mutableMapOfString ParsingValue Map with declared options private val declaredOptions mutableListOfCLIEntityWrapper Map with declared arguments private val declaredArguments mutableListOfCLIEntityWrapper State of parser Stores last parsing result or null private var parsingState ArgParserResult null Map of subcommands OptInExperimentalCliclass protected val subcommands mutableMapOfString Subcommand Mapping for short options names for quick search private val shortNames mutableMapOfString ParsingValue Used prefix form for full option form protected val optionFullFormPrefix if prefixStyle OptionPrefixStyleJVM else Used prefix form for short option form protected val optionShortFromPrefix Name with all commands that should be executed protected val fullCommandName mutableListOfprogramName Flag to recognize if CLI entities can be treated as options protected var treatAsOption true Arguments which should be parsed with subcommands private val subcommandsArguments mutableListOfString Options which should be parsed with subcommands private val subcommandsOptions mutableListOfString Subcommand used in commmand line arguments private var usedSubcommand Subcommand null The way an optionargument has got its value enum class ValueOrigin The value was parsed from command line arguments SET_BY_USER The value was missing in command line therefore the default value was used SET_DEFAULT_VALUE The value is not initialized by command line values or by default values UNSET The value was redefined after parsing manually usually with the property setter REDEFINED The value is undefined because parsing wasnt called UNDEFINED The style of option prefixing enum class OptionPrefixStyle Linux style the full name of an option is prefixed with two hyphens and the short name with one LINUX JVM style both full and short names are prefixed with one hyphen JVM GNU style the full name of an option is prefixed with two hyphens and between options and value and the short name with one Detailed information httpswwwgnuorgsoftwarelibcmanualhtml_nodeArgumentSyntaxhtml GNU DeprecatedOPTION_PREFIX_STYLE is deprecated Please use OptionPrefixStyle ReplaceWithOptionPrefixStyle kotlinxcliOptionPrefixStyle SuppressTOPLEVEL_TYPEALIASES_ONLY typealias OPTION_PREFIX_STYLE OptionPrefixStyle Declares a named option and returns an object which can be used to access the option value after all arguments are parsed or to delegate a property for accessing the option value to By default the option supports only a single value is optional and has no default value therefore its values type is T You can alter the option properties by chaining extensions for the option type on the returned object AbstractSingleOptiondefault to provide a default value that is used when the option is not specified SingleNullableOptionrequired to make the option nonoptional AbstractSingleOptiondelimiter to allow specifying multiple values in one command line argument with a delimiter AbstractSingleOptionmultiple to allow specifying the option several times param type The type describing how to parse an option value from a string an instance of ArgType eg ArgTypeString or ArgTypeChoice param fullName the full name of the option can be omitted if the option name is inferred from the name of a property delegated to this option param shortName the short name of the option null if the option cannot be specified in a short form param description the description of the option used when rendering the usage information param deprecatedWarning the deprecation message for the option Specifying anything except null makes this option deprecated The message is rendered in a help message and issued as a warning when the option is encountered when parsing command line arguments fun T Any option type ArgTypeT fullName String null shortName String null description String null deprecatedWarning String null SingleNullableOptionT if prefixStyle OptionPrefixStyleGNU shortName null requireshortNamelength 1 GNU standart for options allow to use short form which consists of one character For more information please see httpswwwgnuorgsoftwarelibcmanualhtml_nodeArgumentSyntaxhtml trimIndent val option SingleNullableOptionOptionDescriptoroptionFullFormPrefix optionShortFromPrefix type fullName shortName description deprecatedWarning deprecatedWarning CLIEntityWrapper optionownerentity option declaredOptionsaddoptionowner return option Check usage of required property for arguments Make sense only for several last arguments private fun inspectRequiredAndDefaultUsage var previousArgument ParsingValue null argumentsforEach _ currentArgument previousArgumentlet previous Previous argument has default value if previousdescriptordefaultValueSet if currentArgumentdescriptordefaultValueSet currentArgumentdescriptorrequired errorDefault value of argument previousdescriptorfullName will be unused because next argument currentArgumentdescriptorfullName is always required and has no default value Previous argument is optional if previousdescriptorrequired if currentArgumentdescriptordefaultValueSet currentArgumentdescriptorrequired errorArgument previousdescriptorfullName will be always required because next argument currentArgumentdescriptorfullName is always required previousArgument currentArgument Declares an argument and returns an object which can be used to access the argument value after all arguments are parsed or to delegate a property for accessing the argument value to By default the argument supports only a single value is required and has no default value therefore its values type is T You can alter the argument properties by chaining extensions for the argument type on the returned object AbstractSingleArgumentdefault to provide a default value that is used when the argument is not specified SingleArgumentoptional to allow omitting the argument AbstractSingleArgumentmultiple to require the argument to have exactly the number of values specified AbstractSingleArgumentvararg to allow specifying an unlimited number of values for the _last_ argument param type The type describing how to parse an option value from a string an instance of ArgType eg ArgTypeString or ArgTypeChoice param fullName the full name of the argument can be omitted if the argument name is inferred from the name of a property delegated to this argument param description the description of the argument used when rendering the usage information param deprecatedWarning the deprecation message for the argument Specifying anything except null makes this argument deprecated The message is rendered in a help message and issued as a warning when the argument is encountered when parsing command line arguments fun T Any argument type ArgTypeT fullName String null description String null deprecatedWarning String null SingleArgumentT DefaultRequiredTypeRequired val argument SingleArgumentT DefaultRequiredTypeRequiredArgDescriptortype fullName 1 description deprecatedWarning deprecatedWarning CLIEntityWrapper argumentownerentity argument declaredArgumentsaddargumentowner return argument Registers one or more subcommands param subcommandsList subcommands to add ExperimentalCli fun subcommandsvararg subcommandsList Subcommand subcommandsListforEach if itname in subcommands errorSubcommand with name itname was already defined Set same settings as main parser itprefixStyle prefixStyle ituseDefaultHelpShortName useDefaultHelpShortName fullCommandNameforEachIndexed index namePart itfullCommandNameaddindex namePart subcommandsitname it Outputs an error message adding the usage information after it param message error message ", "modifier": "", "signature": "fun printError(message: String): Nothing", "body": "{<EOL> error(\"$message\\n${makeUsage()}"}
{"docstring": " Save value as argument value param arg string with argument value param argumentsQueue queue with active argument descriptors ", "modifier": "private ", "signature": "fun saveAsArg(arg: String, argumentsQueue: ArgumentsQueue): Boolean", "body": "{<EOL> // Find next uninitialized arguments.<EOL> val name = argumentsQueue.pop()<EOL> name?.let {<EOL> val argumentValue = arguments[name]!!<EOL> argumentValue.descriptor.deprecatedWarning?.let { printWarning(it) }"}
{"docstring": " Treat value as argument value param arg string with argument value param argumentsQueue queue with active argument descriptors private fun treatAsArgumentarg String argumentsQueue ArgumentsQueue if saveAsArgarg argumentsQueue usedSubcommandlet if treatAsOption subcommandsOptions else subcommandsArgumentsaddarg printErrorToo many arguments Couldnt process argument arg Save value as option value private fun T Any U Any saveAsOptionparsingValue ParsingValueT U value String parsingValueaddValuevalue Try to recognize and save command line element as full form of option param candidate string with candidate in options param argIterator iterator over command line arguments ", "modifier": "private ", "signature": "fun recognizeAndSaveOptionFullForm(candidate: String, argIterator: Iterator<String>): Boolean", "body": "{<EOL> if (prefixStyle == OptionPrefixStyle.GNU && candidate == optionFullFormPrefix) {<EOL> // All other arguments after `--` are treated as non-option arguments.<EOL> treatAsOption = false<EOL> return false<EOL> }"}
{"docstring": " Save option without parameter param argValue argument value with all information about option internal fun saveOptionWithoutParameterargValue ParsingValue Boolean flags if argValuedescriptorfullName help usedSubcommandlet itparselistOfitoptionFullFormPrefixargValuedescriptorfullName printlnmakeUsage exitProcess0 saveAsOptionargValue true Save option described with standard separated form name value param argValue argument value with all information about option param argIterator iterator over command line arguments private fun saveStandardOptionFormargValue ParsingValue argIterator IteratorString if argValuedescriptortypehasParameter if argIteratorhasNext saveAsOptionargValue argIteratornext else An error option with value without value printErrorNo value for argValuedescriptortextDescription else saveOptionWithoutParameterargValue Try to recognize and save command line element as short form of option param candidate string with candidate in options param argIterator iterator over command line arguments ", "modifier": "private ", "signature": "fun recognizeAndSaveOptionShortForm(candidate: String, argIterator: Iterator<String>): Boolean", "body": "{<EOL> if (!candidate.startsWith(optionShortFromPrefix) ||<EOL> optionFullFormPrefix != optionShortFromPrefix && candidate.startsWith(optionFullFormPrefix)) return false<EOL> // Try to find exact match.<EOL> val option = candidate.substring(optionShortFromPrefix.length)<EOL> val argValue = shortNames[option]<EOL> if (argValue != null) {<EOL> saveStandardOptionForm(argValue, argIterator)<EOL> }"}
{"docstring": " A replacement of the standard exec see orggradleapiProjectexec interface ExecutorService val project Project fun executeclosure Closurein ExecSpec ExecResult execute projectconfigurethis closure fun executeaction Actionin ExecSpec ExecResultprivate fun Executorserviceproject Project object ExecutorService override val project get project override fun executeaction Actionin ExecSpec ExecResult val execSpec projectobjectsnewInstanceDefaultExecSpecapply actionexecutethis val request ExecuteRequest executableAbsolutePath execSpecexecutable args execSpecargs timeout 40toDurationDurationUnitMINUTES apply execSpecstandardInputlet stdin it execSpecstandardOutputlet stdout it execSpecerrorOutputlet stderr it environmentputAllexecSpecenvironmentmapValues ittoString val response thisserviceexecuterequest return object ExecResult override fun getExitValue responseexitCode 1 override fun assertNormalExitValue ExecResult if exitValue 0 throw ExecExceptionFailed with exit code exitValue return this override fun rethrowFailure ExecResult return this Creates an ExecutorService depending on a test target Ptest_target ", "modifier": "", "signature": "fun create(project: Project): ExecutorService", "body": "{<EOL> val testTarget = project.testTarget<EOL> val configurables = project.testTargetConfigurables<EOL><EOL> val executor = when {<EOL> project.compileOnlyTests -> NoOpExecutor(explanation = \"compile-only tests\")<EOL> testTarget == HostManager.host -> HostExecutor()<EOL> configurables is ConfigurablesWithEmulator && testTarget != HostManager.host -> EmulatorExecutor(configurables)<EOL> configurables is AppleConfigurables && configurables.targetTriple.isSimulator -> XcodeSimulatorExecutor(configurables).apply {<EOL> // Property can specify device identifier to be run on. For example, `com.apple.CoreSimulator.SimDeviceType.iPhone-11`<EOL> project.findProperty(\"iosDevice\")?.toString()?.let {<EOL> deviceId = it<EOL> }"}
{"docstring": " Execute Clang the way that produced object file is compatible with the one that produced by KotlinNative for given target It means 1 We pass flags that set sysroot 2 We call Clang from toolchain in case of Apple target ", "modifier": "", "signature": "fun execClangForCompilerTests(target: KonanTarget, action: Action<in ExecSpec>): ExecResult", "body": "{<EOL> val defaultArgs = platformManager.platform(target).clang.clangArgs.toList()<EOL> return execOperations.exec {<EOL> action.execute(this)<EOL> executable = if (target.family.isAppleFamily) {<EOL> resolveToolchainExecutable(target, executable)<EOL> }"}
{"docstring": " Associative container from a KonanTarget with optional SanitizerKind to T Serves similar purpose to NamedDomainObjectContainerorggradleapiNamedDomainObjectContainer except this is keyed on a target instead of a name Also this implementation does not support lazy creation Plugin extensions can inherit from this to automatically get API suitable for buildgradlekts The extension must set factory field for T Example usage someExtension allTargets This is a lambda inside of a T scope Called once for each known target with their respective sanitizer targetsomeTarget This is a lambda inside of a T scope Called for someTarget without any sanitizer targetsomeTargetwithSanitizersomeSanitizer This is a lambda inside of a T scope Called for someTarget with someSanitizer hostTarget This is a lambda inside of a T scope Called for the host target without any sanitizer someExtensiontargetsomeTarget returns T if someTarget was configured Otherwise fails with UnknownDomainObjectException someExtensionallTargets returns a ProviderListT of all created configurations TODO Consider splitting out interface and the default implementation Plugins will inherit from the interface via delegation to the implementation TODO Consider implementing everything from NamedDomainObjectContainer but keyed on a target instead of a nameopen class TargetDomainObjectContainerT Any constructor private val providerFactory ProviderFactory private val platformManager PlatformManager constructorproject Project thisprojectproviders projectextensionsgetByTypePlatformManager How to create T Must be set before using the rest of API lateinit var factory TargetWithSanitizer T private val targets MutableMapTargetWithSanitizer T mutableMapOf Create or update configuration T for target and apply action to it param target target of the configuration param action action to apply to the configuration return resulting configuration ", "modifier": "", "signature": "fun target(target: TargetWithSanitizer, action: Action<in T>): T", "body": "{<EOL> val element = targets.getOrPut(target) { factory(target) }"}
{"docstring": " Get configuration T for target param target target of the configuration return resulting configuration throws UnknownDomainObjectException if configuration for target does not exist ", "modifier": "", "signature": "fun target(target: TargetWithSanitizer): T", "body": "{<EOL> return targets[target] ?: throw UnknownDomainObjectException(\"Configuration for $target does not exists\")<EOL> }"}
{"docstring": " Create or update configurations T for all known targets with their sanitizers and apply action to each of it param action action to apply to the configuration return list of configurations fun allTargetsaction Actionin T ListT platformManagerallTargetsWithSanitizersmap thistargetit action Get all created configurations T return Provider with list of all created configurations val allTargets ProviderListT providerFactoryprovider targetsvaluestoList Create or update configuration T for host targetHostManagerhost and apply action to it param action action to apply to the configuration return resulting configuration ", "modifier": "", "signature": "fun hostTarget(action: Action<in T>): T", "body": "{<EOL> return target(HostManager.host.withSanitizer(), action)<EOL> }"}
{"docstring": " Note we cant use this function instead of klibUniqName in cacheFile because the latter is OutputDirectory so Gradle can call it even before the task dependencies are finished and originalKlib might be not build yet ", "modifier": "private ", "signature": "fun readKlibUniqNameFromManifest(): String", "body": "{<EOL> val konanHome = compilerDistributionPath.get().absolutePath<EOL> val resolver = defaultResolver(<EOL> repositories = emptyList(),<EOL> directLibs = emptyList(),<EOL> target = PlatformManager(konanHome).targetByName(target),<EOL> distribution = Distribution(konanHome),<EOL> logger = object : Logger {<EOL> override fun log(message: String) = logger.info(message)<EOL> override fun warning(message: String) = logger.warn(message)<EOL> override fun error(message: String): Unit = logger.error(message)<EOL> override fun fatal(message: String): Nothing = kotlin.error(message)<EOL> }"}
{"docstring": " Modules description file See READMEmd for more details data class ModulesTxt val muted Boolean val file File val fileName String val modules ListModule val dependencies ListDependency override fun toString fileName data class Moduleval name String var index Int 1 val indexedName get indextoStringpadStart2 0_name Facet should not be created for old tests var kotlinFacetSettings KotlinFacetSettings null val dependencies mutableListOfDependency val usages mutableListOfDependency val isCommonModule get kotlinFacetSettingstargetPlatformisCommon kotlinFacetSettingskind SOURCE_SET_HOLDER val isJvmModule get kotlinFacetSettingstargetPlatformisJvm val expectedBy get dependenciesfilter itkind EXPECTED_BY itkind INCLUDE Flag var edit Boolean false Flag var editJvm Boolean false Flag var editExpectActual Boolean false lateinit var jpsModule JpsModule companion object val flags MapString KMutableProperty1Module Boolean ModuleclassmemberProperties filter itfindAnnotationFlag null filterIsInstanceKMutableProperty1Module Boolean associateBy itname annotation class Flag data class Dependency val from Module val to Module val scope JpsJavaDependencyScope val kind Kind val exported Boolean val effectivelyExported get kind EXPECTED_BY exported init fromdependenciesaddthis tousagesaddthis enum class Kind DEPENDENCY EXPECTED_BY INCLUDE class ModulesTxtBuilder var muted false val modules mutableMapOfString ModuleRef private val dependencies mutableListOfDependencyBuilder Reference to module which can be defined later class ModuleRefname String var defined Boolean false var actual ModulesTxtModule ModulesTxtModulename override fun toString actualname fun buildindex Int ModulesTxtModule val result actual resultindex index val kotlinFacetSettings resultkotlinFacetSettings if kotlinFacetSettings null kotlinFacetSettingsimplementedModuleNames resultdependenciesasSequence filter itkind EXPECTED_BY map ittoname toList kotlinFacetSettingssourceSetNames resultdependenciesasSequence filter itkind INCLUDE map ittoname toList return result Temporary object for resolving references to modules data class DependencyBuilder val from ModuleRef val to ModuleRef val scope JpsJavaDependencyScope val kind ModulesTxtDependencyKind val exported Boolean fun build ModulesTxtDependency when kind DEPENDENCY Unit EXPECTED_BY checktoactualisCommonModule this toactual is not common module INCLUDE checktoactualkotlinFacetSettingskind SOURCE_SET_HOLDER this toactual is not source set holder return ModulesTxtDependencyfromactual toactual scope kind exported fun readFilefile File fileTitle String filetoString ModulesTxt try fileforEachLine line parseDeclarationline dependencies need to be build first modulebuild requires it val dependencies dependenciesmap itbuild val modules modulesvaluesmapIndexed index moduleRef moduleRefbuildindex return ModulesTxtmuted file fileTitle modules dependencies catch t Throwable throw ErrorError while reading file tmessage t private fun parseDeclarationline String doParseDeclarationremoveCommentsline private fun removeCommentsline String linesplit limit 20trim private fun doParseDeclarationline String when lineisEmpty Unit skip empty lines line MUTED muted true linecontains val from rest linesplit limit 2 if restisBlank name module newModuleValueWithFlagsfrom else val to flags parseValueWithFlagsresttrim newDependencyfromtrim totrim flags from to flag1 flag2 dependency else newModuleparseValueWithFlagsline name flag1 flag2 module value flag1 flag2 ", "modifier": "private ", "signature": "fun parseValueWithFlags(str: String): ValueWithFlags", "body": "{<EOL> val parts = str.split(\"[\", limit = 2)<EOL> return if (parts.size > 1) {<EOL> val (value, flags) = parts<EOL> ValueWithFlags(<EOL> value = value.trim(),<EOL> flags = flags.trim()<EOL> .removeSuffix(\"]\")<EOL> .split(\",\")<EOL> .map { it.trim() }"}
{"docstring": " Properties and actions for Kotlin test production module build target abstract class KotlinModuleBuildTargetBuildMetaInfoType BuildMetaInfo internal constructor val kotlinContext KotlinCompileContext val jpsModuleBuildTarget ModuleBuildTarget Note beware of using this context for getting compilation round dependent data for example groovy can provide temp source roots with stubs and it will be visible only in round local compile context TODO1280 got rid of jpsGlobalContext and replace it with kotlinContext val jpsGlobalContext CompileContext get kotlinContextjpsContext Initialized in KotlinCompileContextloadTargets lateinit var chunk KotlinChunk abstract val globalLookupCacheId String abstract val isIncrementalCompilationEnabled Boolean open fun isEnabledchunkCompilerArguments LazyCommonCompilerArguments Boolean true SuppressLeakingThis val localCacheVersionManager localCacheVersionManager kotlinContextdataPathsgetTargetDataRootjpsModuleBuildTargettoPath isIncrementalCompilationEnabled val initialLocalCacheAttributesDiff CacheAttributesDiff localCacheVersionManagerloadDiff val module JpsModule get jpsModuleBuildTargetmodule val isTests Boolean get jpsModuleBuildTargetisTests open val targetId TargetId get Since IDEA 2016 each gradle source root is imported as a separate module One gradle module X is imported as two JPS modules 1 Xproduction with one production target 2 Xtest with one test target This breaks kotlin code since internal members names are mangled using module name For example a declaration of a function f in Xproduction becomes fXProduction but a call f in Xtest becomes fXTest The workaround is to replace a name of such test target with the name of corresponding production module See KT11993 val name relatedProductionModulename jpsModuleBuildTargetid return TargetIdname jpsModuleBuildTargettargetTypetypeId val outputDir by lazy val explicitOutputPath if isTests moduletestOutputFilePath else moduleproductionOutputFilePath val explicitOutputDir explicitOutputPathlet FileitabsoluteFileparentFile returnlazy explicitOutputDir jpsModuleBuildTargetoutputDir throw ProjectBuildExceptionKotlinJpsBundlemessageerrormessagenooutputdirectoryfoundfor0 this val friendBuildTargets ListKotlinModuleBuildTarget get val result mutableListOfKotlinModuleBuildTarget if isTests resultaddIfNotNullkotlinContexttargetsBindingmoduleproductionBuildTarget resultaddIfNotNullkotlinContexttargetsBindingrelatedProductionModuleproductionBuildTarget return resultfilter itsourcesisNotEmpty val friendOutputDirs ListFile get friendBuildTargetsmapNotNull JpsJavaExtensionServicegetInstancegetOutputDirectoryitmodule false private val relatedProductionModule JpsModule get JpsJavaExtensionServicegetInstancegetTestModulePropertiesmoduleproductionModule data class Dependency val src KotlinModuleBuildTarget val target KotlinModuleBuildTarget val exported Boolean TODO1280 try replace allDependencies with KotlinChunkcollectDependentChunksRecursivelyExportedOnly val allDependencies by lazy JpsJavaExtensionServicedependenciesmodulerecursivelyexportedOnly includedInJpsJavaClasspathKindcompileisTests All sources of this target including non dirty Lazy initialization is required since value is required only in rare cases Before first round initialized lazily based on global context This is required for friend build targets when friends are not compiled in this build run Lazy value will be invalidated on each round should be recalculated based on round local context Update required since source roots can be changed for example groovy can provide new temporary source roots with stubs Ugly delegation to lazy is used to capture local compile context and reset calculated value val sources MapFile Source get _sourcesvalue Volatile private var _sources LazyMapFile Source lazy computeSourcesListjpsGlobalContext fun nextRoundlocalContext CompileContext _sources lazy computeSourcesListlocalContext private fun computeSourcesListlocalContext CompileContext MapFile Source val result mutableMapOfFile Source val moduleExcludes moduleexcludeRootsListurlsmapTojavautilHashSet JpsPathUtilurlToFile val compilerExcludes JpsJavaExtensionServicegetInstance getCompilerConfigurationmoduleproject compilerExcludes val buildRootIndex localContextprojectDescriptorbuildRootIndex val roots buildRootIndexgetTargetRootsjpsModuleBuildTarget localContext rootsforEach rootDescriptor val isCrossCompiled rootDescriptor is KotlinIncludedModuleSourceRoot rootDescriptorrootwalkTopDown onEnter file file in moduleExcludes forEach file if compilerExcludesisExcludedfile fileisFile fileisKotlinSourceFile resultfile Sourcefile isCrossCompiled return result property isCrossCompiled sources that are crosscompiled to multiple targets class Source val file File val isCrossCompiled Boolean fun isFromIncludedSourceRootfile File Boolean sourcesfileisCrossCompiled true val sourceFiles CollectionFile get sourceskeys override fun toString jpsModuleBuildTargettoString Called for ModuleChunkrepresentativeTarget abstract fun compileModuleChunk commonArguments CommonCompilerArguments dirtyFilesHolder KotlinDirtySourceFilesHolder environment JpsCompilerEnvironment buildMetricReporter JpsBuilderMetricReporter Boolean open fun registerOutputItemsoutputConsumer ModuleLevelBuilderOutputConsumer outputItems ListGeneratedFile for output in outputItems outputConsumerregisterOutputFilejpsModuleBuildTarget outputoutputFile outputsourceFilesmap itpath protected fun reportAndSkipCircularenvironment JpsCompilerEnvironment Boolean if chunktargetssize 1 We do not support circular dependencies but if they are present we do our best should not break the build so we simply yield a warning and report NOTHING_DONE environmentmessageCollectorreport CompilerMessageSeveritySTRONG_WARNING Circular dependencies are not supported The following modules depend on each other chunkpresentableShortName Kotlin is not compiled for these modules return true return false open fun doAfterBuild open val hasCaches Boolean true abstract fun createCacheStoragepaths BuildDataPaths JpsIncrementalCache Called for ModuleChunkrepresentativeTarget open fun updateChunkMappings localContext CompileContext chunk ModuleChunk dirtyFilesHolder KotlinDirtySourceFilesHolder outputItems MapModuleBuildTarget IterableGeneratedFile incrementalCaches MapKotlinModuleBuildTarget JpsIncrementalCache environment JpsCompilerEnvironment by default do nothing open fun updateCaches dirtyFilesHolder KotlinDirtySourceFilesHolder jpsIncrementalCache JpsIncrementalCache files ListGeneratedFile changesCollector ChangesCollector environment JpsCompilerEnvironment val changedAndRemovedFiles dirtyFilesHoldergetDirtyFilesjpsModuleBuildTargetkeys dirtyFilesHoldergetRemovedFilesjpsModuleBuildTarget val expectActualTracker environmentservicesExpectActualTrackerclassjava as ExpectActualTrackerImpl jpsIncrementalCacheupdateComplementaryFileschangedAndRemovedFiles expectActualTracker open fun makeServices builder ServicesBuilder incrementalCaches MapKotlinModuleBuildTarget JpsIncrementalCache lookupTracker LookupTracker exceptActualTracer ExpectActualTracker inlineConstTracker InlineConstTracker enumWhenTracker EnumWhenTracker importTracker ImportTracker withbuilder registerLookupTrackerclassjava lookupTracker registerExpectActualTrackerclassjava exceptActualTracer registerCompilationCanceledStatusclassjava object CompilationCanceledStatus override fun checkCanceled if jpsGlobalContextcancelStatusisCanceled throw CompilationCanceledException registerInlineConstTrackerclassjava inlineConstTracker registerEnumWhenTrackerclassjava enumWhenTracker registerImportTrackerclassjava importTracker Should be used only for particular target in chunk jvm Should not be cached since may be vary in different rounds protected fun collectSourcesToCompile dirtyFilesHolder KotlinDirtySourceFilesHolder SourcesToCompile sources when chunkrepresentativeTargetisIncrementalCompilationEnabled dirtyFilesHoldergetDirtyFilesjpsModuleBuildTargetvalues else sourcesvalues removedFiles dirtyFilesHoldergetRemovedFilesjpsModuleBuildTarget inner class SourcesToCompile sources CollectionSource val removedFiles CollectionFile val allFiles sourcesmap itfile val crossCompiledFiles sourcesfilter itisCrossCompiled map itfile return true if there are removed files or files to compile ", "modifier": "", "signature": "fun logFiles(): Boolean", "body": "{<EOL> val hasRemovedSources = removedFiles.isNotEmpty()<EOL> val hasDirtyOrRemovedSources = allFiles.isNotEmpty() || hasRemovedSources<EOL><EOL> if (hasDirtyOrRemovedSources) {<EOL> val logger = jpsGlobalContext.loggingManager.projectBuilderLogger<EOL> if (logger.isEnabled) {<EOL> logger.logCompiledFiles(allFiles, KotlinBuilder.KOTLIN_BUILDER_NAME, \"Compiling files:\")<EOL> }"}
{"docstring": " Ensure Kotlin Context initialized Kotlin Context should be initialized only when required before first kotlin chunk build ", "modifier": "private ", "signature": "fun ensureKotlinContextInitialized(context: CompileContext): KotlinCompileContext", "body": "{<EOL> val kotlinCompileContext = context.getUserData(kotlinCompileContextKey)<EOL> if (kotlinCompileContext != null) return kotlinCompileContext<EOL><EOL> // don't synchronize on context, since it is chunk local only<EOL> synchronized(kotlinCompileContextKey) {<EOL> val actualKotlinCompileContext = context.getUserData(kotlinCompileContextKey)<EOL> if (actualKotlinCompileContext != null) return actualKotlinCompileContext<EOL><EOL> try {<EOL> return initializeKotlinContext(context)<EOL> }"}
{"docstring": " see IdeaKotlinBinaryCapability since 1920 val capabilities SetIdeaKotlinBinaryCapability emptySet see IdeaKotlinBinaryAttributes since 1920 val attributes IdeaKotlinBinaryAttributes IdeaKotlinBinaryAttributes IdeaKotlinDependencyCoordinates constructor group String module String version String sourceSetName String null this group group module module version version sourceSetName sourceSetName capabilities emptySet String that can be used to identify the coordinates with the following contract All coordinates that are equal will have an equal identityString All coordinates that are not equal will have a non equal identityString This however shall not be shown to users as the String is hard to read The identityString is not stable across Kotlin versions hence not intended to be parsed val identityString String get buildString appendgroupmodule if sourceSetName null appendsourceSetName if version null appendversion if capabilitiesisNotEmpty appendcapabilitiesjoinToString if attributesisNotEmpty appendattributesattributeshashCode String intended to be shown to users Eg a library within the IDE can use this String to show the coordinates to a given user This will try to be as useful as possible implementing a notion of classifying capabilities Example testFixtures from Gradle Such testFixtures will be resolved with coordinates like kotlin IdeaKotlinBinaryCoordinates group orgjetbrains module sample version 100 capabilities setOf IdeaKotlinBinaryCapability group orgjetbrains name sampletestfixtures See the classifying testfixtures suffix version 100 Such coordinates will be displayed using their classifiers like orgjetbrainssampletestfixtures100 val displayString String get val classifyingCapabilities capabilitiesfilter capability capabilitygroup group capabilitynamestartsWithmodule return when classifyingCapabilitiessize 1 buildString appendclassifyingCapabilitiessingle if sourceSetName null appendsourceSetName classifyingCapabilitiessize 1 buildString appendgroupmodule appendclassifyingCapabilitiesjoinToStringprefix postfix separator capability capabilitynameremovePrefixmoduleremovePrefix if sourceSetName null appendsourceSetName if version null appendversion else buildString appendgroupmodule if sourceSetName null appendsourceSetName if version null appendversion override fun toString String displayString override fun equalsother Any Boolean if this other return true if other is IdeaKotlinBinaryCoordinates return false if group othergroup return false if module othermodule return false if version otherversion return false if sourceSetName othersourceSetName return false if capabilities othercapabilities return false if attributes otherattributes return false return true override fun hashCode Int var result grouphashCode result 31 result modulehashCode result 31 result versionhashCode 0 result 31 result sourceSetNamehashCode 0 result 31 result capabilitieshashCode result 31 result attributeshashCode return result Keep compatibility with 190 and lower ", "modifier": "", "signature": "fun copy(\n        group: String = this.group,\n        module: String = this.module,\n        version: String? = this.version,\n        sourceSetName: String? = this.sourceSetName,\n    ): IdeaKotlinBinaryCoordinates", "body": "{<EOL> return IdeaKotlinBinaryCoordinates(<EOL> group = group,<EOL> module = module,<EOL> version = version,<EOL> sourceSetName = sourceSetName,<EOL> capabilities = capabilities,<EOL> attributes = attributes,<EOL> )<EOL> }"}
{"docstring": " In order to keep javaioSerializable implementation backwards compatible capabilities was added in 1920 If a binary produced before 1920 gets deserialized then capabilities will be null In this case we use the copy function to provide an instance that will have an emptySet instead ", "modifier": "private ", "signature": "fun readResolve(): Any", "body": "{<EOL> @Suppress(\"SENSELESS_COMPARISON\", \"USELESS_ELVIS\")<EOL> if (capabilities == null || attributes == null) {<EOL> return copy(<EOL> capabilities = capabilities ?: emptySet(),<EOL> attributes = attributes ?: IdeaKotlinBinaryAttributes()<EOL> )<EOL> }"}
{"docstring": " Checks that all platform libs for konanTarget actually exist in the distribution ", "modifier": "private ", "signature": "fun checkLibrariesInDistribution(): Boolean", "body": "{<EOL> val presentPlatformLibs = platformLibsDirectory<EOL> .listFiles { file -> file.isDirectory }"}
{"docstring": " Check that caches for all platform libs for konanTarget actually exist in the cache directory ", "modifier": "private ", "signature": "fun checkCaches(): Boolean", "body": "{<EOL> if (!shouldBuildCaches) {<EOL> return true<EOL> }"}
{"docstring": " Search modules in node_modules according to httpsnodejsorgapimoduleshtml open class NpmProjectModules val dir File val packageJsonEntries CollectionString listOfmain module browser val indexFileNames CollectionString listOfINDEX_FILE_NAME val indexFileSuffixes CollectionString listOfJS_SUFFIX Serializable Require request nodejs module and return canonical path to its main js file ", "modifier": "", "signature": "fun require(request: String): String", "body": "{<EOL> return resolve(request)?.canonicalPath ?: error(\"Cannot find node module \\\"$request\\\" in \\\"$this\\\"\")<EOL> }"}
{"docstring": " Parses Gradle rich versionshttpsdocsgradleorgcurrentuserguidesingle_versionshtml version string In case of ranges version prefixes or latest status returned version will be closest using IntMAX_VALUE as highest possible version number for major minor or patch ", "modifier": "", "signature": "fun fromGradleRichVersion(version: String): SemVer", "body": "{<EOL> return when {<EOL> version == \"+\" || version.startsWith(\"latest.\") -><EOL> SemVer(Int.MAX_VALUE.toBigInteger(), Int.MAX_VALUE.toBigInteger(), Int.MAX_VALUE.toBigInteger())<EOL> version.matches(MAJOR_PREFIX_VERSION) -><EOL> from(\"${version.replaceFirst(\"+\", Int.MAX_VALUE.toString())}"}
{"docstring": " Basic info for NpmProject created from compilation This class contains only basic info More info can be obtained from KotlinCompilationNpmResolution which is available after project resolution after KotlinNpmInstallTask execution open class NpmProjectTransient val compilation KotlinJsIrCompilation Serializable val compilationName compilationdisambiguatedName private val extension ProviderString compilationfileExtension val name String by lazy buildNpmProjectName delegateTransient val nodeJs by lazy projectrootProjectkotlinNodeJsExtension val dir ProviderDirectory nodeJsprojectPackagesDirectorymap itdirname val target KotlinJsTargetDsl get compilationtarget as KotlinJsTargetDsl val project Project get targetproject val nodeModulesDir get dirmap itdirNODE_MODULES val packageJsonFile ProviderRegularFile get dirmap itfilePACKAGE_JSON val packageJsonTaskName String get compilationdisambiguateNamepackageJson val packageJsonTask KotlinPackageJsonTask get projecttasksgetByNamepackageJsonTaskName as KotlinPackageJsonTask val packageJsonTaskPath String get packageJsonTaskpath val dist ProviderDirectory get dirmap itdirDIST_FOLDER val main ProviderString extensionmap DIST_FOLDERnameit val publicPackageJsonTaskName String get compilationdisambiguateNamePublicPackageJsonTaskNAME internal val modules by lazy NpmProjectModulesdirgetFile private val nodeExecutable by lazy nodeJsrequireConfiguredexecutable fun useTool exec ExecSpec tool String nodeArgs ListString listOf args ListString execworkingDirdir execexecutablenodeExecutable execargs nodeArgs requiretool args Require request nodejs module and return canonical path to its main js file ", "modifier": "", "signature": "fun require(request: String): String", "body": "{<EOL>// nodeJs.npmResolutionManager.requireAlreadyInstalled(project)<EOL> return modules.require(request)<EOL> }"}
{"docstring": " Names of the Android library variants that should be published from the targets project within the default publications which are set up if the mavenpublish Gradle plugin is applied Item examples release in case no product flavors were defined fooRelease for the release build type of a flavor foo fooBarRelease for the release build type multidimensional flavors foo and bar If set to null which can also be done with publishAllLibraryVariants all library variants will be published but not test or application variants var publishLibraryVariants ListString listOf Workaround for Groovy GString items in a list setvalue field valuemapAnytoString Add Android library variant names to publishLibraryVariants fun publishLibraryVariantsvararg names String publishLibraryVariants publishLibraryVariantsorEmpty names Set up all of the Android library variants to be published from this targets project within the default publications which are set up if the mavenpublish Gradle plugin is applied This overrides the variants chosen with publishLibraryVariants fun publishAllLibraryVariants publishLibraryVariants null If true a publication will be created per merged product flavor with the build types used as classifiers for the artifacts published within each publication If set to false each Android variant will have a separate publication var publishLibraryVariantsGroupedByFlavor false private fun checkPublishLibraryVariantsExist fun AndroidProjectHandlergetLibraryVariantNames mutableSetOfStringapply projectforAllAndroidVariants if getLibraryOutputTaskit null addgetVariantNameit val variantNames KotlinAndroidPluginandroidTargetHandlergetLibraryVariantNames val missingVariants publishLibraryVariantsminusvariantNamesorEmpty if missingVariantsisNotEmpty throw InvalidUserDataException Kotlin target targetName tried to set up publishing for Android build variants that are not library variants or do not existn missingVariantsjoinToStringn it nCheck the publishLibraryVariants property it should point to existing Android library variants Publishing of application and test variants is not supported override val kotlinComponents by lazy checkPublishLibraryVariantsExist KotlinAndroidPluginandroidTargetHandlerdoCreateComponents private fun isVariantPublished SuppressTYPEALIAS_EXPANSION_DEPRECATION variant DeprecatedAndroidBaseVariant Boolean publishLibraryVariantscontainsgetVariantNamevariant true private fun AndroidProjectHandlerdoCreateComponents SetKotlinTargetComponent assertprojectstateexecuted Android doCreateComponents requires afterEvaluate based project state SuppressTYPEALIAS_EXPANSION_DEPRECATION val publishableVariants mutableListOfDeprecatedAndroidBaseVariant apply projectforAllAndroidVariants addit toList Defensive copy against unlikely modification by the lambda that captures the list above in forEachVariant filter getLibraryOutputTaskit null val publishableVariantGroups publishableVariantsgroupBy variant val flavorNames getFlavorNamesvariant if publishLibraryVariantsGroupedByFlavor For each flavor we group its variants which differ only in the build type in a single component in order to publish all of the build types of the flavor as a single module with the build type as the classifier of the artifacts flavorNames else flavorNames getBuildTypeNamevariant return publishableVariantGroupsmap flavorGroupNameParts androidVariants val nestedVariants androidVariantsmapTomutableSetOf androidVariant val androidVariantName getVariantNameandroidVariant val compilation compilationsgetByNameandroidVariantName val usageContexts createAndroidUsageContexts variant androidVariant compilation compilation isSingleBuildType publishableVariantsfilterisVariantPublishedmapgetBuildTypeNamedistinctsize 1 createKotlinVariant lowerCamelCaseNamecompilationtargetname flavorGroupNamePartstoTypedArray compilation usageContexts apply publishable isVariantPublishedandroidVariant if publishLibraryVariantsGroupedByFlavor defaultArtifactIdSuffix dashSeparatedName getFlavorNamesandroidVariant getBuildTypeNameandroidVarianttakeIf it release map ittoLowerCaseAsciiOnly takeIf itisNotEmpty if publishLibraryVariantsGroupedByFlavor JointAndroidKotlinTargetComponent target thisKotlinAndroidTarget nestedVariants nestedVariants flavorNames flavorGroupNameParts else nestedVariantssingle toSet private fun AndroidProjectHandlercreateAndroidUsageContexts SuppressTYPEALIAS_EXPANSION_DEPRECATION variant DeprecatedAndroidBaseVariant compilation KotlinCompilation isSingleBuildType Boolean SetDefaultKotlinUsageContext val flavorNames getFlavorNamesvariant val buildTypeName getBuildTypeNamevariant val artifactClassifier buildTypeNametakeIf it release publishLibraryVariantsGroupedByFlavor val variantName getVariantNamevariant val outputTaskOrProvider getLibraryOutputTaskvariant return emptySet val artifact run val archivesConfigurationName lowerCamelCaseNametargetName variantName archives projectconfigurationsmaybeCreateDependencyScopearchivesConfigurationName projectartifactsaddarchivesConfigurationName outputTaskOrProvider artifact artifactclassifier artifactClassifier val apiElementsConfigurationName lowerCamelCaseNamevariantName apiElements val runtimeElementsConfigurationName lowerCamelCaseNamevariantName runtimeElements val sourcesElementsConfigurationName lowerCamelCaseNamevariantName sourcesElements val sourcesElementsConfiguration createSourcesElementsIfNeeded variantName apiElementsConfigurationName sourcesElementsConfigurationName fun AttributeContainerfilterOutAndroidVariantAttributes AttributeContainer HierarchyAttributeContainerthis val valueString run val value getAttributeit value as Namedname valuetoString filterOutAndroidVariantAttributeit filterOutAndroidBuildTypeAttributeit valueString isSingleBuildType filterOutAndroidAgpVersionAttributeit val sourcesUsageContext createSourcesJarAndUsageContextIfPublishable producingCompilation compilation componentName compilationdisambiguateName artifactNameAppendix dashSeparatedName compilationtargetnametoLowerCaseAsciiOnly flavorNamesmap ittoLowerCaseAsciiOnly toTypedArray buildTypeNametakeIf it release toLowerCaseAsciiOnly classifierPrefix artifactClassifier sourcesElementsConfigurationName sourcesElementsConfigurationName overrideConfigurationAttributes sourcesElementsConfigurationattributesfilterOutAndroidVariantAttributes val usageContexts listOf apiElementsConfigurationName to KotlinUsageContextMavenScopeCOMPILE runtimeElementsConfigurationName to KotlinUsageContextMavenScopeRUNTIME mapTomutableSetOf dependencyConfigurationName mavenScope val configuration projectconfigurationsgetByNamedependencyConfigurationName DefaultKotlinUsageContext compilation mavenScope dependencyConfigurationName overrideConfigurationArtifacts projectsetProperty listOfartifact overrideConfigurationAttributes configurationattributesfilterOutAndroidVariantAttributes usageContextsaddIfNotNullsourcesUsageContext return usageContexts TODO Ask Google about providing such configuration where they could set their attributes and control them Just like as they do with apiElements or runtimeElements ", "modifier": "private ", "signature": "fun createSourcesElementsIfNeeded(\n        variantName: String,\n        apiElementsConfigurationName: String,\n        sourcesElementsConfigurationName: String,\n    ): Configuration", "body": "{<EOL> val existingConfiguration = project.configurations.findByName(sourcesElementsConfigurationName)<EOL> if (existingConfiguration != null) return existingConfiguration<EOL><EOL> val apiElementsConfiguration = project.configurations.findConsumable(apiElementsConfigurationName)<EOL> ?: error(\"Configuration $apiElementsConfigurationName was not found\")<EOL> return project.configurations.createConsumable(sourcesElementsConfigurationName).apply {<EOL> description = \"Source files of Android ${variantName}"}
{"docstring": " return default location of source folders for a kotlin source set eg srcjvmMainkotlin sourceSetNamejvmMain typekotlin ", "modifier": "", "signature": "fun defaultSourceFolder(project: Project, sourceSetName: String, type: String): File", "body": "{<EOL> return project.file(\"src/$sourceSetName/$type\")<EOL> }"}
{"docstring": " The root publication that references the platform specific publications as its variants ", "modifier": "private ", "signature": "fun createRootPublication(project: Project, publishing: PublishingExtension): MavenPublication", "body": "{<EOL> val kotlinSoftwareComponent = project.multiplatformExtension.rootSoftwareComponent<EOL><EOL> return publishing.publications.create(\"kotlinMultiplatform\", MavenPublication::class.java).apply {<EOL> from(kotlinSoftwareComponent)<EOL> (this as MavenPublicationInternal).publishWithOriginalFileName()<EOL><EOL> addKotlinToolingMetadataArtifactIfNeeded(project)<EOL> }"}
{"docstring": " Names of source sets that the consumer sees from the requested dependency val visibleSourceSetNames SetString For some of the visibleSourceSetNames additional artifacts may be present that the consumer should read the compiled source set metadata from val hostSpecificMetadataArtifactBySourceSet MapString Fileprivate val ProjectallPlatformCompilationData ListPlatformCompilationData by projectStoredProperty collectAllPlatformCompilationDataprivate fun ProjectcollectAllPlatformCompilationData ListPlatformCompilationData val multiplatformExtension multiplatformExtensionOrNull return emptyList return multiplatformExtension targets filter itplatformType KotlinPlatformTypecommon flatMap target targetcompilationsmap ittoPlatformCompilationData private fun KotlinCompilationtoPlatformCompilationData PlatformCompilationData allSourceSets allKotlinSourceSetsmap itname toSet resolvedDependenciesConfiguration LazyResolvedConfigurationinternalconfigurationscompileDependencyConfiguration hostSpecificMetadataConfiguration internal configurations hostSpecificMetadataConfiguration letLazyResolvedConfigurationinternal class SourceSetVisibilityProvider private val platformCompilations ListPlatformCompilationData constructorproject Project this platformCompilations projectallPlatformCompilationData class PlatformCompilationData val allSourceSets SetKotlinSourceSetName val resolvedDependenciesConfiguration LazyResolvedConfiguration val hostSpecificMetadataConfiguration LazyResolvedConfiguration Determine which source sets of the resolvedRootMppDependency are visible in the visibleFromSourceSet source set This requires resolving dependencies of the compilations which visibleFromSourceSet takes part in in order to find which variants the resolvedRootMppDependency got resolved to for those compilations Once the variants are known they are checked against the dependencyProjectStructureMetadata and the source sets of the dependency are determined that are compiled for all those variants and thus should be visible here If the resolvedRootMppDependency is a project dependency its project should be passed as resolvedToOtherProject as the Gradle API for dependency variants behaves differently for project dependencies and published ones ", "modifier": "", "signature": "fun getVisibleSourceSets(\n        visibleFromSourceSet: KotlinSourceSetName,\n        resolvedRootMppDependency: ResolvedDependencyResult,\n        dependencyProjectStructureMetadata: KotlinProjectStructureMetadata,\n        resolvedToOtherProject: Boolean,\n    ): SourceSetVisibilityResult", "body": "{<EOL> val resolvedRootMppDependencyId = resolvedRootMppDependency.selected.id<EOL><EOL> val platformCompilationsByResolvedVariantName = mutableMapOf<String, PlatformCompilationData>()<EOL><EOL> val visiblePlatformVariantNames: List<Set<String>> = platformCompilations<EOL> .filter { visibleFromSourceSet in it.allSourceSets }"}
{"docstring": " Example orgjetbrainssamplesampleLibrary100SNAPSHOTappleAndLinuxMainVk5pxQklib override val relativeFile File FilebuildString appendcontainingSourceSetContentcontainingArtifactContentcontainingArtifactmoduleDependencyIdentifier append appendcontainingSourceSetContentcontainingArtifactContentcontainingArtifactmoduleDependencyVersion append appendcontainingSourceSetContentsourceSetName append appendthisMetadataBinaryImplchecksum append appendarchiveExtension override fun copyTofile File Boolean requirefileextension archiveExtension Expected fileextension archiveExtension Found fileextension val libraryPath containingSourceSetContentsourceSetName if artifactFilecontainsKlibDirectorylibraryPath return false fileparentFilemkdirs artifactFilezipcopyPartiallyfile libraryPath return true private inner class CInteropMetadataBinaryImpl override val containingSourceSetContent CompositeMetadataArtifactContentSourceSetContent override val cinteropLibraryName String private val artifactFile ArtifactFile CompositeMetadataArtifactContentCInteropMetadataBinary override val archiveExtension String get SourceSetMetadataLayoutKLIBarchiveExtension override val checksum String get artifactFilechecksum Example orgjetbrainssamplesampleLibrary100SNAPSHOTappleAndLinuxMaincinterop orgjetbrainssample_sampleLibrarycinteropsimpleVk5pxQklib override val relativeFile File FilebuildString appendcontainingSourceSetContentcontainingArtifactContentcontainingArtifactmoduleDependencyIdentifier append appendcontainingSourceSetContentcontainingArtifactContentcontainingArtifactmoduleDependencyVersion append appendcontainingSourceSetContentsourceSetName appendcinterop resolvecinteropLibraryNamethischecksumarchiveExtension override fun copyTofile File Boolean requirefileextension archiveExtension Expected fileextension SourceSetMetadataLayoutKLIBarchiveExtension Found fileextension val sourceSetName containingSourceSetContentsourceSetName val cinteropMetadataDirectory kotlinProjectStructureMetadatasourceSetCInteropMetadataDirectorysourceSetName errorMissing CInteropMetadataDirectory for SourceSet sourceSetName val cinteropMetadataDirectoryPath ensureValidZipDirectoryPathcinteropMetadataDirectory val libraryPath cinteropMetadataDirectoryPathcinteropLibraryName if artifactFilecontainsKlibDirectorylibraryPath return false fileparentFilemkdirs artifactFilezipcopyPartiallyfile cinteropMetadataDirectoryPathcinteropLibraryName return true Interface to the underlying zipfile that only opens the file lazily and keeps references to all entries and infers all potential directory paths see directoryPaths and containsKlibDirectory private class ArtifactFileprivate val file File Closeable private var isClosed false private val lazyZip lazy ensureNotClosed ZipFilefile val zip ZipFile get lazyZipvalue val entries ListZipEntry by lazy zipentriestoList val checksum String by lazyLazyThreadSafetyModeNONE val crc32 CRC32 entriesforEach entry crc32updateentrycrctoInt checksumStringcrc32valuetoInt Check if the underlying zip file contains klib at path Note This check also works for zip files that did not include any klibs This will return true if any other zipentry is placed inside this directory path ", "modifier": "", "signature": "fun containsKlibDirectory(path: String): Boolean", "body": "{<EOL> // Checking for manifest file in \"default\" folder is considered \"good enough\" to say that it is a KLIB<EOL> // There are three possible states of content in the subdirectory of Composite Metadata Artifact<EOL> // 1. Klib<EOL> // 2. resources or mix klib + resources (FIXME: KT-66563)<EOL> // 3. empty directory. In case if something went wrong with publication. Like Task was skipped for some reason.<EOL> val pathToTheManifestFile = ensureValidZipDirectoryPath(path) + \"default/manifest\"<EOL> return zip.getEntry(pathToTheManifestFile) != null<EOL> }"}
{"docstring": " Evaluate and store the value as the dependency will be lost during Gradle instant execution val originalArtifactFiles ListFile dependencydependentsflatMap itallModuleArtifacts map itfile override fun toString String val verb when this is KeepOriginalDependency keep is Exclude exclude is ChooseVisibleSourceSets choose return verb dependency dependency class KeepOriginalDependency dependency ResolvedComponentResult MetadataDependencyResolutiondependency sealed class Exclude dependency ResolvedComponentResult MetadataDependencyResolutiondependency class Unrequested dependency ResolvedComponentResult Excludedependency Resolution for metadata dependencies of leaf platform source sets They are excluded since platform source sets should receive platform dependencies from corresponding compilations and should not get metadata ones See KT52216 class PublishedPlatformSourceSetDependency dependency ResolvedComponentResult val visibleTransitiveDependencies SetResolvedDependencyResult Excludedependency class ChooseVisibleSourceSets internal constructor dependency ResolvedComponentResult val projectStructureMetadata KotlinProjectStructureMetadata val allVisibleSourceSetNames SetString val visibleSourceSetNamesExcludingDependsOn SetString val visibleTransitiveDependencies SetResolvedDependencyResult internal val metadataProvider MetadataProvider MetadataDependencyResolutiondependency internal sealed class MetadataProvider class ArtifactMetadataProviderprivate val compositeMetadataArtifact CompositeMetadataArtifact MetadataProvider CompositeMetadataArtifact by compositeMetadataArtifact abstract class ProjectMetadataProvider MetadataProvider enum class MetadataConsumer Ide Cli abstract fun getSourceSetCompiledMetadatasourceSetName String FileCollection override fun toString String supertoString sourceSets allVisibleSourceSetNamesjoinToString if it in visibleSourceSetNamesExcludingDependsOn else it internal class GranularMetadataTransformation val params Params val parentSourceSetVisibilityProvider ParentSourceSetVisibilityProvider private val logger LogginggetLoggerGranularMetadataTransformationparamssourceSetName class Params val build CurrentBuildIdentifier val sourceSetName String val resolvedMetadataConfiguration LazyResolvedConfiguration val sourceSetVisibilityProvider SourceSetVisibilityProvider val projectStructureMetadataExtractorFactory MppDependencyProjectStructureMetadataExtractorFactory val projectData MapString ProjectData val platformCompilationSourceSets SetString constructorproject Project kotlinSourceSet KotlinSourceSet this build projectcurrentBuild sourceSetName kotlinSourceSetname resolvedMetadataConfiguration LazyResolvedConfigurationkotlinSourceSetinternalresolvableMetadataConfiguration sourceSetVisibilityProvider SourceSetVisibilityProviderproject projectStructureMetadataExtractorFactory projectkotlinMppDependencyProjectStructureMetadataExtractorFactory projectData projectallProjectsData platformCompilationSourceSets projectmultiplatformExtensionplatformCompilationSourceSets class ProjectData val path String val sourceSetMetadataOutputs LenientFutureMapString SourceSetMetadataOutputs val moduleId LenientFutureModuleDependencyIdentifier override fun toString String ProjectDatapathpath val metadataDependencyResolutions IterableMetadataDependencyResolution by lazy doTransform val visibleSourceSetsByComponentId MapComponentIdentifier SetString by lazy metadataDependencyResolutions filterIsInstanceMetadataDependencyResolutionChooseVisibleSourceSets groupBy itdependencyid mapValues _ visibleSourceSets visibleSourceSetsflatMap itallVisibleSourceSetNames toSet private fun doTransform IterableMetadataDependencyResolution val result mutableListOfMetadataDependencyResolution val resolvedDependencyQueue QueueResolvedDependencyResult ArrayDequeResolvedDependencyResultapply addAll paramsresolvedMetadataConfiguration root dependencies filter itisConstraint filterIsInstanceResolvedDependencyResult val visitedDependencies mutableSetOfComponentIdentifier while resolvedDependencyQueueisNotEmpty val resolvedDependency ResolvedDependencyResult resolvedDependencyQueuepoll val selectedComponent resolvedDependencyselected val componentId selectedComponentid if visitedDependenciesaddcomponentId Already processed this dependency continue loggerdebugTransform dependency resolvedDependency val dependencyResult processDependency resolvedDependency parentSourceSetVisibilityProvidergetSourceSetsVisibleInParentscomponentId loggerdebugTransformation result of dependency resolvedDependency dependencyResult resultadddependencyResult val transitiveDependenciesToVisit when dependencyResult is MetadataDependencyResolutionKeepOriginalDependency selectedComponentdependenciesfilterIsInstanceResolvedDependencyResult is MetadataDependencyResolutionChooseVisibleSourceSets dependencyResultvisibleTransitiveDependencies is MetadataDependencyResolutionExcludePublishedPlatformSourceSetDependency dependencyResultvisibleTransitiveDependencies is MetadataDependencyResolutionExcludeUnrequested errora visited dependency is erroneously considered unrequested resolvedDependencyQueueaddAll transitiveDependenciesToVisit filter itselectedid in visitedDependencies filter itisConstraint paramsresolvedMetadataConfigurationallResolvedDependenciesforEach resolvedDependency if resolvedDependencyselectedid in visitedDependencies resultadd MetadataDependencyResolutionExcludeUnrequested resolvedDependencyselected return result If the module is an MPP metadata module we extract KotlinProjectStructureMetadata and do the following get the KotlinProjectStructureMetadata from the dependency either deserialize from the artifact or build from the project determine the set S of source sets that should be seen in the kotlinSourceSet by finding which variants the parent dependency got resolved for the compilations where kotlinSourceSet participates transform the single Kotlin metadata artifact into a set of Kotlin metadata artifacts for the particular source sets in S and add the results as MetadataDependencyResolutionChooseVisibleSourceSets based on the project structure metadata determine which of the modules dependencies are requested by the source sets in S then consider only these transitive dependencies ignore the others ", "modifier": "private ", "signature": "fun processDependency(\n        dependency: ResolvedDependencyResult,\n        sourceSetsVisibleInParents: Set<String>,\n    ): MetadataDependencyResolution", "body": "{<EOL> val module = dependency.selected<EOL> val moduleId = module.id<EOL><EOL> val compositeMetadataArtifact = params<EOL> .resolvedMetadataConfiguration<EOL> .getArtifacts(dependency)<EOL> .singleOrNull()<EOL> // Make sure that resolved metadata artifact is actually Multiplatform one<EOL> ?.takeIf { it.variant.attributes.containsMultiplatformAttributes }"}
{"docstring": " Called when first test in suite started ", "modifier": "private ", "signature": "fun createReportingNode(): TestDescriptorInternal", "body": "{<EOL> val parents = collectParents()<EOL> val fullName = parents.reversed()<EOL> .map { it.cleanName }"}
{"docstring": " Transform to create a snapshot of a classpath entry directory or jar CacheableTransformabstract class BuildToolsApiClasspathEntrySnapshotTransform TransformActionBuildToolsApiClasspathEntrySnapshotTransformParameters TransformActionUsingKotlinToolingDiagnosticsBuildToolsApiClasspathEntrySnapshotTransformParameters abstract class Parameters TransformParameters TransformActionUsingKotlinToolingDiagnosticsParameters getInternal abstract val gradleUserHomeDir DirectoryProperty getInternal internal abstract val classLoadersCachingService PropertyClassLoadersCachingBuildService getClasspath internal abstract val classpath ConfigurableFileCollection getInput internal abstract val compilationViaBuildToolsApi PropertyBoolean getInternal internal abstract val buildToolsImplVersion PropertyString getInternal internal abstract val kgpVersion PropertyString getInternal internal abstract val suppressVersionInconsistencyChecks PropertyBoolean getClasspath getInputArtifact abstract val inputArtifact ProviderFileSystemLocation private fun checkVersionConsistency if parameterssuppressVersionInconsistencyChecksget return val kgpVersion parameterskgpVersionget val buildToolsImplVersion parametersbuildToolsImplVersionorNull takeIf it null workaround for incorrect nullability of map if kgpVersion buildToolsImplVersion reportDiagnosticKotlinToolingDiagnosticsBuildToolsApiVersionInconsistencykgpVersion buildToolsImplVersion override fun transformoutputs TransformOutputs if parameterscompilationViaBuildToolsApiget checkVersionConsistency val classpathEntryInputDirOrJar inputArtifactgetasFile if classpathEntryInputDirOrJarexists reportDiagnosticKotlinToolingDiagnosticsDependencyDoesNotPhysicallyExistclasspathEntryInputDirOrJar return val snapshotOutputFile outputsfileclasspathEntryInputDirOrJarnamereplace _ snapshotbin val granularity getClassSnapshotGranularityclasspathEntryInputDirOrJar parametersgradleUserHomeDirgetasFile val classLoader parametersclassLoadersCachingServiceget getClassLoaderparametersclasspathtoList SharedApiClassesClassLoaderProvider val compilationService CompilationServiceloadImplementationclassLoader val snapshot compilationServicecalculateClasspathSnapshotclasspathEntryInputDirOrJar granularity snapshotsaveSnapshotsnapshotOutputFile Determines the ClassSnapshotGranularity when taking a snapshot of the given classpathEntryDirOrJar As mentioned in ClassSnapshotGranularitys kdoc we will take CLASS_LEVEL snapshots for classes that are infrequently changed eg external libraries which are typically storedtransformed inside the Gradle user home or a few hardcoded cases and take CLASS_MEMBER_LEVEL snapshots for the others ", "modifier": "private ", "signature": "fun getClassSnapshotGranularity(classpathEntryDirOrJar: File, gradleUserHomeDir: File): ClassSnapshotGranularity", "body": "{<EOL> return if (<EOL> classpathEntryDirOrJar.startsWith(gradleUserHomeDir) ||<EOL> classpathEntryDirOrJar.name == \"android.jar\"<EOL> ) CLASS_LEVEL<EOL> else CLASS_MEMBER_LEVEL<EOL> }"}
{"docstring": " Compare this snapshot with the specified one only for the specified files ", "modifier": "", "signature": "fun diff(previousSnapshot: ClasspathSnapshot, changedFiles: Set<File>): KaptClasspathChanges", "body": "{<EOL> if (!isCompatible(previousSnapshot)) {<EOL> return KaptClasspathChanges.Unknown<EOL> }"}
{"docstring": " LRU cache for ClassLoaders by class path class ClassLoadersCache size Int private val parentClassLoader ClassLoader ClassLoadergetSystemClassLoader ttl Duration DurationofHours1 AutoCloseable private val logger LoggerFactorygetLoggerClassLoadersCacheclassjava private val cache ConcurrentMapCacheKey URLClassLoader CacheBuilder newBuilder maximumSizesizetoLong expireAfterAccessttl removalListenerCacheKey URLClassLoader key cl checkkey null cl null loggerinfoRemoving classloader from cache keyentriesmap itpath clclose buildCacheKey URLClassLoader asMap fun getForClassPathfiles ListFile ClassLoader getForClassPathfiles parentClassLoader private fun getForClassPathfiles ListFile parent ClassLoader ClassLoader val key makeKeyfiles return cachegetOrPutkey makeClassLoaderkey parent Gets or creates ClassLoader from bottom top files When creating new ClassLoader it tries to get top from cache first and then create new ClassLoader from bottom files providing top ClassLoader as parent Useful when you have internal and external artifacts and internal ones can be references from other internal artefacts only So you can safely cache ClassLoader from external artifacts and use it for internal ones ", "modifier": "", "signature": "fun getForSplitPaths(bottom: List<File>, top: List<File>): ClassLoader", "body": "{<EOL> return if (bottom.isEmpty() || top.isEmpty()) {<EOL> getForClassPath(bottom + top)<EOL> }"}
{"docstring": " Checks if the file is a MachO dynamic shared library or a MachO fat binary containing a number of dynamic libraries ", "modifier": "", "signature": "fun isDylib(file: File, logger: Logger): Boolean", "body": "{<EOL> try {<EOL> RandomAccessFile(file, \"r\").use { raf -><EOL> val magic = raf.readInt().fromUIntToLong()<EOL><EOL> val fileTypeOffset = when (magic) {<EOL> // all supported platforms are little-endian and JVM is big-endian, so we don't check MH_MAGIC[_64]<EOL> MH_CIGAM, MH_CIGAM_64 -> FILE_TYPE_OFFSET<EOL> FAT_MAGIC, FAT_MAGIC_64 -> {<EOL> raf.seek(FAT_FIRST_MACHO_OFFSET_OFFSET)<EOL> val firstMachoOffset = raf.readInt().fromUIntToLong() // guaranteed to be big-endian by the spec<EOL> firstMachoOffset + FILE_TYPE_OFFSET<EOL> }"}
{"docstring": " A build service required for correct test failures detection in KotlinTestReport as it requires crosstask interaction internal abstract class TestReportService BuildServiceTestReportServiceTestReportServiceParameters AutoCloseable internal interface TestReportServiceParameters BuildServiceParameters val testTasksStateFile RegularFileProperty private val log LogginggetLoggerthisjavaClass private val previouslyFailedTestTasks readPreviouslyFailedTasks private val reportHasFailedTests ConcurrentHashMapString Boolean private val testTaskSuppressedFailures ConcurrentHashMapString MutableListTaskError Marks KotlinTestReport with reportTaskPath as a report containing failed tests during the build testTaskPath is a path of the actual test task with failed tests fun testFailedreportTaskPath String testTaskPath String reportHasFailedTestsreportTaskPath true previouslyFailedTestTasksaddtestTaskPath Checks whether KotlinTestReport defined by path contains any children test tasks that failed during the build ", "modifier": "", "signature": "fun hasFailedTests(path: String): Boolean", "body": "{<EOL> return reportHasFailedTests[path] ?: false<EOL> }"}
{"docstring": " Asserts file under file path exists and is a regular file fun assertFileExists file Path assertFilesexistsfile File file does not exist assertFilesisRegularFilefile file is not a regular file Asserts file under pathToFile relative to the test project exists and is a regular file fun GradleProjectassertFileInProjectExists pathToFile String assertFileExistsprojectPathresolvepathToFilefun assertFileExistsInTree pathToTreeRoot Path fileName String val foundFile pathToTreeRoot toFile walk find itisFile itname fileName assertfoundFile null File fileName does not exists in pathToTreeRoot Asserts file under pathToFile relative to the test project does not exist fun GradleProjectassertFileInProjectNotExists pathToFile String assertFileNotExistsprojectPathresolvepathToFilefun assertFileNotExists pathToFile Path message String File pathToFile exists assertFilesexistspathToFile message fun assertFileNotExistsInTree pathToTreeRoot Path fileName String val foundFile pathToTreeRoot toFile walk find itisFile itname fileName assertfoundFile null File exists foundFileabsolutePath fun GradleProjectassertFileNotExistsInTree pathToTreeRoot String fileName String assertFileNotExistsInTreeprojectPathresolvepathToTreeRoot fileName Asserts symlink under path exists and is a symlink fun assertSymlinkExists path Path assertFilesexistspath Symlink path does not exist assertFilesisSymbolicLinkpath path is not a symlink Asserts symlink under pathToFile relative to the test project exists and is a symlink fun TestProjectassertSymlinkInProjectExists pathToFile String assertSymlinkExistsprojectPathresolvepathToFile Asserts directory under pathToDir relative to the test project exists and is a directory fun GradleProjectassertDirectoryInProjectExists pathToDir String assertDirectoryExistsprojectPathresolvepathToDir Asserts directory under dirPath exists and is a directory fun assertDirectoryExists dirPath Path message String null assertDirectoriesExistdirPath message messagefun assertDirectoriesExist vararg dirPaths Path message String null val exist notExist dirPathspartition itexists val notDirectories existfilterNot itisDirectory assertnotExistisEmpty notDirectoriesisEmpty message buildString if notExistisNotEmpty appendLineFollowing directories does not exist appendLinenotExistjoinToStringseparator n if notDirectoriesisNotEmpty appendLineFollowing files should be directories appendLinenotExistjoinToStringseparator n private const val appendIndentationIncrement 2Uprivate fun StringBuilderappendDirectorydirPath Path indentation UInt 0U FilesnewDirectoryStreamdirPathuse stream for entry in stream appendrepeatindentationtoInt entryfileName val isDirectory FilesisDirectoryentry appendLineif isDirectory else file if isDirectory appendDirectoryentry indentation appendIndentationIncrement appendLine fun GradleProjectassertDirectoryInProjectDoesNotExist dirName String assertDirectoryDoesNotExistprojectPathresolvedirNamefun assertDirectoryDoesNotExist dirPath Path assertFilesexistsdirPath buildString appendDirectory dirPath is expected to not exist if FilesisDirectorydirPath appendLineThe directory contents appendDirectorydirPath else appendHowever it is not even a directory Asserts file under pathToFile relative to the test project exists and contains all the lines from expectedText fun GradleProjectassertFileInProjectContains pathToFile String vararg expectedText String assertFileContainsprojectPathresolvepathToFile expectedText Asserts file under pathToFile relative to the test project exists and does not contain any line from unexpectedText fun GradleProjectassertFileInProjectDoesNotContain pathToFile String vararg unexpectedText String assertFileDoesNotContainprojectPathresolvepathToFile unexpectedText Asserts file under file exists and contains all the lines from expectedText return the content of the file ", "modifier": "", "signature": "fun assertFileContains(\n    file: Path,\n    vararg expectedText: String,\n): String", "body": "{<EOL> return assertFilesCombinedContains(listOf(file), *expectedText)<EOL>}"}
{"docstring": " Asserts files together contains all the lines from expectedText ", "modifier": "", "signature": "fun assertFilesCombinedContains(\n    files: List<Path>,\n    vararg expectedText: String,\n): String", "body": "{<EOL> files.forEach { assertFileExists(it) }"}
{"docstring": " converts back slashes to forward slashes removes double slashes inside the path eg xyz xyz Converted from comintellijopenapiutilioFileUtilnormalize ", "modifier": "", "signature": "fun normalizePath(path: String): String", "body": "{<EOL> var start = 0<EOL> var separator = false<EOL> if (isWindows) {<EOL> if (path.startsWith(\"//\")) {<EOL> start = 2<EOL> separator = true<EOL> }"}
{"docstring": " Returns true if the charCode with the categoryId was successfully placed in categoryIds ", "modifier": "", "signature": "fun fill(charCode: Int, categoryId: String): Boolean", "body": "{<EOL> return categoryIds.fill(charCode, categoryId)<EOL> }"}
{"docstring": " The base class of character ranges builders internal abstract class RangesBuilder private val ranges mutableListOfRangePattern private var lastAppendedCharCode 1 Appends a line from the UnicodeDatatxt file fun appendchar String name String categoryCode String val charCode charhexToInt val categoryId categoryIdcategoryCode when nameendsWith First rangeFirstcharCode categoryId nameendsWith Last rangeLastcharCode categoryId else appendcharCode categoryId lastAppendedCharCode charCode Optimizes the number of ranges and returns them Returns a Triple containing lists of range starts ends and categories in that particular order fun build TripleListInt ListInt ListInt for code in lastAppendedCharCode 10xffff appendSingleCharcode unassignedCategoryId var index rangeslastIndex while index 0 val previous rangesindex 1 val previousEnd previousrangeEnd val previousEndCategory previouscategoryIdOfpreviousEnd val current rangesindex if currentprependpreviousEnd previousEndCategory val newPrevious removeLastprevious if newPrevious null rangesindex 1 newPrevious else rangesremoveAtindex 1 index else index if this is LetterRangesBuilder printlnrangesjoinToStringseparator n if this is CharCategoryRangesBuilder printlnrangessubListfromIndex 0 toIndex 10joinToStringseparator n return Triplerangesmap itrangeStart rangesmap itrangeEnd rangesmap itcategory Appends the charCode as the start of a range of chars with the specified categoryId private fun rangeFirstcharCode Int categoryId String appendcharCode categoryId Appends the charCode as the end of a range of chars with the specified categoryId Chars between last appended char and the charCode are considered to have the specified categoryId private fun rangeLastcharCode Int categoryId String if shouldSkipcategoryId checkrangeslastrangeEnd lastAppendedCharCode checkrangeslastcategoryIdOflastAppendedCharCode categoryId for code in lastAppendedCharCode 1charCode appendSingleCharcode categoryId Appends the charCode with the specified categoryId Chars between last appended char and the charCode are considered to be unassigned private fun appendcharCode Int categoryId String for code in lastAppendedCharCode 1 until charCode appendSingleCharcode unassignedCategoryId appendSingleCharcharCode categoryId Appends the charCode with the specified categoryId to the last range or a new range containing the charCode is created The last range can be transformed to another range type to accommodate the charCode private fun appendSingleCharcharCode Int categoryId String if shouldSkipcategoryId return if rangesisEmpty rangesaddcreateRangecharCode categoryId return val lastRange rangeslast if lastRangeappendcharCode categoryId val newLastRange evolveLastRangelastRange charCode categoryId if newLastRange null rangesrangeslastIndex newLastRange else rangesaddcreateRangecharCode categoryId Category id used for unassigned chars protected val unassignedCategoryId String get categoryIdCharCategoryUNASSIGNEDcode Creates the simplest range containing the single charCode ", "modifier": "private ", "signature": "fun createRange(charCode: Int, categoryId: String): RangePattern", "body": "{<EOL> return PeriodicRangePattern.from(charCode, categoryId, sequenceLength = 1, isPeriodic = true, unassignedCategoryId, makeOnePeriodCategory)<EOL> }"}
{"docstring": " Get file path from a string pattern Implementation is mostly copied from DefaultMavenSettingsBuildergetFile ", "modifier": "private ", "signature": "fun getFilePath(filePattern: String): String", "body": "{<EOL> return substitutePropertiesValues(filePattern) { propertyValue -><EOL> propertyValue<EOL> .replace('\\\\', '/')<EOL> .replace(\"$\", \"\\\\$\")<EOL> }"}
{"docstring": " Generates text if randomCharPool is false from charSequence for each char in charSeq it adds line of length of 3 to the generated text if randomCharPool is true picks characters randomly line count is lines line length is 28 some number bigger than alphabet size ", "modifier": "private ", "signature": "fun initFragmentedScript(\n        charSeq: CharSequence = \"abc\",\n        randomCharPool: Boolean,\n        lines: Int = charSeq.length\n    ): FragmentedText", "body": "{<EOL> val generateFragment: FragmentedText.(Int) -> FragmentedText = when {<EOL> randomCharPool -> { _ -> addRandomFragment() }"}
{"docstring": " Asserts that value is not of type T with an optional message Note that due to type erasure the type check may be partial eg assertIsNotListStringvalue only checks for the class being List and not the type of its elements because its erased SinceKotlin15InlineOnlypublic inline fun reified T assertIsNotvalue Any message String null assertIsNotOfTypevalue typeOfT value is T messagePublishedApiinternal fun assertIsNotOfTypeSuppressUNUSED_PARAMETER value Any type KType result Boolean message String asserterassertTrue messagePrefixmessage Expected value to not be of type type result Asserts that the actual value is not null with an optional message public fun T Any assertNotNullactual T message String null T contract returns implies actual null asserterassertNotNullmessage actual return actual Asserts that the actual value is not null with an optional message and a function block to process the notnull value JvmNameassertNotNullInlineInlineOnlypublic inline fun T Any R assertNotNullactual T message String null block T R contract returns implies actual null blockassertNotNullactual message Asserts that the actual value is null with an optional message public fun assertNullactual Any message String null asserterassertNullmessage actual Asserts that the iterable contains the specified element with an optional message SinceKotlin15public fun OnlyInputTypes T assertContainsiterable IterableT element T message String null asserterassertTrue messagePrefixmessage Expected the collection to contain the elementnCollection iterable element element iterablecontainselement Asserts that the sequence contains the specified element with an optional message SinceKotlin15public fun OnlyInputTypes T assertContainssequence SequenceT element T message String null asserterassertTrue messagePrefixmessage Expected the sequence to contain the elementnSequence sequence element element sequencecontainselement Asserts that the array contains the specified element with an optional message SinceKotlin15public fun OnlyInputTypes T assertContainsarray ArrayT element T message String null assertArrayContainsarray element message ArrayTcontains ArrayTcontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray ByteArray element Byte message String null assertArrayContainsarray element message ByteArraycontains ByteArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray ShortArray element Short message String null assertArrayContainsarray element message ShortArraycontains ShortArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray IntArray element Int message String null assertArrayContainsarray element message IntArraycontains IntArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray LongArray element Long message String null assertArrayContainsarray element message LongArraycontains LongArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray BooleanArray element Boolean message String null assertArrayContainsarray element message BooleanArraycontains BooleanArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15public fun assertContainsarray CharArray element Char message String null assertArrayContainsarray element message CharArraycontains CharArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContainsarray UByteArray element UByte message String null assertArrayContainsarray element message UByteArraycontains UByteArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContainsarray UShortArray element UShort message String null assertArrayContainsarray element message UShortArraycontains UShortArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContainsarray UIntArray element UInt message String null assertArrayContainsarray element message UIntArraycontains UIntArraycontentToString Asserts that the array contains the specified element with an optional message SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContainsarray ULongArray element ULong message String null assertArrayContainsarray element message ULongArraycontains ULongArraycontentToStringkotlininternalInlineOnlyprivate inline fun OnlyInputTypes A E assertArrayContains array A element E message String null contains AE Boolean crossinline contentToString A String asserterassertTrue messagePrefixmessage Expected the array to contain the elementnArray arraycontentToString element elementtoString Explicitly call toString KT45684 arraycontainselement Asserts that the range contains the specified value with an optional message SinceKotlin15public fun assertContainsrange IntRange value Int message String null assertRangeContainsrange value message IntRangecontains Asserts that the range contains the specified value with an optional message SinceKotlin15public fun assertContainsrange LongRange value Long message String null assertRangeContainsrange value message LongRangecontains Asserts that the range contains the specified value with an optional message SinceKotlin15public fun T ComparableT assertContainsrange ClosedRangeT value T message String null assertRangeContainsrange value message ClosedRangeTcontains Asserts that the range contains the specified value with an optional message SinceKotlin17ExperimentalStdlibApipublic fun T ComparableT assertContainsrange OpenEndRangeT value T message String null assertRangeContainsrange value message OpenEndRangeTcontains Asserts that the range contains the specified value with an optional message SinceKotlin15public fun assertContainsrange CharRange value Char message String null assertRangeContainsrange value message CharRangecontains Asserts that the range contains the specified value with an optional message SinceKotlin15public fun assertContainsrange UIntRange value UInt message String null assertRangeContainsrange value message UIntRangecontains Asserts that the range contains the specified value with an optional message SinceKotlin15public fun assertContainsrange ULongRange value ULong message String null assertRangeContainsrange value message ULongRangecontainskotlininternalInlineOnlyprivate inline fun R V assertRangeContainsrange R value V message String null contains RV Boolean asserterassertTrue messagePrefixmessage Expected the range range to contain the value valuetoString Explicitly call toString KT45684 rangecontainsvalue Asserts that the map contains the specified key with an optional message SinceKotlin15public fun OnlyInputTypes K V assertContainsmap MapK V key K message String null asserterassertTrue messagePrefixmessage Expected the map to contain the keynMap map key key mapcontainsKeykey Asserts that the charSequence contains the specified char with an optional message param ignoreCase true to ignore character case when comparing characters By default false SinceKotlin15public fun assertContainscharSequence CharSequence char Char ignoreCase Boolean false message String null asserterassertTrue messagePrefixmessage Expected the char sequence to contain the charnCharSequence charSequence char char ignoreCase ignoreCase charSequencecontainschar ignoreCase Asserts that the charSequence contains the specified other char sequence as a substring with an optional message param ignoreCase true to ignore character case when comparing strings By default false SinceKotlin15public fun assertContainscharSequence CharSequence other CharSequence ignoreCase Boolean false message String null asserterassertTrue messagePrefixmessage Expected the char sequence to contain the substringnCharSequence charSequence substring other ignoreCase ignoreCase charSequencecontainsother ignoreCase Asserts that the charSequence contains at least one match of the specified regular expression regex with an optional message SinceKotlin15public fun assertContainscharSequence CharSequence regex Regex message String null asserterassertTrue messagePrefixmessage Expected the char sequence to contain the regular expressionnCharSequence charSequence regex regex charSequencecontainsregex Asserts that the expected iterable is structurally equal to the actual iterable with an optional message Two iterables are considered structurally equal if they have the same size and elements at corresponding positions following the iteration order are equal Elements are compared for equality using the equalsAnyequals function For floating point numbers this means NaN is equal to itself and 00 is not equal to 00 The iterables are also considered equal if both are null SinceKotlin15public fun OnlyInputTypes T assertContentEqualsexpected IterableT actual IterableT message String null assertIterableContentEqualsIterable message expected actual IterableiteratorSinceKotlin15DeprecatedassertContentEquals for Set arguments is ambiguous Use assertEquals to compare content with the unordered set equality or cast one of arguments to Iterable to compare the set elements in order of iteration level DeprecationLevelERROR replaceWith ReplaceWithassertContentEqualsexpected actualasIterable messagepublic fun OnlyInputTypes T assertContentEqualsexpected SetT actual SetT message String null Unit assertContentEqualsexpected actualasIterable message Asserts that the expected sequence is structurally equal to the actual sequence with an optional message Two sequences are considered structurally equal if they have the same size and elements at corresponding positions following the iteration order are equal Elements are compared for equality using the equalsAnyequals function For floating point numbers this means NaN is equal to itself and 00 is not equal to 00 The sequences are also considered equal if both are null SinceKotlin15public fun OnlyInputTypes T assertContentEqualsexpected SequenceT actual SequenceT message String null assertIterableContentEqualsSequence message expected actual Sequenceiterator Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal Elements are compared for equality using the equalsAnyequals function For floating point numbers this means NaN is equal to itself and 00 is not equal to 00 The arrays are also considered equal if both are null SinceKotlin15public fun OnlyInputTypes T assertContentEqualsexpected ArrayT actual ArrayT message String null assertArrayContentEqualsmessage expected actual itsize Arrayget ArraycontentToString ArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected ByteArray actual ByteArray message String null assertArrayContentEqualsmessage expected actual itsize ByteArrayget ByteArraycontentToString ByteArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected ShortArray actual ShortArray message String null assertArrayContentEqualsmessage expected actual itsize ShortArrayget ShortArraycontentToString ShortArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected IntArray actual IntArray message String null assertArrayContentEqualsmessage expected actual itsize IntArrayget IntArraycontentToString IntArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected LongArray actual LongArray message String null assertArrayContentEqualsmessage expected actual itsize LongArrayget LongArraycontentToString LongArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal Elements are compared for equality using the equalsAnyequals function For floating point numbers this means NaN is equal to itself and 00 is not equal to 00 The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected FloatArray actual FloatArray message String null assertArrayContentEqualsmessage expected actual itsize FloatArrayget FloatArraycontentToString FloatArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal Elements are compared for equality using the equalsAnyequals function For floating point numbers this means NaN is equal to itself and 00 is not equal to 00 The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected DoubleArray actual DoubleArray message String null assertArrayContentEqualsmessage expected actual itsize DoubleArrayget DoubleArraycontentToString DoubleArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected BooleanArray actual BooleanArray message String null assertArrayContentEqualsmessage expected actual itsize BooleanArrayget BooleanArraycontentToString BooleanArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15public fun assertContentEqualsexpected CharArray actual CharArray message String null assertArrayContentEqualsmessage expected actual itsize CharArrayget CharArraycontentToString CharArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContentEqualsexpected UByteArray actual UByteArray message String null assertArrayContentEqualsmessage expected actual itsize UByteArrayget UByteArraycontentToString UByteArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContentEqualsexpected UShortArray actual UShortArray message String null assertArrayContentEqualsmessage expected actual itsize UShortArrayget UShortArraycontentToString UShortArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContentEqualsexpected UIntArray actual UIntArray message String null assertArrayContentEqualsmessage expected actual itsize UIntArrayget UIntArraycontentToString UIntArraycontentEquals Asserts that the expected array is structurally equal to the actual array with an optional message Two arrays are considered structurally equal if they have the same size and elements at corresponding indices are equal The arrays are also considered equal if both are null SinceKotlin15OptInExperimentalUnsignedTypesclasspublic fun assertContentEqualsexpected ULongArray actual ULongArray message String null assertArrayContentEqualsmessage expected actual itsize ULongArrayget ULongArraycontentToString ULongArraycontentEquals Marks a test as having failed if this point in the execution path is reached with an optional message ", "modifier": "public ", "signature": "fun fail(message: String? = null): Nothing", "body": "{<EOL> asserter.fail(message)<EOL>}"}
{"docstring": " Asserts that the specified value is true param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertTrue(message: String?, actual: Boolean): Unit", "body": "{<EOL> assertTrue({ message }"}
{"docstring": " Asserts that the specified values are equal param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertEquals(message: String?, expected: Any?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual>.\" }"}
{"docstring": " Asserts that the specified values are not equal param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertNotEquals(message: String?, illegal: Any?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Illegal value: <$actual>.\" }"}
{"docstring": " Asserts that the specified values are the same instance param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertSame(message: String?, expected: Any?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual> is not same.\" }"}
{"docstring": " Asserts that the specified values are not the same instance param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertNotSame(message: String?, illegal: Any?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Expected not same as <$actual>.\" }"}
{"docstring": " Asserts that the specified value is null param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertNull(message: String?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Expected value to be null, but was: <$actual>.\" }"}
{"docstring": " Asserts that the specified value is not null param message the message to report if the assertion fails ", "modifier": "public ", "signature": "fun assertNotNull(message: String?, actual: Any?): Unit", "body": "{<EOL> assertTrue({ messagePrefix(message) + \"Expected value to be not null.\" }"}
{"docstring": " Represents the parsed metadata of a Kotlin JVM module file To create an instance of KotlinModuleMetadata load the contents of the kotlin_module file into a byte array and call KotlinModuleMetadataread Then it is possible to get the result in the form of KmModule with KotlinModuleMetadatakmModule kotlin_module file is produced per Kotlin compilation and contains auxiliary information such as a map of all single and multifile facades KmModulepackageParts and OptionalExpectation declarations KmModuleoptionalAnnotationClasses UnstableMetadataApipublic class KotlinModuleMetadata public constructor KmModule representation of this metadata Returns the same mutable KmModule instance every time public var kmModule KmModule Version of this metadata public var version JvmMetadataVersion Encodes and writes this metadata of the Kotlin module file This method encodes all available data including version throws IllegalArgumentException if kmModule is not correct and cannot be written or if version is not supported for writing ", "modifier": "public ", "signature": "fun write(): ByteArray", "body": "{<EOL> val b = JvmModuleProtoBuf.Module.newBuilder()<EOL> kmModule.packageParts.forEach { (fqName, packageParts) -><EOL> PackageParts(fqName).apply {<EOL> for (fileFacade in packageParts.fileFacades) {<EOL> addPart(fileFacade, null)<EOL> }"}
{"docstring": " Allows to modify the way fragments of the single package are read by KlibModuleMetadataread For example it may be convenient to join fragments into a single one interface KlibModuleFragmentReadStrategy fun processModulePartsparts ListKmModuleFragment ListKmModuleFragment companion object val DEFAULT object KlibModuleFragmentReadStrategy override fun processModulePartsparts ListKmModuleFragment parts Allows to modify the way module fragments are written by KlibModuleMetadatawrite For example splitting big fragments into several small one allows to improve IDE performance interface KlibModuleFragmentWriteStrategy fun processPackagePartsparts ListKmModuleFragment ListKmModuleFragment companion object val DEFAULT object KlibModuleFragmentWriteStrategy override fun processPackagePartsparts ListKmModuleFragment ListKmModuleFragment parts Represents the parsed metadata of KLIB class KlibModuleMetadata val name String val fragments ListKmModuleFragment val annotations ListKmAnnotation Serialized representation of module metadata class SerializedKlibMetadata val header ByteArray val fragments ListListByteArray val fragmentNames ListString Specifies access to librarys metadata interface MetadataLibraryProvider val moduleHeaderData ByteArray fun packageMetadataPartsfqName String SetString fun packageMetadatafqName String partName String ByteArray companion object Deserializes metadata from the given library param readStrategy specifies the way module fragments of a single package are modified eg merged after deserialization ", "modifier": "", "signature": "fun read(\n            library: MetadataLibraryProvider,\n            readStrategy: KlibModuleFragmentReadStrategy = KlibModuleFragmentReadStrategy.DEFAULT\n        ): KlibModuleMetadata", "body": "{<EOL> val moduleHeaderProto = parseModuleHeader(library.moduleHeaderData)<EOL> val headerNameResolver = NameResolverImpl(moduleHeaderProto.strings, moduleHeaderProto.qualifiedNames)<EOL> val moduleHeader = moduleHeaderProto.readHeader(headerNameResolver)<EOL> val fileIndex = SourceFileIndexReadExtension(moduleHeader.file)<EOL> val moduleFragments = moduleHeader.packageFragmentName.flatMap { packageFqName -><EOL> library.packageMetadataParts(packageFqName).map { part -><EOL> val packageFragment = parsePackageFragment(library.packageMetadata(packageFqName, part))<EOL> val nameResolver = NameResolverImpl(packageFragment.strings, packageFragment.qualifiedNames)<EOL> packageFragment.toKmModuleFragment(nameResolver, listOf(fileIndex))<EOL> }"}
{"docstring": " Writes metadata back to serialized representation param writeStrategy specifies the way module fragments are modified eg split before serialization ", "modifier": "", "signature": "fun write(\n        writeStrategy: KlibModuleFragmentWriteStrategy = KlibModuleFragmentWriteStrategy.DEFAULT\n    ): SerializedKlibMetadata", "body": "{<EOL> val reverseIndex = ReverseSourceFileIndexWriteExtension()<EOL><EOL><EOL> val groupedFragments = fragments<EOL> .groupBy(KmModuleFragment::fqNameOrFail)<EOL> .mapValues { writeStrategy.processPackageParts(it.value) }"}
{"docstring": " Creates an ULong value directly from mantissa bits of Double that is in range 263 264 ", "modifier": "private ", "signature": "fun specialDoubleToULong(v: Double): ULong", "body": "{<EOL> require(v >= 2.0.pow(63))<EOL> require(v < 2.0.pow(64))<EOL> val bits = v.toBits().toULong()<EOL> return (1uL shl 63) + ((bits and (1uL shl 52) - 1u) shl 11)<EOL> }"}
{"docstring": " An interface for indexing access to a collection of keyvalue pairs where type of key is String and type of value is AnyAny public external interface Json Calls to the function will be translated to indexing operation square brackets on the receiver with propertyName as the argument Eg for next code kotlin fun testj Json p String jprop jgetp will be generated js function testj p return jprop jp public operator fun getpropertyName String Any Calls of the function will be translated to an assignment of value to the receiver indexed with square bracketsindex operation with propertyName Eg for the following code kotlin fun testj Json p String newValue Any jprop 1 jsetp newValue will be generated js function testj p newValue jprop 1 jp newValue public operator fun setpropertyName String value Any Unit Returns a simple JavaScript object as Json using provided keyvalue pairs as names and values of its properties ", "modifier": "public ", "signature": "fun json(vararg pairs: Pair<String, Any?>): Json", "body": "{<EOL> val res: dynamic = js(\"({}"}
{"docstring": " Returns the negative size if throwOnMalformed is false throws CharacterCodingException otherwise ", "modifier": "private ", "signature": "fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}"}
{"docstring": " Returns code point corresponding to UTF16 surrogate pair where the first of the pair is the high and the second is in the string at the index Returns zero if the pair is malformed and throwOnMalformed is false throws CharacterCodingException if the pair is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (high !in 0xD800..0xDBFF || index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of two bytes where the first byte of the sequence is the byte1 and the second byte is in the bytes array at the index Returns zero if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of two bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (byte1 and 0x1E == 0 || index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of three bytes where the first byte of the sequence is the byte1 and the others are in the bytes array starting from the index Returns a nonpositive value indicating number of bytes from bytes included in malformed sequence if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of three bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of four bytes where the first byte of the sequence is the byte1 and the others are in the bytes array starting from the index Returns a nonpositive value indicating number of bytes from bytes included in malformed sequence if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of four bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (index >= endIndex) {<EOL> malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns the negative size if throwOnMalformed is false throws CharacterCodingException otherwise ", "modifier": "private ", "signature": "fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}"}
{"docstring": " Returns code point corresponding to UTF16 surrogate pair where the first of the pair is the high and the second is in the string at the index Returns zero if the pair is malformed and throwOnMalformed is false throws CharacterCodingException if the pair is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (high !in 0xD800..0xDBFF || index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of two bytes where the first byte of the sequence is the byte1 and the second byte is in the bytes array at the index Returns zero if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of two bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (byte1 and 0x1E == 0 || index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of three bytes where the first byte of the sequence is the byte1 and the others are in the bytes array starting from the index Returns a nonpositive value indicating number of bytes from bytes included in malformed sequence if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of three bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (index >= endIndex) {<EOL> return malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " Returns code point corresponding to UTF8 sequence of four bytes where the first byte of the sequence is the byte1 and the others are in the bytes array starting from the index Returns a nonpositive value indicating number of bytes from bytes included in malformed sequence if the sequence is malformed and throwOnMalformed is false throws CharacterCodingException if the sequence of four bytes is malformed and throwOnMalformed is true ", "modifier": "private ", "signature": "fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int", "body": "{<EOL> if (index >= endIndex) {<EOL> malformed(0, index, throwOnMalformed)<EOL> }"}
{"docstring": " A vector of bits growing if necessary and allowing one to setclearread bits from it by a bit index this is the stripped copy of KN implementation for Regex constructor creates an empty bit set with the specified size param size the size of one element in the array used to store bits internal class BitSet constructorsize Int ELEMENT_SIZE companion object Default size of one element in the array used to store bits private const val ELEMENT_SIZE 64 private const val MAX_BIT_OFFSET ELEMENT_SIZE 1 private const val ALL_TRUE 1L 0xFFFF_FFFF_FFFF_FFFF private const val ALL_FALSE 0L 0x0000_0000_0000_0000 private var bits LongArray LongArraybitToElementSizesize private val lastIndex Int get size 1 True if this BitSet contains no bits set to true val isEmpty Boolean get bitsall it ALL_FALSE Actual number of bits available in the set All bits with indices size assumed to be 0 var size Int size private set Transforms a bit index into an element index in the bits array private val IntelementIndex Int get this ELEMENT_SIZE Transforms a bit index in the set into a bit in the element of the bits array private val IntbitOffset Int get this ELEMENT_SIZE Transforms a bit index in the set into pair of a bits element index and a bit index in the element private val IntasBitCoordinates PairInt Int get PairelementIndex bitOffset Transforms a bit offset to the mask with only bit set corresponding to the offset private val IntasMask Long get 0x1L shl this Transforms a bit offset to the mask with only bits before the index inclusive set private val IntasMaskBefore Long get getMaskBetween0 this Transforms a bit offset to the mask with only bits after the index inclusive set private val IntasMaskAfter Long get getMaskBetweenthis MAX_BIT_OFFSET Builds a masks with 1 between fromOffset and toOffset both inclusive private fun getMaskBetweenfromOffset Int toOffset Int Long var res 0L val maskToAdd fromOffsetasMask for i in fromOffsettoOffset res res shl 1 or maskToAdd return res Transforms a size in bits to a size in elements of the bits array private fun bitToElementSizebitSize Int Int bitSize ELEMENT_SIZE 1 ELEMENT_SIZE Transforms a pair of an element index and a bit offset to a bit index private fun bitIndexelementIndex Int bitOffset Int elementIndex ELEMENT_SIZE bitOffset Sets all bits after the last available bit size 1 to 0 private fun clearUnusedTail val lastElementIndex lastBitOffset lastIndexasBitCoordinates bitsbitslastIndex bitsbitslastIndex and lastBitOffsetasMaskBefore for i in lastElementIndex 1 until bitssize bitsi ALL_FALSE Internal function Sets bits specified by the element index and the given mask to value private fun setBitsWithMaskelementIndex Int mask Long value Boolean val element bitselementIndex if value bitselementIndex element or mask else bitselementIndex element and maskinv Checks if index is valid and extends the bits array if the index exceeds its size throws IndexOutOfBoundsException if index 0 private fun ensureCapacityindex Int if index 0 throw IndexOutOfBoundsException if index size size index 1 if indexelementIndex bitssize Create a new array containing the indexth bit bits bitscopyOfbitToElementSizeindex 1 Set all bits after the index to 0 TODO We can remove it clearUnusedTail Set the bit specified to the specified value fun setindex Int value Boolean true ensureCapacityindex val elementIndex offset indexasBitCoordinates setBitsWithMaskelementIndex offsetasMask value Sets the bits with indices between from inclusive and to exclusive to the specified value fun setfrom Int to Int value Boolean true setfrom until to value Sets the bits from the range specified to the specified value fun setrange IntRange value Boolean true if rangestart 0 rangeendInclusive 0 throw IndexOutOfBoundsException if rangestart rangeendInclusive Empty range return ensureCapacityrangeendInclusive val fromIndex fromOffset rangestartasBitCoordinates val toIndex toOffset rangeendInclusiveasBitCoordinates if toIndex fromIndex val mask getMaskBetweenfromOffset toOffset setBitsWithMaskfromIndex mask value else Set bits in the first element setBitsWithMaskfromIndex fromOffsetasMaskAfter value Set all bits of all elements excluding border ones to 0 or 1 depending for index in fromIndex 1 until toIndex bitsindex if value ALL_TRUE else ALL_FALSE Set bits in the last element setBitsWithMasktoIndex toOffsetasMaskBefore value Returns an index of a next set if lookFor true or clear if lookFor false bit after startIndex inclusive Returns 1 for lookFor true or size for lookFor false if there is no such bits between startIndex and size 1 throws IndexOutOfBoundException if startIndex 0 ", "modifier": "private ", "signature": "fun nextBit(startIndex: Int, lookFor: Boolean): Int", "body": "{<EOL> if (startIndex < 0) {<EOL> throw IndexOutOfBoundsException()<EOL> }"}
{"docstring": " Gets canonical class for given codepoint from decomposition mappings table internal fun getCanonicalClassInternalch Int Int return getCanonicalClassch Check if the given character is in table of single decompositions internal fun hasSingleCodepointDecompositionInternalch Int Boolean val index Int binarySearchRangesingleDecompositions ch return index 1 singleDecompositionsindex ch Decomposes the given string represented as an array of codepoints Saves the decomposition into outputCodepoints array Returns the length of the decomposition internal fun decomposeStringinputCodePoints IntArray inputLength Int outputCodePoints IntArray Int if inputLength 0 return 0 var outputLength 0 for i in 0 until inputLength val decomposition getDecompositioninputCodePointsi if decomposition null outputCodePointsoutputLength inputCodePointsi else decompositioncopyIntooutputCodePoints outputLength outputLength decompositionsize return outputLength Decomposes the given codepoint Saves the decomposition into outputCodepoints array starting with fromIndex Returns the length of the decomposition internal fun decomposeCodePointcodePoint Int outputCodePoints IntArray fromIndex Int Int val decomposition getDecompositioncodePoint if decomposition null outputCodePointsfromIndex codePoint return 1 else decompositioncopyIntooutputCodePoints fromIndex return decompositionsize Returns the index of the largest element in array smaller or equal to the specified needle or 1 if needle is smaller than the smallest element in array ", "modifier": "private ", "signature": "fun binarySearchRange(array: IntArray, needle: Int): Int", "body": "{<EOL> var bottom = 0<EOL> var top = array.size - 1<EOL> var middle = -1<EOL> var value = 0<EOL> while (bottom <= top) {<EOL> middle = (bottom + top) / 2<EOL> value = array[middle]<EOL> if (needle > value)<EOL> bottom = middle + 1<EOL> else if (needle == value)<EOL> return middle<EOL> else<EOL> top = middle - 1<EOL> }"}
{"docstring": " Sets the maximum depth of a directory tree to traverse By default there is no limit The value must be positive and IntMAX_VALUE is used to specify an unlimited depth With a value of 1 walker visits only the origin directory and all its immediate children with a value of 2 also grandchildren etc ", "modifier": "public ", "signature": "fun maxDepth(depth: Int): FileTreeWalk", "body": "{<EOL> if (depth <= 0)<EOL> throw IllegalArgumentException(\"depth must be positive, but was $depth.\")<EOL> return FileTreeWalk(start, direction, onEnter, onLeave, onFail, depth)<EOL> }"}
{"docstring": " Estimation of a root name by a given file name This implementation is able to find Drive Drive or networknameroot as possible root names denotes Fileseparator here so can be used instead All other possible roots cannot be identified by this implementation Its also not guaranteed but possible that function will be able to detect a root which is incorrect for current OS For instance in Unix function cannot detect network root names like networknameroot but can detect Windows roots like C return length or a substring representing the root for this path or zero if this file name is relative private fun StringgetRootLength Int Note separators should be already replaced to system ones var first indexOfFileseparatorChar 0 if first 0 if length 1 this1 FileseparatorChar Network names like myhosthomesomething myhosthome should be root NB does not work in Unix because myhosthome is converted into myhosthome there So in Windows well have root of myhosthome but in Unix just first indexOfFileseparatorChar 2 if first 0 first indexOfFileseparatorChar first 1 if first 0 return first 1 else return length return 1 C if first 0 thisfirst 1 first return first C if first 1 endsWith return length return 0 Estimation of a root name for this file This implementation is able to find Drive Drive or networknameroot as possible root names denotes Fileseparator here so can be used instead All other possible roots cannot be identified by this implementation Its also not guaranteed but possible that function will be able to detect a root which is incorrect for current OS For instance in Unix function cannot detect network root names like networknameroot but can detect Windows roots like C return string representing the root for this file or empty string is this file name is relative internal val FilerootName String get pathsubstring0 pathgetRootLength Returns root component of this abstract name like from homeuser or C from Cfiletmp or myhosthome for myhosthomeuser internal val Fileroot File get FilerootName Determines whether this file has a root or it represents a relative path Returns true when this file has nonempty root public val FileisRooted Boolean get pathgetRootLength 0 Represents the path to a file as a collection of directories property root the File object representing root of the path for example or C or empty for relative paths property segments the list of File objects representing every directory in the path to the file up to an including the file itself internal data class FilePathComponents internal constructorpublic val root File public val segments ListFile Returns a string representing the root for this file or an empty string is this file name is relative public val rootName String get rootpath Returns true when the root is not empty public val isRooted Boolean get rootpathisNotEmpty Returns the number of elements in the path to the file public val size Int get segmentssize Returns a subpath of the path starting with the directory at the specified beginIndex and up to the specified endIndex ", "modifier": "public ", "signature": "fun subPath(beginIndex: Int, endIndex: Int): File", "body": "{<EOL> if (beginIndex < 0 || beginIndex > endIndex || endIndex > size)<EOL> throw IllegalArgumentException()<EOL><EOL> return File(segments.subList(beginIndex, endIndex).joinToString(File.separator))<EOL> }"}
{"docstring": " Retains elements if retain true and removes them it retain false ", "modifier": "private ", "signature": "fun retainOrRemoveAllInternal(rangeOffset: Int, rangeLength: Int, elements: Collection<E>, retain: Boolean): Int", "body": "{<EOL> var i = 0<EOL> var j = 0<EOL> while (i < rangeLength) {<EOL> if (elements.contains(backing[rangeOffset + i]) == retain) {<EOL> backing[rangeOffset + j++] = backing[rangeOffset + i++]<EOL> }"}
{"docstring": " Retains elements if retain true and removes them it retain false ", "modifier": "private ", "signature": "fun retainOrRemoveAllInternal(rangeOffset: Int, rangeLength: Int, elements: Collection<E>, retain: Boolean): Int", "body": "{<EOL> val removed =<EOL> if (parent != null) {<EOL> parent.retainOrRemoveAllInternal(rangeOffset, rangeLength, elements, retain)<EOL> }"}
{"docstring": " Returns current character and moves string index to the next one operator fun next Int movePointer return lookBack Returns current special token and moves string index to the next one fun nextSpecial SpecialToken val res curSpecialToken movePointer return res Reread current character May be required if a previous token changes mode to one with different character interpretation private fun reread lookAhead currentChar lookAheadSpecialToken curSpecialToken index lookAheadTokenIndex lookAheadTokenIndex curTokenIndex movePointer Returns the next character index to read and moves pointer to the next one If comments flag is on this method will skip comments and whitespaces The following actions are equivalent if comments flag is off currentChar patternindex currentChar patternnextIndex ", "modifier": "private ", "signature": "fun nextIndex(): Int", "body": "{<EOL> prevNonWhitespaceIndex = index<EOL> index++<EOL> if (mode != Mode.ESCAPE && flags and Pattern.COMMENTS != 0) {<EOL> skipComments()<EOL> }"}
{"docstring": " Skips comments and whitespaces ", "modifier": "private ", "signature": "fun skipComments(): Int", "body": "{<EOL> val length = pattern.size - 2<EOL> do {<EOL> while (index < length && pattern[index].isWhitespace()) {<EOL> index++<EOL> }"}
{"docstring": " Returns the next code point in the pattern string OptInExperimentalNativeApiclass private fun nextCodePoint Int val high patternnextIndex nextIndex skips comments and whitespaces if comments flag is on if highisHighSurrogate Low and high chars may be delimited by spaces val lowExpectedIndex prevNonWhitespaceIndex 1 if lowExpectedIndex patternsize val low patternlowExpectedIndex if lowisLowSurrogate nextIndex return ChartoCodePointhigh low return hightoInt Moves pointer one position right Saves the current character to lookBack lookAhead to the current one and finally read one more to lookAhead private fun movePointer swap pointers lookBack currentChar currentChar lookAhead curSpecialToken lookAheadSpecialToken curTokenIndex lookAheadTokenIndex lookAheadTokenIndex index var reread Boolean do Read the next character analyze it and construct a token lookAhead if index patternsize nextCodePoint else 0 lookAheadSpecialToken null if mode ModeESCAPE processInEscapeMode reread when mode ModePATTERN processInPatternMode ModeRANGE processInRangeMode else false while reread Special functions called from movePointer function to process chars in different modes Processing an escaped sequence like Q foo E Just skip a character if it is not E Returns whether we need to reread the character or not ", "modifier": "private ", "signature": "fun processInEscapeMode(): Boolean", "body": "{<EOL> if (lookAhead == '\\\\'.toInt()) {<EOL> // Need not care about supplementary code points here.<EOL> val lookAheadChar: Char = if (index < pattern.size) pattern[nextIndex()] else '\\u0000'<EOL> lookAhead = lookAheadChar.toInt()<EOL><EOL> if (lookAheadChar == 'E') {<EOL> // If \\E found - change the mode to the previous one and shift to the next char.<EOL> mode = savedMode<EOL> index = prevNonWhitespaceIndex // index of 'E'<EOL> nextIndex() // skip 'E' and process the following chars with the saved mode<EOL> lookAhead = if (index <= pattern.size - 2) nextCodePoint() else 0<EOL> }"}
{"docstring": " Processes a next character in ModePATTERN mode Returns whether we need to reread the character or not ", "modifier": "private ", "signature": "fun processInPatternMode(): Boolean", "body": "{<EOL> if (lookAhead.isSurrogatePair()) {<EOL> return false<EOL> }"}
{"docstring": " Processes a character inside a range Returns whether we need to reread the character or not ", "modifier": "private ", "signature": "fun processInRangeMode(): Boolean", "body": "{<EOL> if (lookAhead.isSurrogatePair()) {<EOL> return false<EOL> }"}
{"docstring": " Processes an escaped x character in any mode Returns whether we need to reread the character or not ", "modifier": "private ", "signature": "fun processEscapedChar() : Boolean", "body": "{<EOL> val escapedCharIndex = prevNonWhitespaceIndex + 1<EOL> if (escapedCharIndex >= pattern.size - 2) {<EOL> throw PatternSyntaxException(\"Trailing \\\\\", patternString, curTokenIndex)<EOL> }"}
{"docstring": " Process lookAhead in assumption that its quantifier ", "modifier": "private ", "signature": "fun processQuantifier(): Quantifier", "body": "{<EOL> @OptIn(ExperimentalNativeApi::class)<EOL> assert(lookAhead == '{'.toInt())<EOL> val sb = StringBuilder(4)<EOL> var min = -1<EOL> var max = -1<EOL><EOL> // Obtain a min value.<EOL> var char: Char = if (index < pattern.size) {<EOL> pattern[nextIndex()]<EOL> }"}
{"docstring": " Process expression flags given with idmsuxidmsux Returns the flags processed ", "modifier": "private ", "signature": "fun readFlags(): Int", "body": "{<EOL> var positive = true<EOL> var result = flags<EOL><EOL> while (index < pattern.size) {<EOL> val char = pattern[index]<EOL> when (char) {<EOL> '-' -> {<EOL> if (!positive) {<EOL> throw PatternSyntaxException(\"Illegal inline construct\", patternString, curTokenIndex)<EOL> }"}
{"docstring": " Parse character classes names and verifies correction of the syntax ", "modifier": "private ", "signature": "fun parseCharClassName(): String", "body": "{<EOL> val sb = StringBuilder(10)<EOL> if (index < pattern.size - 2) {<EOL> // one symbol family<EOL> if (pattern[index] != '{') {<EOL> return \"Is${pattern[nextIndex()]}"}
{"docstring": " Process hexadecimal integer ", "modifier": "private ", "signature": "fun readHex(radixName: String, max: Int): Int", "body": "{<EOL> val builder = StringBuilder(max)<EOL> val length = pattern.size - 2<EOL> var i = 0<EOL> while (i < max && index < length) {<EOL> builder.append(pattern[nextIndex()])<EOL> i++<EOL> }"}
{"docstring": " Process octal integer ", "modifier": "private ", "signature": "fun readOctals(): Int", "body": "{<EOL> val length = pattern.size - 2<EOL> var result = 0<EOL> var digit = digitOf(pattern[index], 8)<EOL> if (digit == -1) {<EOL> throw PatternSyntaxException(\"Invalid octal escape sequence\", patternString, curTokenIndex)<EOL> }"}
{"docstring": " Returns true if ch is a plain token ", "modifier": "", "signature": "fun isLetter(ch: Int): Boolean", "body": "{<EOL> // All supplementary codepoints have integer value that is >= 0.<EOL> return ch >= 0<EOL> }"}
{"docstring": " Rearrange codepoints in inputInts according to canonical order Return an array with rearranged codepoints ", "modifier": "", "signature": "fun getCanonicalOrder(inputInts: IntArray, length: Int): IntArray", "body": "{<EOL> val inputLength = if (length < inputInts.size)<EOL> length<EOL> else<EOL> inputInts.size<EOL><EOL> /*<EOL> * Simple bubble-sort algorithm. Note that many codepoints have 0 canonical class, so this algorithm works<EOL> * almost lineary in overwhelming majority of cases. This is due to specific of Unicode combining<EOL> * classes and codepoints.<EOL> */<EOL> for (i in 1..inputLength - 1) {<EOL> var j = i - 1<EOL> val iCanonicalClass = getCanonicalClass(inputInts[i])<EOL> val ch: Int<EOL><EOL> if (iCanonicalClass == 0) {<EOL> continue<EOL> }"}
{"docstring": " Unicode category ie Ll Lu internal open class UnicodeCategoryprotected val category Int AbstractCharClass override fun containsch Int Boolean alt xor chtoCharcategoryvalue category Unicode category scope ie IsL IsM internal class UnicodeCategoryScopecategory Int UnicodeCategorycategory override fun containsch Int Boolean return alt xor category shr chtoCharcategoryvalue and 1 0 This class represents character classes ie sets of character either predefined or user defined Note this class represent a token not node so being constructed by lexer OptInFreezingIsDeprecatedclass ObsoleteNativeApiclassinternal abstract class AbstractCharClass SpecialToken Show if the class has alternative meaning if the class contains character a and alt true then the class will contains all characters except a internal var alt Boolean false internal var altSurrogates Boolean false For each unpaired surrogate char indicates whether it is contained in this char class internal val lowHighSurrogates BitSetSURROGATE_CARDINALITY Bit set for surrogates Indicates if this class may contain supplementary Unicode codepoints If this flag is specified it doesnt mean that this class contains supplementary characters but may contain var mayContainSupplCodepoints false protected set Returns true if this char class contains character specified abstract operator fun containsch Int Boolean open fun containsch Char Boolean containschtoInt Returns BitSet representing this character class or null if this character class does not have character representation open internal val bits BitSet get null fun hasLowHighSurrogates Boolean return if altSurrogates lowHighSurrogatesnextClearBit0 1 else lowHighSurrogatesnextSetBit0 1 override val type Type TypeCHARCLASS open val instance AbstractCharClass get this private val surrogates_ AtomicReferenceAbstractCharClassnull Returns a char class that contains only unpaired surrogate chars from this char class Consider the following char class auD801uDC00uD800 This function returns a char class that contains only uD800 uD800 classWithoutSurrogates returns a char class that does not contain uD800 auD801uDC00 The returned char class is used to create SurrogateRangeSet node that matches any unpaired surrogate from this char class SurrogateRangeSet doesnt match a surrogate that is paired with the char before or after it The result of classWithoutSurrogates is used to create SupplementaryRangeSet or RangeSet depending on mayContainSupplCodepoints The two nodes are then combined in CompositeRangeSet node to fully represent this char class ", "modifier": "", "signature": "fun classWithSurrogates(): AbstractCharClass", "body": "{<EOL> surrogates_.value?.let {<EOL> return it<EOL> }"}
{"docstring": " Returns a char class that contains all chars from this char class excluding the unpaired surrogate chars See classWithSurrogates for details We cannot cache this class as weve done with surrogates above because here is a circular reference between it and AbstractCharClass fun classWithoutSurrogates AbstractCharClass val result object AbstractCharClass override fun containsch Int Boolean val index ch CharMIN_SURROGATEtoInt val containslHS if index 0 index AbstractCharClassSURROGATE_CARDINALITY thisaltSurrogates xor thisAbstractCharClasslowHighSurrogatesgetindex else false return thisAbstractCharClasscontainsch containslHS resultalt thisalt resultaltSurrogates thisaltSurrogates resultmayContainSupplCodepoints thismayContainSupplCodepoints return result Sets this CharClass to negative form ie if they will add some characters and after that set this class to negative it will accept all the characters except previously set ones Although this method will not alternate all the already set characters just overall meaning of the class ", "modifier": "", "signature": "fun setNegative(value: Boolean): AbstractCharClass", "body": "{<EOL> if (alt xor value) {<EOL> alt = !alt<EOL> altSurrogates = !altSurrogates<EOL><EOL> if (!mayContainSupplCodepoints) {<EOL> mayContainSupplCodepoints = true<EOL> }"}
{"docstring": " Match result implementation internal class MatchResultImpl param input an input sequence for matchingsearching param regex a Regex instance used for matchingsearching constructor internal val input CharSequence internal val regex Regex MatchResult Harmonys implementation private val nativePattern regexnativePattern private val groupCount nativePatterncapturingGroupssize private val groupBounds IntArraygroupCount 2 1 private val consumers IntArraynativePatternconsumersCount 1 1 Used by quantifiers to store a count of a quantified expression occurrences val enterCounters IntArray IntArray maxOfnativePatterngroupQuantifierCount 0 var startIndex Int 0 set startIndex Int field startIndex if previousMatch 0 previousMatch startIndex var previousMatch 1 var mode RegexModeMATCH private data class MatchResultStateval groupBounds IntArray val consumers IntArray val enterCounters IntArray val startIndex Int val previousMatch Int private var state MatchResultState null internal fun saveState state MatchResultStategroupBoundscopyOf consumerscopyOf enterCounterscopyOf startIndex previousMatch internal fun rollbackState Boolean return statelet itgroupBoundscopyIntogroupBounds itconsumerscopyIntoconsumers itenterCounterscopyIntoenterCounters startIndex itstartIndex previousMatch itpreviousMatch true false MatchResult interface The range of indices in the original string where match was captured override val range IntRange get getStart0 until getEnd0 The substring from the input string captured by this match override val value String get group0 throw AssertionErrorNo groupIndex 0 in the match result A collection of groups matched by the regular expression This collection has size of groupCount 1 where groupCount is the count of groups in the regular expression Groups are indexed from 1 to groupCount and group with the index 0 corresponds to the entire match Create one object or several ones override val groups MatchGroupCollection object MatchNamedGroupCollection AbstractCollectionMatchGroup override val size Int get thisMatchResultImplgroupCount override fun iterator IteratorMatchGroup return object IteratorMatchGroup var nextIndex Int 0 override fun hasNext Boolean return nextIndex size override fun next MatchGroup if hasNext throw NoSuchElementException return getnextIndex override fun getindex Int MatchGroup val value groupindex return null return MatchGroupvalue getStartindex until getEndindex override fun getname String MatchGroup val index nativePatterngroupNameToIndexname throw IllegalArgumentExceptionCapturing group with name name does not exist return getindex A list of matched indexed group values This list has size of groupCount 1 where groupCount is the count of groups in the regular expression Groups are indexed from 1 to groupCount and group with the index 0 corresponds to the entire match If the group in the regular expression is optional and there were no match captured by that group corresponding item in groupValues is an empty string sample samplestextRegexpsmatchDestructuringToGroupValues override val groupValues ListString get mutableListOfStringapply for i in 0 until groupCount thisaddgroupi override fun next MatchResult var nextStart rangeendInclusive 1 If the current match is empty shift by 1 if nextStart rangestart nextStart if nextStart inputlength return null return regexfindinput nextStart Harmonys implementation fun setConsumedcounter Int value Int thisconsumerscounter value fun getConsumedcounter Int Int return thisconsumerscounter fun isCapturedgroup Int Boolean getStartgroup 0 Setters and getters for starts and ends of groups internal fun setStartgroup Int offset Int checkGroupgroup groupBoundsgroup 2 offset internal fun setEndgroup Int offset Int checkGroupgroup groupBoundsgroup 2 1 offset Returns the index of the first character of the text that matched a given group param group the group ranging from 0 to groupCount 1 with 0 representing the whole pattern return the character index ", "modifier": "", "signature": "fun getStart(group: Int = 0): Int", "body": "{<EOL> checkGroup(group)<EOL> return groupBounds[group * 2]<EOL> }"}
{"docstring": " Returns the index of the first character following the text that matched a given group param group the group ranging from 0 to groupCount 1 with 0 representing the whole pattern return the character index ", "modifier": "", "signature": "fun getEnd(group: Int = 0): Int", "body": "{<EOL> checkGroup(group)<EOL> return groupBounds[group * 2 + 1]<EOL> }"}
{"docstring": " Returns the text that matched a given group of the regular expression param group the group ranging from 0 to groupCount 1 with 0 representing the whole pattern return the text that matched the group fun groupgroup Int 0 String val start getStartgroup val end getEndgroup if start 0 end 0 return null return inputsubSequencegetStartgroup getEndgrouptoString Returns the number of groups in the result which is always equal to the number of groups in the original regular expression return the number of groups ", "modifier": "", "signature": "fun groupCount(): Int", "body": "{<EOL> return groupCount - 1<EOL> }"}
{"docstring": " User defined character classes eg abef TODO replace the implementation with one using BitSet for first 256 symbols and a hash table tree for the rest of UTFOptInObsoleteNativeApiclassinternal class CharClassval ignoreCase Boolean false negative Boolean false AbstractCharClass var invertedSurrogates false Shows if the alt flags was inverted during the range construction process Eg consider the following range D3 Here we firstly add the D char class which has the alt flag set into a resulting char set After that the resulting char also has the alt flag set But then we need to add the 3 character into this class with positive sense So we set the inverted flag to show that the range is not negative by itself but was inverted during some transformations var inverted false var hideBits false internal var bits_ BitSet override val bits BitSet get if hideBits return null return bits_ var nonBitSet AbstractCharClass null private val IntasciiSupplement Int get when this in atoIntztoInt this 32 this in AtoIntZtoInt this 32 else this private val IntisSurrogate Boolean get this in CharMIN_SURROGATEtoIntCharMAX_SURROGATEtoInt init setNegativenegative We can use this method safely even if nonBitSet null due to specific of range constructions in regular expressions OptInExperimentalNativeApiclass fun addch Int CharClass var character ch if ignoreCase if charactertoChar in az charactertoChar in AZ bits_setcharacterasciiSupplement inverted else if character 128 character ChartoLowerCaseChartoUpperCasecharacter if charactertoCharisSurrogate lowHighSurrogatessetcharacter CharMIN_SURROGATEtoInt invertedSurrogates bits_setcharacter inverted if mayContainSupplCodepoints CharisSupplementaryCodePointch mayContainSupplCodepoints true return this fun addch Char CharClass addchtoInt The difference between addAbstractCharClass and unionAbstractCharClass is that add is used for constructions like abcd this pattern doesnt match 1 while union is used for constructions like abcd this pattern matches 1 ", "modifier": "", "signature": "fun add(another: AbstractCharClass): CharClass", "body": "{<EOL><EOL> if (!mayContainSupplCodepoints && another.mayContainSupplCodepoints) {<EOL> mayContainSupplCodepoints = true<EOL> }"}
{"docstring": " Represents a compiled pattern used by Regex for matching searching or replacing strings internal class Patternval pattern String flags Int 0 var flags flags private set A lexer instance used to get tokens from the pattern private val lexemes Lexerpattern flags List of all capturing groups in the pattern Primarily used for handling back references val capturingGroups mutableListOfFSet Mapping from group name to its index val groupNameToIndex hashMapOfString Int Is true if back referenced sets replacement by second compilation pass is needed private var needsBackRefReplacement false A number of group quantifiers in the pattern var groupQuantifierCount 0 private set A number of consumers found in the pattern Consumer is any expression ending with an FSet except capturing groups they are counted by capturingGroups var consumersCount 0 private set A node to start a matchingsearching process by call startNodematchesstartNodefind internal val startNode AbstractSet Compiles the given pattern init if flags 0 flags or flagsBitMask flagsBitMask throw IllegalArgumentExceptionInvalid match flags value startNode processExpression1 thisflags null if lexemesisEmpty throw PatternSyntaxExceptionTrailing characters pattern lexemescurTokenIndex Finalize compilation if needsBackRefReplacement startNodeprocessSecondPass override fun toString String pattern Return true if the pattern has the specified flag private fun hasFlagflag Int Boolean flags and flag flag Compilation methods Aa ", "modifier": "private ", "signature": "fun processAlternations(last: AbstractSet): AbstractSet", "body": "{<EOL> val auxRange = CharClass(hasFlag(Pattern.CASE_INSENSITIVE))<EOL> while (!lexemes.isEmpty() && lexemes.isLetter()<EOL> && (lexemes.lookAhead == 0<EOL> || lexemes.lookAhead == Lexer.CHAR_VERTICAL_BAR<EOL> || lexemes.lookAhead == Lexer.CHAR_RIGHT_PARENTHESIS)) {<EOL> auxRange.add(lexemes.next())<EOL> if (lexemes.currentChar == Lexer.CHAR_VERTICAL_BAR) {<EOL> lexemes.next()<EOL> }"}
{"docstring": " EAE ESE ES Aa ESS ", "modifier": "private ", "signature": "fun processExpression(ch: Int, newFlags: Int, last: AbstractSet?): AbstractSet", "body": "{<EOL> val children = ArrayList<AbstractSet>()<EOL> val savedFlags = flags<EOL> var saveChangedFlags = false<EOL><EOL> if (newFlags != flags) {<EOL> flags = newFlags<EOL> }"}
{"docstring": " Taaa OptInExperimentalNativeApiclass private fun processSequence AbstractSet val substring StringBuilder while lexemesisEmpty lexemesisLetter lexemesisSurrogate lexemesisNextSpecial lexemeslookAhead 0 End of a pattern lexemesisNextSpecial LexerisLetterlexemeslookAhead lexemeslookAhead LexerCHAR_RIGHT_PARENTHESIS lexemeslookAhead and 0x8000fffftoInt LexerCHAR_LEFT_PARENTHESIS lexemeslookAhead LexerCHAR_VERTICAL_BAR lexemeslookAhead LexerCHAR_DOLLAR val ch lexemesnext if CharisSupplementaryCodePointch substringappendChartoCharsch else substringappendchtoChar return SequenceSetsubstring hasFlagCASE_INSENSITIVE Da ", "modifier": "private ", "signature": "fun processDecomposedChar(): AbstractSet", "body": "{<EOL> val codePoints = IntArray(Lexer.MAX_DECOMPOSITION_LENGTH)<EOL> val codePointsHangul: CharArray<EOL> var readCodePoints = 0<EOL> var curSymb = -1<EOL> var curSymbIndex = -1<EOL><EOL> if (!lexemes.isEmpty() && lexemes.isLetter()) {<EOL> curSymb = lexemes.next()<EOL> codePoints[readCodePoints] = curSymb<EOL> curSymbIndex = curSymb - Lexer.LBase<EOL> }"}
{"docstring": " SBS SQS SQ Ba ", "modifier": "private ", "signature": "fun processSubExpression(last: AbstractSet): AbstractSet", "body": "{<EOL> var cur: AbstractSet<EOL> when {<EOL> lexemes.isLetter() && !lexemes.isNextSpecial && Lexer.isLetter(lexemes.lookAhead) -> {<EOL> when {<EOL> hasFlag(Pattern.CANON_EQ) -> {<EOL> cur = processDecomposedChar()<EOL> if (!lexemes.isEmpty()<EOL> && (lexemes.currentChar != Lexer.CHAR_RIGHT_PARENTHESIS || last is FinalSet)<EOL> && lexemes.currentChar != Lexer.CHAR_VERTICAL_BAR<EOL> && !lexemes.isLetter()) {<EOL><EOL> cur = processQuantifier(last, cur)<EOL> }"}
{"docstring": " QT also do some optimizations ", "modifier": "private ", "signature": "fun processQuantifier(last: AbstractSet, term: AbstractSet): AbstractSet", "body": "{<EOL> val quant = lexemes.currentChar<EOL><EOL> if (term.type == AbstractSet.TYPE_DOTSET && (quant == Lexer.QUANT_STAR || quant == Lexer.QUANT_PLUS)) {<EOL> lexemes.next()<EOL> return DotQuantifierSet(term, last, quant, AbstractLineTerminator.getInstance(flags), hasFlag(Pattern.DOTALL))<EOL> }"}
{"docstring": " T letterrangecharclassE ", "modifier": "private ", "signature": "fun processTerminal(last: AbstractSet): AbstractSet", "body": "{<EOL> val term: AbstractSet<EOL> var char = lexemes.currentChar<EOL> // Process flags: (?...)(?...)...<EOL> while (char and 0xff00ffff.toInt() == Lexer.CHAR_FLAGS) {<EOL> lexemes.next()<EOL> flags = (char shr 16) and flagsBitMask<EOL> char = lexemes.currentChar<EOL> }"}
{"docstring": " Creates a back reference to the group with specified groupIndex or throws if the group doesnt exist yet ", "modifier": "private ", "signature": "fun createBackReference(groupIndex: Int): BackReferenceSet", "body": "{<EOL> if (groupIndex >= 0 && groupIndex < capturingGroups.size) {<EOL> capturingGroups[groupIndex].isBackReferenced = true<EOL> needsBackRefReplacement = true // And process back references in the second pass.<EOL> return BackReferenceSet(groupIndex, consumersCount++, hasFlag(CASE_INSENSITIVE))<EOL> }"}
{"docstring": " Process ranges ", "modifier": "private ", "signature": "fun processRange(negative: Boolean, last: AbstractSet): AbstractSet", "body": "{<EOL> val res = processRangeExpression(negative)<EOL> val rangeSet = processRangeSet(res)<EOL> rangeSet.next = last<EOL><EOL> return rangeSet<EOL> }"}
{"docstring": " This constant specifies that a pattern matches Unix line endings n only against the and meta characters val UNIX_LINES 1 shl 0 This constant specifies that a Pattern is matched caseinsensitively That is the patterns a and A would both match the string aAaAaA val CASE_INSENSITIVE 1 shl 1 This constant specifies that a Pattern may contain whitespace or comments Otherwise comments and whitespace are taken as literal characters val COMMENTS 1 shl 2 This constant specifies that the meta characters and match only the beginning and end end of an input line respectively Normally they match the beginning and the end of the complete input val MULTILINE 1 shl 3 This constant specifies that the whole Pattern is to be taken literally that is all meta characters lose their meanings val LITERAL 1 shl 4 This constant specifies that the meta character matches arbitrary characters including line endings which is normally not the case val DOTALL 1 shl 5 This constant specifies that a character in a Pattern and a character in the input string only match if they are canonically equivalent val CANON_EQ 1 shl 6 A bit mask that includes all defined match flags internal val flagsBitMask PatternUNIX_LINES or PatternCASE_INSENSITIVE or PatternCOMMENTS or PatternMULTILINE or PatternLITERAL or PatternDOTALL or PatternCANON_EQ Quotes a given string using Q and E so that all other metacharacters lose their special meaning If the string is used for a Pattern afterwards it can only be matched literally ", "modifier": "", "signature": "fun quote(s: String): String", "body": "{<EOL> return StringBuilder()<EOL> .append(\"\\\\Q\")<EOL> .append(s.replace(\"\\\\E\", \"\\\\E\\\\\\\\E\\\\Q\"))<EOL> .append(\"\\\\E\").toString()<EOL> }"}
{"docstring": " Creates a new empty ArrayList with the specified initial capacity Capacity is the maximum number of elements the list is able to store in current backing storage When the list gets full and a new element cant be added its capacity is expanded which usually leads to creation of a bigger backing storage param initialCapacity the initial capacity of the created list Note that the argument is just a hint for the implementation and can be ignored throws IllegalArgumentException if initialCapacity is negative public actual constructorinitialCapacity Int MutableListE RandomAccess AbstractMutableListE private var backing arrayOfUninitializedElementsEinitialCapacity private var length 0 private var isReadOnly false private companion object private val Empty ArrayListNothing0also itisReadOnly true Creates a new empty ArrayList public actual constructor this10 Creates a new ArrayList filled with the elements of the specified collection The iteration order of elements in the created list is the same as in the specified collection public actual constructorelements CollectionE thiselementssize addAllelements PublishedApi internal fun build ListE checkIsMutable isReadOnly true return if length 0 this else Empty actual override val size Int get length actual override fun isEmpty Boolean length 0 actual override fun getindex Int E AbstractListcheckElementIndexindex length return backingindex actual override operator fun setindex Int element E E checkIsMutable AbstractListcheckElementIndexindex length val old backingindex backingindex element return old actual override fun indexOfelement E Int var i 0 while i length if backingi element return i i return 1 actual override fun lastIndexOfelement E Int var i length 1 while i 0 if backingi element return i i return 1 actual override fun iterator MutableIteratorE listIterator0 actual override fun listIterator MutableListIteratorE listIterator0 actual override fun listIteratorindex Int MutableListIteratorE AbstractListcheckPositionIndexindex length return Itrthis index actual override fun addelement E Boolean checkIsMutable addAtInternallength element return true actual override fun addindex Int element E checkIsMutable AbstractListcheckPositionIndexindex length addAtInternalindex element actual override fun addAllelements CollectionE Boolean checkIsMutable val n elementssize addAllInternallength elements n return n 0 actual override fun addAllindex Int elements CollectionE Boolean checkIsMutable AbstractListcheckPositionIndexindex length val n elementssize addAllInternalindex elements n return n 0 actual override fun clear checkIsMutable removeRangeInternal0 length actual override fun removeAtindex Int E checkIsMutable AbstractListcheckElementIndexindex length return removeAtInternalindex actual override fun removeelement E Boolean checkIsMutable val i indexOfelement if i 0 removeAti return i 0 actual override fun removeAllelements CollectionE Boolean checkIsMutable return retainOrRemoveAllInternal0 length elements false 0 actual override fun retainAllelements CollectionE Boolean checkIsMutable return retainOrRemoveAllInternal0 length elements true 0 actual override fun subListfromIndex Int toIndex Int MutableListE AbstractListcheckRangeIndexesfromIndex toIndex length return ArraySubListbacking fromIndex toIndex fromIndex null this SuppressUNCHECKED_CAST override fun T toArrayarray ArrayT ArrayT if arraysize length return backingcopyOfRangefromIndex 0 toIndex length as ArrayT backing as ArrayTcopyIntoarray 0 startIndex 0 endIndex length return terminateCollectionToArraylength array override fun toArray ArrayAny SuppressUNCHECKED_CAST return backingcopyOfRangefromIndex 0 toIndex length as ArrayAny public actual fun trimToSize registerModification if length backingsize backing backingcopyOfUninitializedElementslength public actual fun ensureCapacityminCapacity Int if minCapacity backingsize return registerModification ensureCapacityInternalminCapacity override fun equalsother Any Boolean return other this other is List contentEqualsother override fun hashCode Int return backingsubarrayContentHashCode0 length override fun toString String return backingsubarrayContentToString0 length this private private fun registerModification modCount 1 private fun checkIsMutable if isReadOnly throw UnsupportedOperationException private fun ensureExtraCapacityn Int ensureCapacityInternallength n private fun ensureCapacityInternalminCapacity Int if minCapacity 0 throw OutOfMemoryError overflow if minCapacity backingsize val newSize AbstractListnewCapacitybackingsize minCapacity backing backingcopyOfUninitializedElementsnewSize private fun contentEqualsother List Boolean return backingsubarrayContentEquals0 length other private fun insertAtInternali Int n Int ensureExtraCapacityn backingcopyIntobacking startIndex i endIndex length destinationOffset i n length n private fun addAtInternali Int element E registerModification insertAtInternali 1 backingi element private fun addAllInternali Int elements CollectionE n Int registerModification insertAtInternali n var j 0 val it elementsiterator while j n backingi j itnext j private fun removeAtInternali Int E registerModification val old backingi backingcopyIntobacking startIndex i 1 endIndex length destinationOffset i backingresetAtlength 1 length return old private fun removeRangeInternalrangeOffset Int rangeLength Int if rangeLength 0 registerModification backingcopyIntobacking startIndex rangeOffset rangeLength endIndex length destinationOffset rangeOffset backingresetRangefromIndex length rangeLength toIndex length length rangeLength Retains elements if retain true and removes them it retain false ", "modifier": "private ", "signature": "fun retainOrRemoveAllInternal(rangeOffset: Int, rangeLength: Int, elements: Collection<E>, retain: Boolean): Int", "body": "{<EOL> var i = 0<EOL> var j = 0<EOL> while (i < rangeLength) {<EOL> if (elements.contains(backing[rangeOffset + i]) == retain) {<EOL> backing[rangeOffset + j++] = backing[rangeOffset + i++]<EOL> }"}
{"docstring": " Retains elements if retain true and removes them it retain false ", "modifier": "private ", "signature": "fun retainOrRemoveAllInternal(rangeOffset: Int, rangeLength: Int, elements: Collection<E>, retain: Boolean): Int", "body": "{<EOL> val removed =<EOL> if (parent != null) {<EOL> parent.retainOrRemoveAllInternal(rangeOffset, rangeLength, elements, retain)<EOL> }"}
{"docstring": " Provides Base64 encoding and decoding functionality This class is not supposed to be instantiated or inherited However predefined instances of this class are available for use The companion object Base64Default is the default instance of Base64 There are also Base64UrlSafe and Base64Mime instances SinceKotlin18ExperimentalEncodingApipublic open class Base64 private constructor internal val isUrlSafe Boolean internal val isMimeScheme Boolean init requireisUrlSafe isMimeScheme Encodes bytes from the specified source array or its subrange Returns a ByteArray containing the resulting symbols If the size of the source array or its subrange is not an integral multiple of 3 the result is padded with to an integral multiple of 4 symbols Each resulting symbol occupies one byte in the returned byte array Use encode to get the output in string form param source the array to encode bytes from param startIndex the beginning inclusive of the subrange to encode 0 by default param endIndex the end exclusive of the subrange to encode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex return a ByteArray with the resulting symbols ", "modifier": "public ", "signature": "fun encodeToByteArray(source: ByteArray, startIndex: Int = 0, endIndex: Int = source.size): ByteArray", "body": "{<EOL> return platformEncodeToByteArray(source, startIndex, endIndex)<EOL> }"}
{"docstring": " Encodes bytes from the specified source array or its subrange and writes resulting symbols into the destination array Returns the number of symbols written If the size of the source array or its subrange is not an integral multiple of 3 the result is padded with to an integral multiple of 4 symbols param source the array to encode bytes from param destination the array to write symbols into param destinationOffset the starting index in the destination array to write symbols to 0 by default param startIndex the beginning inclusive of the subrange to encode 0 by default param endIndex the end exclusive of the subrange to encode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex throws IndexOutOfBoundsException when the resulting symbols dont fit into the destination array starting at the specified destinationOffset or when that index is out of the destination array indices range return the number of symbols written into destination array ", "modifier": "public ", "signature": "fun encodeIntoByteArray(\n        source: ByteArray,\n        destination: ByteArray,\n        destinationOffset: Int = 0,\n        startIndex: Int = 0,\n        endIndex: Int = source.size\n    ): Int", "body": "{<EOL> return platformEncodeIntoByteArray(source, destination, destinationOffset, startIndex, endIndex)<EOL> }"}
{"docstring": " Encodes bytes from the specified source array or its subrange Returns a string with the resulting symbols If the size of the source array or its subrange is not an integral multiple of 3 the result is padded with to an integral multiple of 4 symbols Use encodeToByteArray to get the output in ByteArray form param source the array to encode bytes from param startIndex the beginning inclusive of the subrange to encode 0 by default param endIndex the end exclusive of the subrange to encode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex return a string with the resulting symbols ", "modifier": "public ", "signature": "fun encode(source: ByteArray, startIndex: Int = 0, endIndex: Int = source.size): String", "body": "{<EOL> return platformEncodeToString(source, startIndex, endIndex)<EOL> }"}
{"docstring": " Encodes bytes from the specified source array or its subrange and appends resulting symbols to the destination appendable Returns the destination appendable If the size of the source array or its subrange is not an integral multiple of 3 the result is padded with to an integral multiple of 4 symbols param source the array to encode bytes from param destination the appendable to append symbols to param startIndex the beginning inclusive of the subrange to encode 0 by default param endIndex the end exclusive of the subrange to encode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex return the destination appendable public fun A Appendable encodeToAppendable source ByteArray destination A startIndex Int 0 endIndex Int sourcesize A val stringResult platformEncodeToStringsource startIndex endIndex destinationappendstringResult return destination Decodes symbols from the specified source array or its subrange Returns a ByteArray containing the resulting bytes The symbols for decoding are not required to be padded However if there is a padding character present the correct amount of padding characters must be present The padding character is interpreted as the end of the encoded byte data Subsequent symbols are prohibited param source the array to decode symbols from param startIndex the beginning inclusive of the subrange to decode 0 by default param endIndex the end exclusive of the subrange to decode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex throws IllegalArgumentException when the symbols for decoding are padded incorrectly or there are extra symbols after the padding return a ByteArray with the resulting bytes ", "modifier": "public ", "signature": "fun decode(source: ByteArray, startIndex: Int = 0, endIndex: Int = source.size): ByteArray", "body": "{<EOL> checkSourceBounds(source.size, startIndex, endIndex)<EOL><EOL> val decodeSize = decodeSize(source, startIndex, endIndex)<EOL> val destination = ByteArray(decodeSize)<EOL><EOL> val bytesWritten = decodeImpl(source, destination, 0, startIndex, endIndex)<EOL><EOL> check(bytesWritten == destination.size)<EOL><EOL> return destination<EOL> }"}
{"docstring": " Decodes symbols from the specified source array or its subrange and writes resulting bytes into the destination array Returns the number of bytes written The symbols for decoding are not required to be padded However if there is a padding character present the correct amount of padding characters must be present The padding character is interpreted as the end of the encoded byte data Subsequent symbols are prohibited param source the array to decode symbols from param destination the array to write bytes into param destinationOffset the starting index in the destination array to write bytes to 0 by default param startIndex the beginning inclusive of the subrange to decode 0 by default param endIndex the end exclusive of the subrange to decode size of the source array by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source array indices throws IllegalArgumentException when startIndex endIndex throws IndexOutOfBoundsException when the resulting bytes dont fit into the destination array starting at the specified destinationOffset or when that index is out of the destination array indices range throws IllegalArgumentException when the symbols for decoding are padded incorrectly or there are extra symbols after the padding return the number of bytes written into destination array ", "modifier": "public ", "signature": "fun decodeIntoByteArray(\n        source: ByteArray,\n        destination: ByteArray,\n        destinationOffset: Int = 0,\n        startIndex: Int = 0,\n        endIndex: Int = source.size\n    ): Int", "body": "{<EOL> checkSourceBounds(source.size, startIndex, endIndex)<EOL> checkDestinationBounds(destination.size, destinationOffset, decodeSize(source, startIndex, endIndex))<EOL><EOL> return decodeImpl(source, destination, destinationOffset, startIndex, endIndex)<EOL> }"}
{"docstring": " Decodes symbols from the specified source char sequence or its substring Returns a ByteArray containing the resulting bytes The symbols for decoding are not required to be padded However if there is a padding character present the correct amount of padding characters must be present The padding character is interpreted as the end of the encoded byte data Subsequent symbols are prohibited param source the char sequence to decode symbols from param startIndex the beginning inclusive of the substring to decode 0 by default param endIndex the end exclusive of the substring to decode length of the source by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source indices throws IllegalArgumentException when startIndex endIndex throws IllegalArgumentException when the symbols for decoding are padded incorrectly or there are extra symbols after the padding return a ByteArray with the resulting bytes ", "modifier": "public ", "signature": "fun decode(source: CharSequence, startIndex: Int = 0, endIndex: Int = source.length): ByteArray", "body": "{<EOL> val byteSource = platformCharsToBytes(source, startIndex, endIndex)<EOL> return decode(byteSource)<EOL> }"}
{"docstring": " Decodes symbols from the specified source char sequence or its substring and writes resulting bytes into the destination array Returns the number of bytes written The symbols for decoding are not required to be padded However if there is a padding character present the correct amount of padding characters must be present The padding character is interpreted as the end of the encoded byte data Subsequent symbols are prohibited param source the char sequence to decode symbols from param destination the array to write bytes into param destinationOffset the starting index in the destination array to write bytes to 0 by default param startIndex the beginning inclusive of the substring to decode 0 by default param endIndex the end exclusive of the substring to decode length of the source by default throws IndexOutOfBoundsException when startIndex or endIndex is out of range of source indices throws IllegalArgumentException when startIndex endIndex throws IndexOutOfBoundsException when the resulting bytes dont fit into the destination array starting at the specified destinationOffset or when that index is out of the destination array indices range throws IllegalArgumentException when the symbols for decoding are padded incorrectly or there are extra symbols after the padding return the number of bytes written into destination array ", "modifier": "public ", "signature": "fun decodeIntoByteArray(\n        source: CharSequence,\n        destination: ByteArray,\n        destinationOffset: Int = 0,\n        startIndex: Int = 0,\n        endIndex: Int = source.length\n    ): Int", "body": "{<EOL> val byteSource = platformCharsToBytes(source, startIndex, endIndex)<EOL> return decodeIntoByteArray(byteSource, destination, destinationOffset)<EOL> }"}
{"docstring": " Splits this duration into days hours minutes seconds and nanoseconds and executes the given action with these components The result of action is returned as the result of this function nanoseconds represents the whole number of nanoseconds in this duration and its absolute value is less than 1_000_000_000 seconds represents the whole number of seconds in this duration and its absolute value is less than 60 minutes represents the whole number of minutes in this duration and its absolute value is less than 60 hours represents the whole number of hours in this duration and its absolute value is less than 24 days represents the whole number of days in this duration Infinite durations are represented as either LongMAX_VALUE days or LongMIN_VALUE days depending on the sign of infinity and zeroes in the lower components public inline fun T toComponentsaction days Long hours Int minutes Int seconds Int nanoseconds Int T T contract callsInPlaceaction InvocationKindEXACTLY_ONCE return actioninWholeDays hoursComponent minutesComponent secondsComponent nanosecondsComponent Splits this duration into hours minutes seconds and nanoseconds and executes the given action with these components The result of action is returned as the result of this function nanoseconds represents the whole number of nanoseconds in this duration and its absolute value is less than 1_000_000_000 seconds represents the whole number of seconds in this duration and its absolute value is less than 60 minutes represents the whole number of minutes in this duration and its absolute value is less than 60 hours represents the whole number of hours in this duration Infinite durations are represented as either LongMAX_VALUE hours or LongMIN_VALUE hours depending on the sign of infinity and zeroes in the lower components public inline fun T toComponentsaction hours Long minutes Int seconds Int nanoseconds Int T T contract callsInPlaceaction InvocationKindEXACTLY_ONCE return actioninWholeHours minutesComponent secondsComponent nanosecondsComponent Splits this duration into minutes seconds and nanoseconds and executes the given action with these components The result of action is returned as the result of this function nanoseconds represents the whole number of nanoseconds in this duration and its absolute value is less than 1_000_000_000 seconds represents the whole number of seconds in this duration and its absolute value is less than 60 minutes represents the whole number of minutes in this duration Infinite durations are represented as either LongMAX_VALUE minutes or LongMIN_VALUE minutes depending on the sign of infinity and zeroes in the lower components public inline fun T toComponentsaction minutes Long seconds Int nanoseconds Int T T contract callsInPlaceaction InvocationKindEXACTLY_ONCE return actioninWholeMinutes secondsComponent nanosecondsComponent Splits this duration into seconds and nanoseconds and executes the given action with these components The result of action is returned as the result of this function nanoseconds represents the whole number of nanoseconds in this duration and its absolute value is less than 1_000_000_000 seconds represents the whole number of seconds in this duration Infinite durations are represented as either LongMAX_VALUE seconds or LongMIN_VALUE seconds depending on the sign of infinity and zero nanoseconds public inline fun T toComponentsaction seconds Long nanoseconds Int T T contract callsInPlaceaction InvocationKindEXACTLY_ONCE return actioninWholeSeconds nanosecondsComponent PublishedApi internal val hoursComponent Int get if isInfinite 0 else inWholeHours 24toInt PublishedApi internal val minutesComponent Int get if isInfinite 0 else inWholeMinutes 60toInt PublishedApi internal val secondsComponent Int get if isInfinite 0 else inWholeSeconds 60toInt PublishedApi internal val nanosecondsComponent Int get when isInfinite 0 isInMillis millisToNanosvalue 1_000toInt else value 1_000_000_000toInt conversion to units Returns the value of this duration expressed as a Double number of the specified unit The operation may involve rounding when the result cannot be represented exactly with a Double number An infinite duration value is converted either to DoublePOSITIVE_INFINITY or DoubleNEGATIVE_INFINITY depending on its sign ", "modifier": "public ", "signature": "fun toDouble(unit: DurationUnit): Double", "body": "{<EOL> return when (rawValue) {<EOL> INFINITE.rawValue -> Double.POSITIVE_INFINITY<EOL> NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY<EOL> else -> {<EOL> // TODO: whether it's ok to convert to Double before scaling<EOL> convertDurationUnit(value.toDouble(), storageUnit, unit)<EOL> }"}
{"docstring": " Returns the value of this duration expressed as a Long number of the specified unit If the result doesnt fit in the range of Long type it is coerced into that range LongMIN_VALUE is returned if its less than LongMIN_VALUE LongMAX_VALUE is returned if its greater than LongMAX_VALUE An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign ", "modifier": "public ", "signature": "fun toLong(unit: DurationUnit): Long", "body": "{<EOL> return when (rawValue) {<EOL> INFINITE.rawValue -> Long.MAX_VALUE<EOL> NEG_INFINITE.rawValue -> Long.MIN_VALUE<EOL> else -> convertDurationUnit(value, storageUnit, unit)<EOL> }"}
{"docstring": " Returns the value of this duration expressed as an Int number of the specified unit If the result doesnt fit in the range of Int type it is coerced into that range IntMIN_VALUE is returned if its less than IntMIN_VALUE IntMAX_VALUE is returned if its greater than IntMAX_VALUE An infinite duration value is converted either to IntMAX_VALUE or IntMIN_VALUE depending on its sign public fun toIntunit DurationUnit Int toLongunitcoerceInIntMIN_VALUEtoLong IntMAX_VALUEtoLongtoInt The value of this duration expressed as a Double number of days ExperimentalTime DeprecatedUse inWholeDays property instead or convert toDoubleDAYS if a double value is required ReplaceWithtoDoubleDurationUnitDAYS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inDays Double get toDoubleDurationUnitDAYS The value of this duration expressed as a Double number of hours ExperimentalTime DeprecatedUse inWholeHours property instead or convert toDoubleHOURS if a double value is required ReplaceWithtoDoubleDurationUnitHOURS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inHours Double get toDoubleDurationUnitHOURS The value of this duration expressed as a Double number of minutes ExperimentalTime DeprecatedUse inWholeMinutes property instead or convert toDoubleMINUTES if a double value is required ReplaceWithtoDoubleDurationUnitMINUTES DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inMinutes Double get toDoubleDurationUnitMINUTES The value of this duration expressed as a Double number of seconds ExperimentalTime DeprecatedUse inWholeSeconds property instead or convert toDoubleSECONDS if a double value is required ReplaceWithtoDoubleDurationUnitSECONDS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inSeconds Double get toDoubleDurationUnitSECONDS The value of this duration expressed as a Double number of milliseconds ExperimentalTime DeprecatedUse inWholeMilliseconds property instead or convert toDoubleMILLISECONDS if a double value is required ReplaceWithtoDoubleDurationUnitMILLISECONDS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inMilliseconds Double get toDoubleDurationUnitMILLISECONDS The value of this duration expressed as a Double number of microseconds ExperimentalTime DeprecatedUse inWholeMicroseconds property instead or convert toDoubleMICROSECONDS if a double value is required ReplaceWithtoDoubleDurationUnitMICROSECONDS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inMicroseconds Double get toDoubleDurationUnitMICROSECONDS The value of this duration expressed as a Double number of nanoseconds ExperimentalTime DeprecatedUse inWholeNanoseconds property instead or convert toDoubleNANOSECONDS if a double value is required ReplaceWithtoDoubleDurationUnitNANOSECONDS DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public val inNanoseconds Double get toDoubleDurationUnitNANOSECONDS The value of this duration expressed as a Long number of days An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeDays Long get toLongDurationUnitDAYS The value of this duration expressed as a Long number of hours An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeHours Long get toLongDurationUnitHOURS The value of this duration expressed as a Long number of minutes An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeMinutes Long get toLongDurationUnitMINUTES The value of this duration expressed as a Long number of seconds An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeSeconds Long get toLongDurationUnitSECONDS The value of this duration expressed as a Long number of milliseconds An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeMilliseconds Long get return if isInMillis isFinite value else toLongDurationUnitMILLISECONDS The value of this duration expressed as a Long number of microseconds If the result doesnt fit in the range of Long type it is coerced into that range LongMIN_VALUE is returned if its less than LongMIN_VALUE LongMAX_VALUE is returned if its greater than LongMAX_VALUE An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeMicroseconds Long get toLongDurationUnitMICROSECONDS The value of this duration expressed as a Long number of nanoseconds If the result doesnt fit in the range of Long type it is coerced into that range LongMIN_VALUE is returned if its less than LongMIN_VALUE LongMAX_VALUE is returned if its greater than LongMAX_VALUE An infinite duration value is converted either to LongMAX_VALUE or LongMIN_VALUE depending on its sign public val inWholeNanoseconds Long get val value value return when isInNanos value value LongMAX_VALUE NANOS_IN_MILLIS LongMAX_VALUE value LongMIN_VALUE NANOS_IN_MILLIS LongMIN_VALUE else millisToNanosvalue shortcuts Returns the value of this duration expressed as a Long number of nanoseconds If the value doesnt fit in the range of Long type it is coerced into that range see the conversion DoubletoLong for details The range of durations that can be expressed as a Long number of nanoseconds is approximately 292 years ExperimentalTime DeprecatedUse inWholeNanoseconds property instead ReplaceWiththisinWholeNanoseconds DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public fun toLongNanoseconds Long inWholeNanoseconds Returns the value of this duration expressed as a Long number of milliseconds The value is coerced to the range of Long type if it doesnt fit in that range see the conversion DoubletoLong for details The range of durations that can be expressed as a Long number of milliseconds is approximately 292 million years ExperimentalTime DeprecatedUse inWholeMilliseconds property instead ReplaceWiththisinWholeMilliseconds DeprecatedSinceKotlinwarningSince 15 errorSince 18 hiddenSince 19 public fun toLongMilliseconds Long inWholeMilliseconds Returns a string representation of this duration value expressed as a combination of numeric components each in its own unit Each component is a number followed by the unit abbreviated name d h m s 5h 1d 12h 1h 0m 30340s The last component usually seconds can be a number with a fractional part If the duration is less than a second it is represented as a single number with one of subsecond units ms milliseconds us microseconds or ns nanoseconds 140884ms 500us 24ns A negative duration is prefixed with sign and if it consists of multiple components surrounded with parentheses 12m and 1h 30m Special cases an infinite duration is formatted as Infinity or Infinity without a unit Its recommended to use toIsoString that uses more strict ISO8601 format instead of this toString when you want to convert a duration to a string in cases of serialization interchange etc sample samplestimeDurationstoStringDefault override fun toString String when rawValue 0L 0s INFINITErawValue Infinity NEG_INFINITErawValue Infinity else val isNegative isNegative buildString if isNegative append absoluteValuetoComponents days hours minutes seconds nanoseconds val hasDays days 0L val hasHours hours 0 val hasMinutes minutes 0 val hasSeconds seconds 0 nanoseconds 0 var components 0 if hasDays appenddaysappendd components if hasHours hasDays hasMinutes hasSeconds if components 0 append appendhoursappendh if hasMinutes hasSeconds hasHours hasDays if components 0 append appendminutesappendm if hasSeconds if components 0 append when seconds 0 hasDays hasHours hasMinutes appendFractionalseconds nanoseconds 9 s isoZeroes false nanoseconds 1_000_000 appendFractionalnanoseconds 1_000_000 nanoseconds 1_000_000 6 ms isoZeroes false nanoseconds 1_000 appendFractionalnanoseconds 1_000 nanoseconds 1_000 3 us isoZeroes false else appendnanosecondsappendns if isNegative components 1 insert1 append private fun StringBuilderappendFractionalwhole Int fractional Int fractionalSize Int unit String isoZeroes Boolean appendwhole if fractional 0 append val fracString fractionaltoStringpadStartfractionalSize 0 val nonZeroDigits fracStringindexOfLast it 0 1 when isoZeroes nonZeroDigits 3 appendRangefracString 0 nonZeroDigits else appendRangefracString 0 nonZeroDigits 2 3 3 appendunit Returns a string representation of this duration value expressed in the given unit and formatted with the specified decimals number of digits after decimal point Special cases an infinite duration is formatted as Infinity or Infinity without a unit param decimals the number of digits after decimal point to show The value must be nonnegative No more than 12 decimals will be shown even if a larger number is requested return the value of duration in the specified unit followed by that unit abbreviated name d h m s ms us or ns throws IllegalArgumentException if decimals is less than zero sample samplestimeDurationstoStringDecimals ", "modifier": "public ", "signature": "fun toString(unit: DurationUnit, decimals: Int = 0): String", "body": "{<EOL> require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }"}
{"docstring": " A base class to simplify implementing iterators so that implementations only have to implement computeNext to implement the iterator calling done when the iteration is complete public abstract class AbstractIteratorT IteratorT private var state StateNOT_READY private var nextValue T null override fun hasNext Boolean return when state StateDONE false StateREADY true StateNOT_READY tryToComputeNext else throw IllegalArgumentExceptionhasNext called when the iterator is in the FAILED state override fun next T if state StateREADY state StateNOT_READY SuppressUNCHECKED_CAST return nextValue as T if state StateDONE tryToComputeNext throw NoSuchElementException state StateNOT_READY SuppressUNCHECKED_CAST return nextValue as T private fun tryToComputeNext Boolean state StateFAILED computeNext return state StateREADY Computes the next item in the iterator This callback method should call one of these two methods setNext with the next value of the iteration done to indicate there are no more elements Failure to call either method will result in the iteration terminating with a failed state protected abstract fun computeNext Unit Sets the next value in the iteration called from the computeNext function ", "modifier": "protected ", "signature": "fun setNext(value: T): Unit", "body": "{<EOL> nextValue = value<EOL> state = State.READY<EOL> }"}
{"docstring": " Returns the first element or throws NoSuchElementException if this deque is empty public fun first E if isEmpty throw NoSuchElementExceptionArrayDeque is empty else internalGethead Returns the first element or null if this deque is empty public fun firstOrNull E if isEmpty null else internalGethead Returns the last element or throws NoSuchElementException if this deque is empty public fun last E if isEmpty throw NoSuchElementExceptionArrayDeque is empty else internalGetinternalIndexlastIndex Returns the last element or null if this deque is empty public fun lastOrNull E if isEmpty null else internalGetinternalIndexlastIndex Prepends the specified element to this deque public fun addFirstelement E registerModification ensureCapacitysize 1 head decrementedhead elementDatahead element size 1 Appends the specified element to this deque public fun addLastelement E registerModification ensureCapacitysize 1 elementDatainternalIndexsize element size 1 Removes the first element from this deque and returns that removed element or throws NoSuchElementException if this deque is empty ", "modifier": "public ", "signature": "fun removeFirst(): E", "body": "{<EOL> if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\")<EOL> registerModification()<EOL><EOL> val element = internalGet(head)<EOL> elementData[head] = null<EOL> head = incremented(head)<EOL> size -= 1<EOL> return element<EOL> }"}
{"docstring": " Removes the first element from this deque and returns that removed element or returns null if this deque is empty public fun removeFirstOrNull E if isEmpty null else removeFirst Removes the last element from this deque and returns that removed element or throws NoSuchElementException if this deque is empty ", "modifier": "public ", "signature": "fun removeLast(): E", "body": "{<EOL> if (isEmpty()) throw NoSuchElementException(\"ArrayDeque is empty.\")<EOL> registerModification()<EOL><EOL> val internalLastIndex = internalIndex(lastIndex)<EOL> val element = internalGet(internalLastIndex)<EOL> elementData[internalLastIndex] = null<EOL> size -= 1<EOL> return element<EOL> }"}
{"docstring": " Used to collect TypeRefs for printing a list of imports for those TypeRefs internal class ImportCollectorcurrentPackage String ImportCollecting companion object private val STAR sortedSetOf The maximum number of imports from a single package before collapsing those imports to a starimport private const val STAR_COLLAPSE_THRESHOLD 4 A map of package names to a list of entities to import from that package private val imports SortedMapString SortedSetString sortedMapOf Entities from these packages will not be imported explicitly See the list of default importshttpskotlinlangorgdocspackageshtmldefaultimports private val ignoredPackages hashSetOf currentPackage kotlin kotlinannotation kotlincollections kotlincomparisons kotlinio kotlinranges kotlinsequences kotlintext javalang kotlinjvm private fun addImportpackageName String entity String if packageName in ignoredPackages return val entities importscomputeIfAbsentpackageName sortedSetOf if entities STAR return if entity importspackageName STAR return entitiesaddentity if entitiessize STAR_COLLAPSE_THRESHOLD importspackageName STAR override fun addImportimportable Importable addImportimportablepackageName importabletypeName Prints all the collected imports in alphabetical order return true if at least one import was printed false if no imports were printed ", "modifier": "", "signature": "fun printAllImports(printer: Appendable): Boolean", "body": "{<EOL> var atLeastOneImport = false<EOL> for ((packageName, entities) in imports) {<EOL> for (entity in entities) {<EOL> atLeastOneImport = true<EOL> printer.append(\"import \", packageName, \".\", entity, \"\\n\")<EOL> }"}
{"docstring": " returns true means that line contain directive ", "modifier": "", "signature": "fun parse(line: String): Boolean", "body": "{<EOL> val rawDirective = parseDirective(line) ?: return false<EOL> val parsedDirective = convertToRegisteredDirective(rawDirective) ?: return false<EOL> addParsedDirective(parsedDirective)<EOL> return true<EOL> }"}
{"docstring": " return list of all declarations from compiled source module which are matched to predicate abstract fun getSymbolsByPredicatepredicate LookupPredicate ListFirBasedSymbol return list of all parents of declaration abstract fun getOwnersOfDeclarationdeclaration FirDeclaration ListFirBasedSymbol return true if file has a toplevel annotation from the FirRegisteredPluginAnnotationsannotations list see FirRegisteredPluginAnnotationsannotations abstract fun fileHasPluginAnnotationsfile FirFile Boolean return if declaration matches predicate or not abstract fun matchespredicate AbstractPredicate declaration FirDeclaration Boolean return if declaration matches predicate or not ", "modifier": "", "signature": "fun matches(predicate: AbstractPredicate<*>, declaration: FirBasedSymbol<*>): Boolean", "body": "{<EOL> return matches(predicate, declaration.fir)<EOL> }"}
{"docstring": " return if declaration matches any predicate from predicates or not ", "modifier": "", "signature": "fun matches(predicates: List<AbstractPredicate<*>>, declaration: FirDeclaration): Boolean", "body": "{<EOL> return predicates.any { matches(it, declaration) }"}
{"docstring": " return if declaration matches any predicate from predicates or not ", "modifier": "", "signature": "fun matches(predicates: List<AbstractPredicate<*>>, declaration: FirBasedSymbol<*>): Boolean", "body": "{<EOL> return matches(predicates, declaration.fir)<EOL> }"}
{"docstring": " Here we only check that we are casting to a forward declaration to suppress a CAST_NEVER_SUCCEEDS warning The cast would be further checked with FirNativeForwardDeclarationTypeOperatorChecker and FirNativeForwardDeclarationGetClassCallChecker ", "modifier": "private ", "signature": "fun isCastToAForwardDeclaration(session: FirSession, forwardDeclarationType: ConeKotlinType): Boolean", "body": "{<EOL> return forwardDeclarationType.toRegularClassSymbol(session)?.forwardDeclarationKindOrNull() != null<EOL> }"}
{"docstring": " Checks if a given collection of ConeKotlinType are compatible In other words the types are compatible if its possible at all to define a type thats a subtype of all of the given types The compatibility of a given set of types concept is closely related to whether the intersection of these types is inhabited But its not identical because 1 one can manually control visibility of constructors and 2 there can be unused type parameters The compatibility check is done recursively on the given types and all type arguments passed to each corresponding type parameters For example consider the following two types ArrayListSetString ListHashSetInt The checker first checks the base types ArrayList and List and it sees no issue since ArrayList List Next it checks the type parameters bound to these base types T1 in ArrayListT1 and T2 in ListT2 For T1 there is only one bound type argument SetString so its good For T2 there are two bound type arguments SetString and HashSetInt Now the checker recursively checks whether these two types are compatible Again it first checks the base type Set and HashSet and it finds no problem since HashSet Set Finally checks the type arguments String and Int that are bound to T in SetT They are incompatible since String and Int are unrelated classes The above example only goes over covariant type arguments For contravariant types the checker simply checks whether the range formed by covariant and contravariant bounds is empty For example a range like Collection List is empty and hence invalid because List is not a super classinterface of Collection object ConeTypeCompatibilityChecker private val javaClassClassId ClassIdfromStringjavalangClass private val kotlinClassClassId ClassIdfromStringkotlinreflectKClass The result returned by ConeTypeCompatibilityChecker Note the order of enum entries matters enum class Compatibility ComparableCompatibility The given types are fully compatible COMPATIBLE The given types may not be compatible But the compiler would allow such comparisons SOFT_INCOMPATIBLE The given types are definitely incompatible If the established contracts of Kotlin code are respected values of the given types can never be considered equal HARD_INCOMPATIBLE fun ConeInferenceContextisCompatiblea ConeKotlinType b ConeKotlinType Compatibility Dont report explicit comparison with Nothing if aisNothing bisNothing return CompatibilityCOMPATIBLE if a is ConeIntersectionType return aintersectedTypesminOf isCompatibleit b if b is ConeIntersectionType return bintersectedTypesminOf isCompatiblea it return when val intersectionType intersectTypesOrNulllistOfa b is ConeIntersectionType intersectionTypeintersectedTypesgetCompatibilitythis else if intersectionTypeisNothing true CompatibilityHARD_INCOMPATIBLE else CompatibilityCOMPATIBLE private fun CollectionConeKotlinTypegetCompatibilityctx ConeInferenceContext Compatibility If all types are nullable then null makes the given types compatible if all withctx itisNullableType return CompatibilityCOMPATIBLE Next can simply focus on the type hierarchy and dont need to worry about nullability val compatibilityUpperBound when all itisConcreteType CompatibilityHARD_INCOMPATIBLE If any type is not concrete for example type parameter we only report warning for incompatible types This is to stay compatible with FE10 else CompatibilitySOFT_INCOMPATIBLE return ctxgetCompatibilityflatMap itcollectUpperBounds toSet emptySet compatibilityUpperBound private fun ConeKotlinTypeisConcreteType Boolean return when this is ConeClassLikeType true is ConeDefinitelyNotNullType originalisConcreteType is ConeIntersectionType intersectedTypesall itisConcreteType else false param compatibilityUpperBound the max compatibility result that can be returned by this method For example if this is set to CompatibilitySOFT_INCOMPATIBLE then even if the given bounds dont match the hard way for example incompatible primitives the method should still return CompatibilitySOFT_INCOMPATIBLE This is useful for checking type parameters since we dont want to dictate what semantics a type parameter may have in user code In other words if user wants to compare MyCustomout String with MyCustomout Int we let them do so since we do not know what class MyCustom uses the type parameter for Empty containers are another example emptyListInt emptyListString private fun ConeInferenceContextgetCompatibility upperBounds SetConeClassLikeType lowerBounds SetConeClassLikeType compatibilityUpperBound Compatibility checkedTypeParameters MutableSetFirTypeParameterSymbol mutableSetOf Compatibility val upperBoundClasses SetFirClassWithSuperClasses upperBoundsmapNotNull ittoFirClassWithSuperClassesthis toSet Following if condition is an optimization if we ignore the subtyping relation and treat all upper bounds as unrelated classesinterfaces yet the types are deemed compatible for sure then we just bail out early if lowerBoundsisEmpty upperBoundssize 2 thisareClassesOrInterfacesCompatibleupperBoundClasses compatibilityUpperBound CompatibilityCOMPATIBLE return CompatibilityCOMPATIBLE TODO Due to KT49358 we skip any checks on Java and Kotlin refection class if upperBoundsany itclassId javaClassClassId itclassId kotlinClassClassId return CompatibilityCOMPATIBLE val leafClassesOrInterfaces computeLeafClassesOrInterfacesupperBoundClasses thisareClassesOrInterfacesCompatibleleafClassesOrInterfaces compatibilityUpperBoundlet return it Check if the range formed by upper bounds and lower bounds is empty if lowerBoundsall lowerBoundType val classesSatisfyingLowerBounds lowerBoundTypetoFirClassWithSuperClassesthisthisAndAllSuperClasses emptySet leafClassesOrInterfacesall it in classesSatisfyingLowerBounds return compatibilityUpperBound if upperBoundssize 2 return CompatibilityCOMPATIBLE Base types are compatible Now we check type parameters val typeArgumentMapping mutableMapOfFirTypeParameterSymbol BoundTypeArgumentsapply for type in upperBounds collectTypeArgumentMappingtype thisgetCompatibility compatibilityUpperBound var result CompatibilityCOMPATIBLE val typeArgsCompatibility typeArgumentMappingasSequence map paramRef boundTypeArguments val upper lower compatibility boundTypeArguments if paramRef in checkedTypeParameters if we are already checking this type parameter simply bail out to prevent infinite recursion CompatibilityCOMPATIBLE else checkedTypeParametersaddparamRef getCompatibilityupper lower compatibility checkedTypeParameters for compatibility in typeArgsCompatibility if compatibility compatibilityUpperBound return compatibility if compatibility result result compatibility return result Puts the upper bound classes into the class hierarchy and count hows many subclasses are there for each encountered class Then output a list of leaf classes or interfaces in the class hierarchy private fun computeLeafClassesOrInterfacesupperBoundClasses SetFirClassWithSuperClasses SetFirClassWithSuperClasses val isLeaf mutableMapOfFirClassWithSuperClasses Boolean upperBoundClassesassociateWithToisLeaf true implementation of keysToMap actually ends up creating 2 maps so this is better val queue ArrayDequeupperBoundClasses while queueisNotEmpty for superClass in queueremoveFirstsuperClasses when isLeafsuperClass true isLeafsuperClass false false nothing to be done since this super class has already been handled else isLeafsuperClass false queueaddLastsuperClass return isLeaffilterValues it keys Checks whether the given classes are compatible In other words check if its possible for objects of the given classes to be considered equal by Anyequals return null if this check is inconclusive private fun ConeInferenceContextareClassesOrInterfacesCompatible classesOrInterfaces CollectionFirClassWithSuperClasses compatibilityUpperBound Compatibility Compatibility val classes classesOrInterfacesfilter itisInterface Java force single inheritance so any pair of unrelated classes are incompatible if classessize 2 return if classesany itgetHasPredefinedEqualityContractthis compatibilityUpperBound else CompatibilitySOFT_INCOMPATIBLE val finalClass classesfirstOrNull itisFinal return null One final class and some other unrelated interface are not compatible if classesOrInterfacessize classessize return if finalClassgetHasPredefinedEqualityContractthis compatibilityUpperBound else CompatibilitySOFT_INCOMPATIBLE return null private fun ConeKotlinTypecollectLowerBounds SetConeClassLikeType if this null return emptySet return when this is ConeErrorType emptySet Ignore error types is ConeLookupTagBasedType when this is ConeClassLikeType setOfthis is ConeTypeParameterType emptySet else errormissing branch for javaClassname is ConeTypeVariableType emptySet is ConeDefinitelyNotNullType originalcollectLowerBounds is ConeIntersectionType intersectedTypesflatMap itcollectLowerBounds toSet is ConeFlexibleType lowerBoundcollectLowerBounds is ConeCapturedType constructorsupertypesflatMap itcollectLowerBounds toSetorEmpty is ConeIntegerConstantOperatorType setOfgetApproximatedType is ConeStubType is ConeIntegerLiteralConstantType errorthis should not reach here For each type parameters appeared in the class hierarchy collect all type arguments that eventually mapped to it For example given type ListString the returned map contains type parameter of List upperString lower type parameter of Collection upperString lower type parameter of Iterable upperString lower If later CollectionInt is passed to this method with the same receiver map the receiver map would become type parameter of List upperString lower type parameter of Collection upperString Int lower type parameter of Iterable upperString Int lower private fun MutableMapFirTypeParameterSymbol BoundTypeArgumentscollectTypeArgumentMapping coneType ConeClassLikeType ctx ConeInferenceContext compatibilityUpperBound Compatibility val queue ArrayDequeTypeArgumentMapping queueaddLastconeTypetoTypeArgumentMappingctx return while queueisNotEmpty val typeParameterOwner mapping queueremoveFirst val superTypes typeParameterOwnergetSuperTypes for superType in superTypes queueaddLastsuperTypetoTypeArgumentMappingctx mapping continue for firTypeParameterRef boundTypeArgument in mapping thiscollectctx typeParameterOwner firTypeParameterRef boundTypeArgument compatibilityUpperBound Converts type arguments in a ConeClassLikeType to a TypeArgumentMapping private fun ConeClassLikeTypetoTypeArgumentMapping ctx ConeInferenceContext envMapping MapFirTypeParameterSymbol BoundTypeArgument emptyMap TypeArgumentMapping val typeParameterOwner getClassLikeElementctx return null val mapping buildMapFirTypeParameterSymbol BoundTypeArgument typeArgumentsforEachIndexed index coneTypeProjection val typeParameter typeParameterOwnergetTypeParameterindex returnforEachIndexed var boundTypeArgument BoundTypeArgument when coneTypeProjection Ignore star since it doesnt provide any constraints ConeStarProjection returnforEachIndexed Ignore contravariant projection because they induces union types Hence whatever type argument should always be considered compatible is ConeKotlinTypeProjectionIn BoundTypeArgumentconeTypeProjectiontype VarianceIN_VARIANCE is ConeKotlinTypeProjectionOut BoundTypeArgumentconeTypeProjectiontype VarianceOUT_VARIANCE is ConeKotlinTypeConflictingProjection BoundTypeArgumentconeTypeProjectiontype VarianceINVARIANT is ConeKotlinType when typeParametervariance VarianceIN_VARIANCE BoundTypeArgumentconeTypeProjectiontype VarianceIN_VARIANCE VarianceOUT_VARIANCE BoundTypeArgumentconeTypeProjectiontype VarianceOUT_VARIANCE else BoundTypeArgumentconeTypeProjectiontype VarianceINVARIANT val coneKotlinType boundTypeArgumenttype if coneKotlinType is ConeTypeParameterType val envTypeParameter coneKotlinTypelookupTagtypeParameterSymbol val envTypeArgument envMappingenvTypeParameter if envTypeArgument null boundTypeArgument envTypeArgument puttypeParameter boundTypeArgument return TypeArgumentMappingtypeParameterOwner mapping private fun MutableMapFirTypeParameterSymbol BoundTypeArgumentscollect ctx ConeInferenceContext typeParameterOwner FirClassLikeSymbol parameter FirTypeParameterSymbol boundTypeArgument BoundTypeArgument compatibilityUpperBound Compatibility computeIfAbsentparameter the semantic of type parameter in Enum and KClass are fixed values of types with incompatible type parameters are always incompatible val compatibilityUpperBoundForTypeArg if ctxprohibitComparisonOfIncompatibleEnums typeParameterOwnerclassId StandardClassIdsEnum ctxprohibitComparisonOfIncompatibleClasses typeParameterOwnerclassId StandardClassIdsKClass compatibilityUpperBound else CompatibilitySOFT_INCOMPATIBLE BoundTypeArgumentsmutableSetOf mutableSetOf compatibilityUpperBoundForTypeArg let val type boundTypeArgumenttype if boundTypeArgumentvarianceallowsInPosition itlower typecollectLowerBounds if boundTypeArgumentvarianceallowsOutPosition itupper typecollectUpperBounds private fun FirClassLikeSymbolgetSuperTypes ListConeClassLikeType return when this is FirTypeAliasSymbol listOfNotNullresolvedExpandedTypeRefconeTypeSafe is FirClassSymbol resolvedSuperTypeRefsmapNotNull itconeTypeSafe else emptyList private fun ConeClassLikeTypegetClassLikeElementctx ConeInferenceContext FirClassLikeSymbol ctxsymbolProvidergetSymbolByLookupTaglookupTag private fun FirClassLikeSymbolgetTypeParameterindex Int FirTypeParameterSymbol return when this is FirTypeAliasSymbol typeParameterSymbolsindex is FirClassSymbol typeParameterSymbolsindex else return null A class declaration and the arguments bound to the declared type parameters private data class TypeArgumentMapping val typeParameterOwner FirClassLikeSymbol val mapping MapFirTypeParameterSymbol BoundTypeArgument A single bound type argument to a type parameter declared in a class private data class BoundTypeArgumentval type ConeKotlinType val variance Variance Accumulated type arguments bound to a type parameter declared in a class private data class BoundTypeArguments val upper MutableSetConeClassLikeType val lower MutableSetConeClassLikeType val compatibilityUpperBound Compatibility private fun ConeClassLikeTypetoFirClassWithSuperClassesctx ConeInferenceContext FirClassWithSuperClasses return lookupTagtoFirClassWithSuperClassesctx private fun ConeClassLikeLookupTagtoFirClassWithSuperClasses ctx ConeInferenceContext FirClassWithSuperClasses when val klass ctxsymbolProvidergetSymbolByLookupTagthis is FirTypeAliasSymbol klassfullyExpandedClassctxsessionlet FirClassWithSuperClassesit ctx is FirClassSymbol FirClassWithSuperClassesklass ctx else null private data class FirClassWithSuperClassesval firClass FirClassSymbol val ctx ConeInferenceContext val isInterface Boolean get firClassisInterface val superClasses SetFirClassWithSuperClasses by lazy firClassresolvedSuperTypesmapNotNull it as ConeClassLikeTypelookupTagtoFirClassWithSuperClassesctx toSet val thisAndAllSuperClasses SetFirClassWithSuperClasses by lazy val queue ArrayDequeFirClassWithSuperClasses queueaddLastthis buildSet addthisFirClassWithSuperClasses while queueisNotEmpty val current queueremoveFirst val superTypes currentsuperClasses superTypesfilterNotToqueue it in thisbuildSet addAllsuperTypes val isFinal Boolean get firClassisFinal The following are considered to have a predefined equality contract enums primitives including unsigned integer types classes strings objects of data classes objects of inline classes kotlinUnit ", "modifier": "", "signature": "fun getHasPredefinedEqualityContract(ctx: ConeInferenceContext): Boolean", "body": "{<EOL> return (ctx.prohibitComparisonOfIncompatibleEnums && (firClass.isEnumClass || firClass.classId == StandardClassIds.Enum)) ||<EOL> firClass.isPrimitiveType() ||<EOL> (ctx.prohibitComparisonOfIncompatibleClasses && firClass.classId == StandardClassIds.KClass) ||<EOL> firClass.classId == StandardClassIds.String || firClass.classId == StandardClassIds.Unit ||<EOL> (firClass is FirRegularClassSymbol && (firClass.isData || firClass.isInline))<EOL> }"}
{"docstring": " Remember that we are trying to cast something of type supertype to subtype Since at runtime we can only check the class type constructor the rest of the subtype should be known statically from supertype This method reconstructs all static information that can be obtained from supertype Example 1 supertype Collection subtype List result List all arguments are inferred Example 2 supertype Any subtype List result List some arguments were not inferred replaced with ", "modifier": "", "signature": "fun findStaticallyKnownSubtype(\n    supertype: ConeKotlinType,\n    subTypeClassSymbol: FirRegularClassSymbol,\n    context: CheckerContext\n): ConeKotlinType", "body": "{<EOL> assert(!supertype.isMarkedNullable) { \"This method only makes sense for non-nullable types\" }"}
{"docstring": " This function exists because of KT65272 RestrictsSuspension object TestScope val testLambda suspend TestScope Unit get TODO suspend fun test TestScopetestLambda K1 K2 testLambdaTestScope K1 K2 Working K1 code now fails to compile testLambdainvokeTestScope K1 K2 It was decided to replicate K1 behavior for now so function returns true when given an expression like testLambdaTestScope an implicit invoke call on a receiver of an extension function type such that the receiver argument is passed as a value argument ", "modifier": "private ", "signature": "fun isCaseMissedByK1(expression: FirFunctionCall): Boolean", "body": "{<EOL> val isInvokeFromExtensionFunctionType = expression is FirImplicitInvokeCall<EOL> && expression.explicitReceiver?.resolvedType?.isExtensionFunctionType == true<EOL><EOL> if (!isInvokeFromExtensionFunctionType) {<EOL> return false<EOL> }"}
{"docstring": " Exclusion list 1 Primary constructors of public API classes 2 Properties of data classes in public API 3 Overrides of public API Effectively this means no report on overrides at all 4 Getters and setters because getters cant change visibility and setteronly explicit visibility looks ugly 5 Properties of annotations in public API 6 Value parameter declaration 7 An anonymous function 8 A local named function ", "modifier": "private ", "signature": "fun explicitVisibilityIsNotRequired(declaration: FirMemberDeclaration, context: CheckerContext): Boolean", "body": "{<EOL> return when (declaration) {<EOL> is FirPrimaryConstructor, // 1,<EOL> is FirPropertyAccessor, // 4<EOL> is FirValueParameter, // 6<EOL> is FirAnonymousFunction -> true // 7<EOL> is FirCallableDeclaration -> {<EOL> val containingClass = context.containingDeclarations.lastOrNull() as? FirRegularClass<EOL> // 2, 5<EOL> if (declaration is FirProperty &&<EOL> containingClass != null &&<EOL> (containingClass.isData || containingClass.classKind == ClassKind.ANNOTATION_CLASS)<EOL> ) {<EOL> return true<EOL> }"}
{"docstring": " Simplified checking of subtype relation used in context receiver checkers It converts type parameters to star projections and top level type parameters to its supertypes Then it checks the relation ", "modifier": "", "signature": "fun checkSubTypes(types: List<ConeKotlinType>, context: CheckerContext): Boolean", "body": "{<EOL> fun replaceTypeParametersByStarProjections(type: ConeClassLikeType): ConeClassLikeType {<EOL> return type.withArguments(type.typeArguments.map {<EOL> when {<EOL> it.isStarProjection -> it<EOL> it.type!! is ConeTypeParameterType -> ConeStarProjection<EOL> it.type!! is ConeClassLikeType -> replaceTypeParametersByStarProjections(it.type as ConeClassLikeType)<EOL> else -> it<EOL> }"}
{"docstring": " return true if any error was reported false otherwise ", "modifier": "private ", "signature": "fun checkFunctionReferenceErrors(functionCall: FirFunctionCall): Boolean", "body": "{<EOL> val reference = functionCall.calleeReference<EOL> val diagnostic = if (reference.isError()) reference.diagnostic else return false<EOL> if (reference.source?.kind != KtFakeSourceElementKind.DelegatedPropertyAccessor) return false<EOL> val expectedFunctionSignature =<EOL> (if (isGet) \"getValue\" else \"setValue\") + \"(${functionCall.arguments.joinToString(\", \") { it.resolvedType.renderReadable() }"}
{"docstring": " The same code as in this class also exists in orgjetbrainskotlinirobjcinteropObjCOverridabilityCondition and in orgjetbrainskotlinirobjcinteropIrObjCOverridabilityCondition When modifying all three copies should be synchronized class FirNativeOverrideCheckerprivate val session FirSession FirOverrideChecker private val standardOverrideChecker FirStandardOverrideCheckersession override fun isOverriddenFunctionoverrideCandidate FirSimpleFunction baseDeclaration FirSimpleFunction Boolean overrideCandidateisPlatformOverriddenFunctionsession baseDeclaration standardOverrideCheckerisOverriddenFunctionoverrideCandidate baseDeclaration override fun isOverriddenPropertyoverrideCandidate FirCallableDeclaration baseDeclaration FirProperty Boolean KT57640 Theres no necessity to implement platformdependent overridability check for properties standardOverrideCheckerisOverriddenPropertyoverrideCandidate baseDeclaration override fun chooseIntersectionVisibility overrides CollectionFirCallableSymbol dispatchClassSymbol FirRegularClassSymbol Visibility return chooseIntersectionVisibilityOrNulloverrides itisAbstractAccordingToRawStatus itisObjCClassPropertyOrAccessorsession VisibilitiesUnknown private fun FirCallableSymbolisObjCClassPropertyOrAccessorsession FirSession this is FirPropertySymbol this is FirPropertyAccessorSymbol containingClassLookupTagtoSymbolsession as FirClassSymbolisObjCClasssession false mimics ObjCOverridabilityConditionisOverridable private fun FirSimpleFunctionisPlatformOverriddenFunctionsession FirSession baseDeclaration FirSimpleFunction Boolean if thisname baseDeclarationname return null val superInfo baseDeclarationsymboldecodeObjCMethodAnnotationsession return null val subInfo symboldecodeObjCMethodAnnotationsession return if subInfo null Overriding ObjectiveC method by ObjectiveC method in interop stubs Dont even check method signatures so this check is weaker than the standard one superInfoselector subInfoselector else Overriding ObjectiveC method by Kotlin method if parameterNamesMatchthis baseDeclaration false else null mimics ObjCInteropKtparameterNamesMatch ", "modifier": "private ", "signature": "fun parameterNamesMatch(first: FirSimpleFunction, second: FirSimpleFunction): Boolean", "body": "{<EOL> // The original Objective-C method selector is represented as<EOL> // function name and parameter names (except first).<EOL><EOL> if (first.valueParameters.size != second.valueParameters.size) {<EOL> return false<EOL> }"}
{"docstring": " Handle special cases when classifiers dont cause ambiguity Throws The following output options are possible shouldReplaceResult true isAmbiguousResult false means successful disambiguation but the previous result should be replaced with the new one typically class symbol wins typealias shouldReplaceResult false isAmbiguousResult false means successful disambiguation but the new result should be discarded shouldReplaceResult false isAmbiguousResult true means unsuccessful disambiguation and both results become irrelevant ", "modifier": "private ", "signature": "fun checkUnambiguousClassifiers(\n    foundClassifierSymbol: FirClassifierSymbol<*>,\n    newClassifierSymbol: FirClassifierSymbol<*>,\n    session: FirSession,\n): CheckUnambiguousClassifiersResult", "body": "{<EOL> val classTypealiasesThatDontCauseAmbiguity = session.platformClassMapper.classTypealiasesThatDontCauseAmbiguity<EOL><EOL> if (foundClassifierSymbol is FirTypeAliasSymbol && newClassifierSymbol is FirRegularClassSymbol &&<EOL> classTypealiasesThatDontCauseAmbiguity[newClassifierSymbol.classId] == foundClassifierSymbol.classId<EOL> ) {<EOL> return CheckUnambiguousClassifiersResult(shouldReplaceResult = true, isAmbiguousResult = false)<EOL> }"}
{"docstring": " This function provides a type for a newly created EQUALS constraint on a fresh type variable for a situation when we have an explicit type argument and type parameter is a Java type parameter without known nullability For a normal function call like fooT SomeType we create a constraint T SomeType This is an unsafe solution however yet we have to keep it otherwise a lot of code becomes red Typical strange example Java public class Foo static T T idT foo return null Kotlin fun test String return FooidStringnull OK We keep more sound constraint T SomeType for regular and SAM constructor calls Typical examples are fun test1 J1Int type should be J1Int not J1Int J1java public class J1T1 or Again type should be JString and not JString fun test1 JString x x FILE Jjava public interface JT T fooT x return type which is chosen for EQUALS constraint ", "modifier": "private ", "signature": "fun getTypePreservingFlexibilityWrtTypeVariable(\n        type: ConeKotlinType,\n        typeParameter: FirTypeParameterRef,\n        session: FirSession,\n    ): ConeKotlinType", "body": "{<EOL> val containingDeclarationSymbol = typeParameter.symbol.containingDeclarationSymbol<EOL> // To remove constructors (they use class type parameters)<EOL> return if (<EOL> containingDeclarationSymbol is FirCallableSymbol &&<EOL> // To remove SAMs<EOL> containingDeclarationSymbol !is FirSyntheticFunctionSymbol &&<EOL> typeParameter.shouldBeFlexible(session.typeContext)<EOL> ) {<EOL> when (type) {<EOL> is ConeSimpleKotlinType -> ConeFlexibleType(<EOL> type.withNullability(ConeNullability.NOT_NULL, session.typeContext),<EOL> type.withNullability(ConeNullability.NULLABLE, session.typeContext)<EOL> )<EOL> /*<EOL> * ConeFlexibleTypes have to be handled here<EOL> * at least because MapTypeArguments special-cases ConeRawTypes without explicit arguments (KT-54666)<EOL> * which allows them to get past the NoExplicitArguments optimization<EOL> * in CreateFreshTypeVariableSubstitutorStage.check<EOL> *<EOL> * (it might be safe to just return the same flexible type without explicitly enforcing flexibility,<EOL> * but better safe than sorry when dealing with raw types)<EOL> */<EOL> is ConeFlexibleType -> ConeFlexibleType(<EOL> type.lowerBound.withNullability(ConeNullability.NOT_NULL, session.typeContext),<EOL> type.upperBound.withNullability(ConeNullability.NULLABLE, session.typeContext)<EOL> )<EOL> }"}
{"docstring": " Returns true if call1 is definitely more or equally specific call2 false otherwise ", "modifier": "protected ", "signature": "fun compareCallsByUsedArguments(\n        call1: FlatSignature<Candidate>,\n        call2: FlatSignature<Candidate>,\n        discriminateGenerics: Boolean,\n        useOriginalSamTypes: Boolean\n    ): Boolean", "body": "{<EOL> if (discriminateGenerics) {<EOL> val isGeneric1 = call1.isGeneric<EOL> val isGeneric2 = call2.isGeneric<EOL> // generic loses to non-generic<EOL> if (isGeneric1 && !isGeneric2) return false<EOL> if (!isGeneric1 && isGeneric2) return true<EOL> // two generics are non-comparable<EOL> if (isGeneric1 && isGeneric2) return false<EOL> }"}
{"docstring": " call1 is not less specific than call2 ", "modifier": "private ", "signature": "fun isNotLessSpecificCallWithArgumentMapping(\n        call1: CandidateSignature,\n        call2: CandidateSignature,\n        discriminateGenerics: Boolean,\n        useOriginalSamTypes: Boolean = false\n    ): Boolean", "body": "{<EOL> return compareCallsByUsedArguments(call1, call2, discriminateGenerics, useOriginalSamTypes)<EOL> }"}
{"docstring": " This function checks whether an actual expression type is a subtype of an expected functional type in context of SAM conversion In more details this function searches for an invoke symbol inside the actual expression type and then checks compatibility of invoke symbol parameter types and return type with the corresponding functional type parameters and return type During this check type parameters inside the expected functional type are considered as compatible with everything also stub types in any positions are considered equal to anything In other aspects a normal subtype check is used ", "modifier": "private ", "signature": "fun isSubtypeForSamConversion(\n    session: FirSession,\n    scopeSession: ScopeSession,\n    actualExpressionType: ConeKotlinType,\n    classLikeExpectedFunctionType: ConeClassLikeType,\n    returnTypeCalculator: ReturnTypeCalculator\n): Boolean", "body": "{<EOL> // TODO: can we replace the function with a call of ConeKotlinType.isSubtypeOfFunctionType from FunctionalTypeUtils.kt,<EOL> // or with a call of AbstractTypeChecker.isSubtypeOf ?<EOL> // Relevant tests that can become broken:<EOL> // - codegen/box/sam/passSubtypeOfFunctionSamConversion.kt<EOL> // - diagnostics/tests/j+k/sam/recursiveSamsAndInvoke.kt<EOL> val invokeSymbol =<EOL> actualExpressionType.findContributedInvokeSymbol(<EOL> session, scopeSession, classLikeExpectedFunctionType, shouldCalculateReturnTypesOfFakeOverrides = false<EOL> ) ?: return false<EOL> // Make sure the contributed `invoke` is indeed a wanted functional type by checking if types are compatible.<EOL> val expectedReturnType = classLikeExpectedFunctionType.returnType(session).lowerBoundIfFlexible()<EOL> val returnTypeCompatible =<EOL> // TODO: can we remove is ConeTypeParameterType check here?<EOL> expectedReturnType.originalIfDefinitelyNotNullable() is ConeTypeParameterType ||<EOL> AbstractTypeChecker.isSubtypeOf(<EOL> session.typeContext.newTypeCheckerState(<EOL> errorTypesEqualToAnything = false,<EOL> stubTypesEqualToAnything = true<EOL> ),<EOL> // TODO: can we remove returnTypeCalculatorFrom here<EOL> returnTypeCalculator.tryCalculateReturnType(invokeSymbol.fir).type,<EOL> expectedReturnType,<EOL> isFromNullabilityConstraint = false<EOL> )<EOL> if (!returnTypeCompatible) {<EOL> return false<EOL> }"}
{"docstring": " Determines if type smartcasting to the specified ClassId can be performed when values are compared via equality Because this is determined using the ClassId only standard builtin types are considered ", "modifier": "private ", "signature": "fun isSmartcastPrimitive(classId: ClassId?): Boolean", "body": "{<EOL> return when (classId) {<EOL> // Support other primitives as well: KT-62246.<EOL> StandardClassIds.String,<EOL> -> true<EOL><EOL> else -> false<EOL> }"}
{"docstring": " If it appears that after completion try main expression returns nothing and try has finally block we should make edge from finally exist to try exit a dead and it may be not dead originally before completion if haveNothingReturnCall enterFinallyNodeallNormalInputsAreDead val exitFinallyNode nodepreviousNodessingle assertexitFinallyNode is FinallyBlockExitNode CFGNoderemoveAllIncomingEdgesnode addEdgeexitFinallyNode node isDead true mergeDataFlowFromPostponedLambdasnode callCompleted nodeupdateDeadStatus lastNodespushnode return node Calledinplace function graphs are effectively inlined exceptions go to enclosing function private fun levelOfNextExceptionCatchingGraph Int graphsallfirst itkind ControlFlowGraphKindAnonymousFunctionCalledInPlace exitNodelevel this is a workaround to make function call dead when call is completed _after_ building its node in the graph this happens when completing the last call in trycatch blocks returns true if node actually returned Nothing ", "modifier": "private ", "signature": "fun completeFunctionCall(node: FunctionCallNode): Boolean", "body": "{<EOL> if (!node.fir.hasNothingType) return false<EOL> val stub = StubNode(node.owner, node.level)<EOL> val edges = node.followingNodes.map { it to node.edgeTo(it) }"}
{"docstring": " Returns the smallest nonresolvable prefix of the given qualifiers Examples Given ABC and AB can be resolved then ABC will be returned Given ABC and A cannot be resolved then A will be returned Given abC and package a exists but package ab doesnt exist ab will be returned private fun smallestUnresolvablePrefix qualifiers ListFirQualifierPart partiallyResolvedTypeRef FirResolvedTypeRef ListFirQualifierPart val totalQualifierCount qualifierssize val resolvedQualifierCount partiallyResolvedTypeRefdelegatedTypeRef as FirUserTypeRefqualifiersize calculatePartiallyResolvablePackageSegmentsqualifiers val unresolvedQualifierCount totalQualifierCount resolvedQualifierCount return if unresolvedQualifierCount 1 qualifiersdropLastunresolvedQualifierCount 1 else qualifiers Tries to calculate a partially resolved type reference for a type reference which was resolved to an error type It will attempt to resolve the type with a decreasing number of qualifiers until it succeeds allowing partial resolution in case of errors in the type reference This is useful for providing better IDE support when resolving partially incorrect types param typeRef The type reference for which to try to calculate a partially resolved type reference param data The scope class declaration containing relevant information for resolving the reference return A partially resolved type reference if it was resolved or null otherwise private fun tryCalculatingPartiallyResolvedTypeReftypeRef FirTypeRef data ScopeClassDeclaration FirResolvedTypeRef if typeRef is FirUserTypeRef return null val qualifiers typeRefqualifier if qualifierssize 1 return null val qualifiersToTry qualifierstoMutableList while qualifiersToTrysize 1 qualifiersToTryremoveLast val typeRefToTry buildUserTypeRef qualifier qualifiersToTry isMarkedNullable false source typeRefsource val resolvedType diagnostic resolveTypetypeRefToTry data if resolvedType is ConeErrorType diagnostic null continue return buildResolvedTypeRef source qualifiersToTrylastsource type resolvedType delegatedTypeRef typeRefToTry return null If the given qualifiers are interpreted as a fully qualified name calculates how many segments from the left can be resolved to an existing package This is useful for providing better IDE support when resolving partially incorrect types The last segment is never considered ie if qualifiers is not empty the result is always qualifierssize ", "modifier": "private ", "signature": "fun calculatePartiallyResolvablePackageSegments(qualifiers: List<FirQualifierPart>): Int", "body": "{<EOL> if (qualifiers.size <= 1) {<EOL> return 0<EOL> }"}
{"docstring": " If loading happens in postcompute then symbol for type alias is already computed and should be provided in preComputedSymbol See AbstractFirDeserializedSymbolProviderfindAndDeserializeTypeAlias ", "modifier": "", "signature": "fun loadTypeAlias(proto: ProtoBuf.TypeAlias, preComputedSymbol: FirTypeAliasSymbol? = null): FirTypeAlias", "body": "{<EOL> val flags = proto.flags<EOL> val name = c.nameResolver.getName(proto.name)<EOL> val classId = ClassId(c.packageFqName, name)<EOL> val symbol = preComputedSymbol ?: FirTypeAliasSymbol(classId)<EOL> val local = c.childContext(proto.typeParameterList, containingDeclarationSymbol = symbol)<EOL> val versionRequirements = VersionRequirement.create(proto, c)<EOL> return buildTypeAlias {<EOL> moduleData = c.moduleData<EOL> origin = FirDeclarationOrigin.Library<EOL> this.name = name<EOL> val visibility = ProtoEnumFlags.visibility(Flags.VISIBILITY.get(flags))<EOL> status = FirResolvedDeclarationStatusImpl(<EOL> visibility,<EOL> Modality.FINAL,<EOL> visibility.toEffectiveVisibility(owner = null)<EOL> ).apply {<EOL> isExpect = Flags.IS_EXPECT_CLASS.get(flags)<EOL> isActual = false<EOL> }"}
{"docstring": " This symbol is bound to a synthetic property based on Java gettersetter call See details about such properties here httpskotlinlangorgdocsjavainterophtmlgettersandsetters Frontend IR creates this kind of symbol each time when xfoo should be resolved to xgetFoo or xsetFoo class FirSimpleSyntheticPropertySymbol propertyId CallableId getterId CallableId FirSyntheticPropertySymbolpropertyId getterId SyntheticSymbol override fun copy FirSyntheticPropertySymbol FirSimpleSyntheticPropertySymbolcallableId getterIdclass FirSyntheticFunctionSymbol callableId CallableId FirNamedFunctionSymbolcallableId SyntheticSymbolclass FirSyntheticPropertiesScope private constructor val session FirSession private val baseScope FirTypeScope private val dispatchReceiverType ConeKotlinType private val syntheticNamesProvider FirSyntheticNamesProvider private val returnTypeCalculator ReturnTypeCalculator private val isSuperCall Boolean FirContainingNamesAwareScope companion object fun createIfSyntheticNamesProviderIsDefined session FirSession dispatchReceiverType ConeKotlinType baseScope FirTypeScope returnTypeCalculator ReturnTypeCalculator null isSuperCall Boolean false FirSyntheticPropertiesScope val syntheticNamesProvider sessionsyntheticNamesProvider return null return FirSyntheticPropertiesScope session baseScope dispatchReceiverType syntheticNamesProvider returnTypeCalculator isSuperCall override fun processPropertiesByNamename Name processor FirVariableSymbol Unit val getterNames syntheticNamesProviderpossibleGetterNamesByPropertyNamename var getterFound false for getterName in getterNames baseScopeprocessFunctionsByNamegetterName checkGetAndCreateSyntheticname getterName it needCheckForSetter true processor getterFound true if getterFound shouldSearchForJavaRecordComponents baseScopeprocessFunctionsByNamename if itfirisJavaRecordComponent true checkGetAndCreateSyntheticname name it needCheckForSetter false processor private fun shouldSearchForJavaRecordComponents Boolean Fast path if dispatch receiver type is simple type and corresponding class is not a java record then there is no need to additional search for record components val dispatchSymbol dispatchReceiverTypetoRegularClassSymbolsession return true return dispatchSymbolfirisJavaRecord false override fun getCallableNames SetName baseScopegetCallableNamesflatMapTohashSetOf propertyName syntheticNamesProviderpossiblePropertyNamesByAccessorNamepropertyName override fun getClassifierNames SetName emptySet private fun checkGetAndCreateSynthetic propertyName Name getterName Name getterSymbol FirNamedFunctionSymbol needCheckForSetter Boolean processor FirVariableSymbol Unit val getter getterSymbolfir if gettertypeParametersisNotEmpty return if gettervalueParametersisNotEmpty return if getterisStatic return Should have Java among overridden _and_ dont have isHiddenEverywhereBesideSuperCalls among them val getterCompatibility deprecatedOverrideOfHidden getterSymbolcomputeGetterCompatibility if getterCompatibility Incompatible return var getterReturnType getterreturnTypeRef as FirResolvedTypeReftype if getterReturnType null needCheckForSetter During implicit body resolve phase we can encounter a reference to a not yet resolved Kotlin class that inherits a synthetic property from a Java class In that case resolve the return type here ignoring error types eg cycles getterReturnType returnTypeCalculatortryCalculateReturnTypeOrNullgettertypetakeUnless it is ConeErrorType void type is the only case when weve got notnullable nonenhanced Unit from Java And it doesnt make sense to make a synthetic property for void typed getters if getterReturnTypeisUnit true CompilerConeAttributesEnhancedNullability in getterReturnTypeattributes return var matchingSetter FirSimpleFunction null if needCheckForSetter getterReturnType null val setterName syntheticNamesProvidersetterNameByGetterNamegetterName baseScopeprocessFunctionsByNamesetterName funsetterSymbol FirNamedFunctionSymbol if matchingSetter null return val setter setterSymbolfir if settertypeParametersisNotEmpty setterisStatic return val parameter settervalueParameterssingleOrNull return if parameterisVararg return val parameterType parameterreturnTypeRef as FirResolvedTypeReftype return if setterTypeIsConsistentWithGetterTypepropertyName getterSymbol setterSymbol parameterType return matchingSetter setterSymbolfir val property buildSyntheticPropertypropertyName getter matchingSetter getterCompatibility deprecatedOverrideOfHidden getteroriginalForSubstitutionOverridelet propertyoriginalForSubstitutionOverrideAttr buildSyntheticProperty propertyName it matchingSetteroriginalForSubstitutionOverride matchingSetter getterCompatibility deprecatedOverrideOfHidden val syntheticSymbol propertysymbol baseScope as FirUnstableSmartcastTypeScopeapply if isSymbolFromUnstableSmartcastgetterSymbol markSymbolFromUnstableSmartcastsyntheticSymbol processorsyntheticSymbol private fun buildSyntheticProperty propertyName Name getter FirSimpleFunction setter FirSimpleFunction getterCompatibility SyntheticGetterCompatibility deprecatedOverrideOfHidden Boolean FirSyntheticProperty val classLookupTag gettersymboloriginalOrSelfdispatchReceiverClassLookupTagOrNull val packageName classLookupTagclassIdpackageFqName gettersymbolcallableIdpackageName val className classLookupTagclassIdrelativeClassName return buildSyntheticProperty moduleData sessionmoduleData name propertyName symbol FirSimpleSyntheticPropertySymbol getterId gettersymbolcallableId propertyId CallableIdpackageName className propertyName delegateGetter getter delegateSetter setter deprecationsProvider getDeprecationsProviderFromAccessorssession getter setter apply if getterCompatibility HasJavaOrigin noJavaOrigin true if deprecatedOverrideOfHidden thisdeprecatedOverrideOfHidden true private fun setterTypeIsConsistentWithGetterType propertyName Name getterSymbol FirNamedFunctionSymbol setterSymbol FirNamedFunctionSymbol setterParameterType ConeKotlinType Boolean val getterReturnType getterSymbolresolvedReturnTypeReftype if AbstractTypeCheckerequalTypessessiontypeContext getterReturnType setterParameterType return true if AbstractTypeCheckerisSubtypeOfsessiontypeContext getterReturnType setterParameterType return false If type of setter parameter is subtype of getter return type we need to check corresponding overridden synthetic properties from parent classes If some of them has this setter or its overridden as base for setter then current setterSymbol can be used as setter for corresponding getterSymbol See corresponding code in FE 10 in SyntheticJavaPropertyDescriptorisGoodSetMethod Note that FE 10 looks through overrides just ones by setter hierarchy but FIR does twice for setter and getter This is needed because FIR does not create fake overrides for all inherited methods of class so there may be a situation when in inheritor class only getter is overridden and setter does not have overriddens at all class Base public Object getX public Object setXObject x setterSymbol class Derived extends Base public String getX getterSymbol public fakeoverride Object setXObject x exist in FE 10 but not in FIR ", "modifier": "", "signature": "fun processOverrides(symbolToStart: FirNamedFunctionSymbol, setterSymbolToCompare: FirNamedFunctionSymbol?): Boolean", "body": "{<EOL> var hasMatchingSetter = false<EOL> baseScope.processDirectOverriddenFunctionsWithBaseScope(symbolToStart) l@{ symbol, scope -><EOL> if (hasMatchingSetter) return@l ProcessorAction.STOP<EOL> val baseDispatchReceiverType = symbol.dispatchReceiverType ?: return@l ProcessorAction.NEXT<EOL> val syntheticScope = FirSyntheticPropertiesScope(session, scope, baseDispatchReceiverType, syntheticNamesProvider, returnTypeCalculator, isSuperCall)<EOL> val baseProperties = syntheticScope.getProperties(propertyName)<EOL> val propertyFound = baseProperties.any {<EOL> val baseProperty = it.fir<EOL> baseProperty is FirSyntheticProperty && baseProperty.setter?.delegate?.symbol == (setterSymbolToCompare ?: symbol)<EOL> }"}
{"docstring": " This method computes if getter method can be used as base for synthetic property based on overridden hierarchy There are three kinds of compatibility Incompatible obvious HasJavaOrigin indicates that this getter is based on root java function ok to create property HasKotlinOrigin shows that there is no base java getter overridden Property will be created only with some LV KT64358 private fun FirNamedFunctionSymbolcomputeGetterCompatibility GetterCompatibilityResult val kotlinBaseAllowed sessionlanguageVersionSettingssupportsFeatureForbidSyntheticPropertiesWithoutBaseJavaGetter var isHiddenEverywhereBesideSuperCalls false var isDeprecatedOverrideOfHidden false var result Incompatible val visited mutableSetOfMemberWithBaseScopeFirNamedFunctionSymbol fun checkJavaOriginsymbol FirNamedFunctionSymbol scope FirTypeScope isOverridden Boolean val hidden symbolhiddenStatusOfCallisSuperCall isSuperCall isCallToOverride isOverridden when hidden CallToPotentiallyHiddenSymbolResultHidden isHiddenEverywhereBesideSuperCalls true CallToPotentiallyHiddenSymbolResultVisibleWithDeprecation isDeprecatedOverrideOfHidden true CallToPotentiallyHiddenSymbolResultVisible val overriddenWithScope scopegetDirectOverriddenFunctionsWithBaseScopesymbol if symbolorigin FirDeclarationOriginEnhancement If there is no overridden then we found java root and want to stick with it Otherwise we are in the middle of the hierarchy so leaf potentially can be from Kotlin val potentialResult when overriddenWithScopeisEmpty HasJavaOrigin kotlinBaseAllowed HasKotlinOrigin else Incompatible result maxOfresult potentialResult overriddenWithScopeforEach if visitedaddit returnforEach checkJavaOriginitmember itbaseScope isOverridden true checkJavaOriginthis baseScope isOverridden false val syntheticGetterCompatibility when isHiddenEverywhereBesideSuperCalls Incompatible result Incompatible result kotlinBaseAllowed Incompatible This branch is needed for compatibility reasons see KT64358 isJavaTypeOnThePaththisdispatchReceiverType HasKotlinOrigin else Incompatible return GetterCompatibilityResultsyntheticGetterCompatibility isDeprecatedOverrideOfHidden We should check the whole hierarchy between dispatch receiver type of found getter and our dispatch receiver type because synthetic properly should be created if there is a java class on this way KT62394 FILE Basekt abstract class Baseprivate val x String fun getFoo x FILE Intermediatejava public class Intermediate extends Base public IntermediateString x superx FILE Finalkt class Finalx String Intermediatex fun testf Final ffoo ", "modifier": "private ", "signature": "fun isJavaTypeOnThePath(baseType: ConeSimpleKotlinType?): Boolean", "body": "{<EOL> val lookupTagToStop = (baseType as? ConeLookupTagBasedType)?.lookupTag ?: return false<EOL> val dispatchReceiverClassSymbol = (dispatchReceiverType as? ConeLookupTagBasedType)?.lookupTag?.toSymbol(session) ?: return false<EOL><EOL> val typeContext = session.typeContext<EOL> fun checkType(type: ConeClassLikeType): Boolean {<EOL> val state = typeContext.newTypeCheckerState(errorTypesEqualToAnything = false, stubTypesEqualToAnything = false)<EOL> if (type.toRegularClassSymbol(session)?.isJavaOrEnhancement == true) {<EOL> if (AbstractTypeChecker.isSubtypeOfClass(state, type.lookupTag, lookupTagToStop)) {<EOL> return true<EOL> }"}
{"docstring": " See the documentation to computeConstantExpressionKind function below ", "modifier": "", "signature": "fun canBeEvaluatedAtCompileTime(\n    expression: FirExpression?,\n    session: FirSession,\n    allowErrors: Boolean,\n    calledOnCheckerStage: Boolean,\n): Boolean", "body": "{<EOL> val result = computeConstantExpressionKind(expression, session, calledOnCheckerStage)<EOL> return result == ConstantArgumentKind.VALID_CONST || allowErrors && result == ConstantArgumentKind.RESOLUTION_ERROR<EOL>}"}
{"docstring": " This function computes if given expression can be counted as a constant expression or not It returns a ConstantArgumentKind which can be used to understand why exactly the expression is not constant Precise computation of this ConstantArgumentKind may require resolution of initializer of nonconst properties which is allowed to do only on BODY_RESOLVE phase and checkers phase Without it the result may be less precise but still correct it may return the general ConstantArgumentKindNOT_CONST instead more specific ConstantArgumentKindNOT_KCLASS_LITERAL for example So to allow using this function not only from checkers there is a param calledOnCheckerStage which should be set to true ONLY if this method is called from checkers ", "modifier": "", "signature": "fun computeConstantExpressionKind(\n    expression: FirExpression?,\n    session: FirSession,\n    calledOnCheckerStage: Boolean\n): ConstantArgumentKind", "body": "{<EOL> if (expression == null) return ConstantArgumentKind.RESOLUTION_ERROR<EOL> return expression.accept(FirConstCheckVisitor(session, calledOnCheckerStage), null)<EOL>}"}
{"docstring": " Good case complexity is O1 Worst case complexity is ON where N is number of typeparameter bounds ", "modifier": "private ", "signature": "fun isEqualBound(\n        overrideBound: FirTypeRef,\n        baseBound: FirTypeRef,\n        overrideTypeParameter: FirTypeParameter,\n        baseTypeParameter: FirTypeParameter,\n        substitutor: ConeSubstitutor\n    ): Boolean", "body": "{<EOL> val substitutedOverrideType = substitutor.substituteOrSelf(overrideBound.coneType)<EOL> val substitutedBaseType = substitutor.substituteOrSelf(baseBound.coneType)<EOL><EOL> if (AbstractTypeChecker.equalTypes(context, substitutedOverrideType, substitutedBaseType)) return true<EOL><EOL> return overrideTypeParameter.symbol.resolvedBounds.any { bound -><EOL> isEqualTypes(<EOL> bound.coneType,<EOL> substitutedBaseType,<EOL> substitutor<EOL> )<EOL> }"}
{"docstring": " Without LanguageFeatureJavaTypeParameterDefaultRepresentationWithDNN enabled the check is unfortunately not symmetrical in a case when the declarations are generic DNNs are used and one of them has a flexible upper bound while the other one doesnt See compilertestDatadiagnosticstestsjkoverrideWithTypeParameterkt ", "modifier": "private ", "signature": "fun shouldDoReverseCheck(overrideCandidate: FirSimpleFunction): Boolean", "body": "{<EOL> return !session.languageVersionSettings.supportsFeature(LanguageFeature.JavaTypeParameterDefaultRepresentationWithDNN) &&<EOL> overrideCandidate.typeParameters.isNotEmpty()<EOL> }"}
{"docstring": " Its a kind of usesite scope specialized for a Java owner class Provides access to symbols by names both for declared inside Javaclass and inherited from its base classes as usual for usesite scopes all functions that are explicitly declared in a Java class are visible by default Exceptions functions that have corresponding properties functions that override renamed builtins eg charAt functions that are overrides with erased type parameters eg containsObject See isVisibleInCurrentClass Eg containsString or getint are visible as explicitly declared functions also this scope as a usesite member scope shows us some functions from supertypes Here we have two choices see collectFunctions in the fast path which is used when supertypes do not include any suspend functions AND the name is standard we dont suspect possible builtin renaming or type parameter erasing we use a standard procedure class sees all supertype functions except those overridden by explicitly declared functions in the class otherwise processSpecialFunctions comes into play It attempts to find a specific override for this erased type parameter and renamed builtin case In case of success it always creates a synthetic function and shows it as a scope part in case we have an accidental normal override like containsString or getint its hidden version is created as the synthetic function in case we dont have it we create an implicit function with such a signature containsString getint as the synthetic function class JavaClassUseSiteMemberScope private val klass FirJavaClass session FirSession superTypeScopes ListFirTypeScope declaredMemberScope FirContainingNamesAwareScope AbstractFirUseSiteMemberScope klasssymboltoLookupTag session JavaOverrideCheckersession klassjavaTypeParameterStack superTypeScopes considerReturnTypeKinds true overrideCheckerForIntersection null superTypeScopes klassdefaultType declaredMemberScope private val typeParameterStack klassjavaTypeParameterStack private val canUseSpecialGetters Boolean by lazy klasshasKotlinSupersession private val javaOverrideChecker JavaOverrideChecker get overrideChecker as JavaOverrideChecker private val syntheticPropertyCache sessionsyntheticPropertiesStoragecacheByOwnergetValueklass null private fun generateSyntheticPropertySymbol getterSymbol FirNamedFunctionSymbol setterSymbol FirNamedFunctionSymbol property FirProperty takeModalityFromGetter Boolean FirSyntheticPropertySymbol val callableId getterSymbolcallableIdwithClassIdklassclassId return buildSyntheticProperty moduleData sessionmoduleData name propertyname symbol FirJavaOverriddenSyntheticPropertySymbol getterId callableId propertyId CallableIdklassclassId propertyname delegateGetter getterSymbolfir delegateSetter setterSymbolfir status getterSymbolfirstatuscopy modality if takeModalityFromGetter delegateGettermodality propertymodality else chooseModalityForAccessorproperty delegateGetter deprecationsProvider getDeprecationsProviderFromAccessorssession delegateGetter delegateSetter dispatchReceiverType klassdefaultType symbol private fun chooseModalityForAccessorproperty FirProperty getter FirSimpleFunction Modality val a propertymodality val b gettermodality if a null return b if b null return a return minOfa b override fun collectPropertiesname Name CollectionFirVariableSymbol val fields mutableSetOfFirCallableSymbol val fieldNames mutableSetOfName val result mutableSetOfFirVariableSymbol fields declaredMemberScopeprocessPropertiesByNamename processor variableSymbol if variableSymbolisStatic returnprocessor fields variableSymbol fieldNames variableSymbolfirname result variableSymbol From supertype we can get 1 Set of properties with same name including regular and extension properties 2 Field from some java superclass only one if class have more than one superclass then we can choose just one field because this is incorrect code anyway val fromSupertypes supertypeScopeContextcollectIntersectionResultsForCallablesname FirScopeprocessPropertiesByName val fieldsFromSupertype propertiesFromSupertypes fromSupertypespartition it is ResultOfIntersectionSingleMember itchosenSymbol is FirFieldSymbol assertfieldsFromSupertypesize in 01 fieldsFromSupertypefirstOrNullchosenSymbollet fieldSymbol requirefieldSymbol is FirFieldSymbol if fieldSymbolname in fieldNames resultaddfieldSymbol SuppressUNCHECKED_CAST for overriddenProperty in propertiesFromSupertypes as ListResultOfIntersectionFirPropertySymbol val key SyntheticPropertiesCacheKey name overriddenPropertychosenSymbolreceiverParametertypeRefconeType overriddenPropertychosenSymbolresolvedContextReceiversifNotEmpty map ittypeRefconeType emptyList val overrideInClass syntheticPropertyCachegetValuekey this to overriddenProperty val chosenSymbol overrideInClass overriddenPropertychosenSymbol directOverriddenPropertieschosenSymbol listOfoverriddenProperty overriddenPropertyoverriddenMembersforEach overrideByBaseitmember overrideInClass result chosenSymbol return result internal fun syntheticPropertyFromOverrideoverriddenProperty ResultOfIntersectionFirPropertySymbol FirSyntheticPropertySymbol val overrideInClass overriddenPropertyoverriddenMembersfirstNotNullOfOrNull superMember symbol baseScope We may call this function at the STATUS phase which means that using resolved status may lead to cycle So we need to use raw status here if symbolisVisibleInClassklasssymbol symbolrawStatus returnsuperMember null symbolcreateOverridePropertyIfExistsdeclaredMemberScope takeModalityFromGetter true superTypeScopesfirstNotNullOfOrNull superScope scope if scope baseScope returnsuperScope null symbolcreateOverridePropertyIfExistsscope takeModalityFromGetter false return overrideInClass private fun FirPropertySymbolcreateOverridePropertyIfExists scope FirScope takeModalityFromGetter Boolean FirSyntheticPropertySymbol val getterSymbol thisfindGetterOverridescope return null val setterSymbol if thisfirisVar thisfindSetterOverridescope return null else null if setterSymbol null setterSymbolfirmodality getterSymbolfirmodality return null return generateSyntheticPropertySymbolgetterSymbol setterSymbol fir takeModalityFromGetter private fun FirPropertySymbolfindGetterOverride scope FirScope FirNamedFunctionSymbol val specialGetterName if canUseSpecialGetters getBuiltinSpecialPropertyGetterName else null val name specialGetterNameasString JvmAbigetterNamefirnameasString return findGetterOverridename scope private fun FirPropertySymbolfindGetterOverride getterName String scope FirScope FirNamedFunctionSymbol val propertyFromSupertype fir val expectedReturnType propertyFromSupertypereturnTypeRefconeTypeSafeConeKotlinType val receiverCount if receiverParameter null 1 else 0 resolvedContextReceiverssize return scopegetFunctionsNameidentifiergetterNamefirstNotNullOfOrNull factory candidateSymbol val candidate candidateSymbolfir if candidatevalueParameterssize receiverCount returnfactory null if checkValueParameterscandidate returnfactory null val candidateReturnType candidatereturnTypeReftoConeKotlinTypeProbablyFlexible session typeParameterStack sourcefakeElementKtFakeSourceElementKindEnhancement candidateSymboltakeIf when candidateisAcceptableAsAccessorOverride TODO Decide something for the case when property type is not computed yet expectedReturnType null AbstractTypeCheckerisSubtypeOfsessiontypeContext candidateReturnType expectedReturnType else false private fun FirPropertySymbolfindSetterOverride scope FirScope FirNamedFunctionSymbol val propertyType firreturnTypeRefconeTypeSafeConeKotlinType return null val receiverCount if receiverParameter null 1 else 0 resolvedContextReceiverssize return scopegetFunctionsNameidentifierJvmAbisetterNamefirnameasStringfirstNotNullOfOrNull factory candidateSymbol val candidate candidateSymbolfir if candidatevalueParameterssize receiverCount 1 returnfactory null if checkValueParameterscandidate returnfactory null val fakeSource sourcefakeElementKtFakeSourceElementKindEnhancement if candidatereturnTypeReftoConeKotlinTypeProbablyFlexiblesession typeParameterStack fakeSourceisUnit returnfactory null val parameterType candidatevalueParameterslastreturnTypeReftoConeKotlinTypeProbablyFlexiblesession typeParameterStack fakeSource candidateSymboltakeIf candidateisAcceptableAsAccessorOverride AbstractTypeCheckerequalTypes sessiontypeContext parameterType propertyType private fun FirPropertySymbolcheckValueParameterscandidate FirSimpleFunction Boolean var parameterIndex 0 val fakeSource sourcefakeElementKtFakeSourceElementKindEnhancement for contextReceiver in thisresolvedContextReceivers if contextReceivertypeRefconeTypecomputeJvmDescriptorRepresentation candidatevalueParametersparameterIndexreturnTypeRef toConeKotlinTypeProbablyFlexiblesession typeParameterStack fakeSource computeJvmDescriptorRepresentation return false return receiverParameter null receiverParametertypeRefconeTypecomputeJvmDescriptorRepresentation candidatevalueParametersparameterIndexreturnTypeRef toConeKotlinTypeProbablyFlexiblesession typeParameterStack fakeSource computeJvmDescriptorRepresentation private fun FirSimpleFunctionisAcceptableAsAccessorOverride Boolean We dont accept here accessors with type parameters from Kotlin to avoid strange cases like KT59038 However we temporarily see below accept accessors from Kotlin in general to keep K1 compatibility in cases like KT59550 KT59601 we are going to forbid accessors from Kotlin in general after some investigation andor deprecation period return isJavaOrEnhancement typeParametersisEmpty private fun FirPropertySymbolgetBuiltinSpecialPropertyGetterName Name var result Name null superTypeScopesprocessOverriddenPropertiesAndSelfthis overridden val fqName overriddenfircontainingClassLookupTagclassIdasSingleFqNamechildoverriddenfirname BuiltinSpecialPropertiesPROPERTY_FQ_NAME_TO_JVM_GETTER_NAME_MAPfqNamelet name result name returnprocessOverriddenPropertiesAndSelf ProcessorActionSTOP ProcessorActionNEXT return result override fun FirNamedFunctionSymbolisVisibleInCurrentClass Boolean val potentialPropertyNames getPropertyNamesCandidatesByAccessorNamename val hasCorrespondingProperty potentialPropertyNamesany propertyName getPropertiespropertyNameany l propertySymbol TODO add magic overrides from LazyJavaClassMemberScopeisVisibleAsFunctionInCurrentClass if propertySymbol is FirPropertySymbol returnl false We may call this function at the STATUS phase which means that using resolved status may lead to cycle so we need to use raw status here propertySymbolisVisibleInClassthisJavaClassUseSiteMemberScopeklasssymbol propertySymbolrawStatus propertySymbolisOverriddenInClassBythis if hasCorrespondingProperty return false return doesOverrideRenamedBuiltins shouldBeVisibleAsOverrideOfBuiltInWithErasedValueParameters private fun FirNamedFunctionSymboldoesOverrideRenamedBuiltins Boolean eg removeAt or toInt val builtinName SpecialGenericSignaturesgetBuiltinFunctionNamesByJvmNamename return false val builtinSpecialFromSuperTypes supertypeScopeContextcollectMembersGroupedByScopebuiltinName FirScopeprocessFunctionsByName flatMap scope symbols symbolsfilter itdoesOverrideBuiltinWithDifferentJvmNamescope session if builtinSpecialFromSuperTypesisEmpty return false return builtinSpecialFromSuperTypesany Here this and it have different names but its ok because override checker does not consider names of declarations at all overrideCheckerisOverriddenFunctionthisfir itfir Checks if function is a valid override of JDK analogue of builtin method with erased value parameters eg MapcontainsKeyk K Examples boolean containsKeyObject key true boolean containsKeyK key false Wrong JDK method override while its a valid Kotlin builtin override There is a case when we shouldnt hide a function even if it overrides builtin member with value parameter erasure if substituted kotlin overridden has the same parameters as current java override Such situation may happen only in case when AnyObject is used as parameterization of supertype java class MySuperMap extends javautilMapObject Object Override public boolean containsKeyObject key Override public boolean containsValueObject key In this case the signature of override made based on the correct kotlin signature will be the same because of K Any V Any substitution for both functions And since the list of all such functions is wellknown the only case when this may happen is when value parameter types of kotlin overridden are Any private fun FirNamedFunctionSymbolshouldBeVisibleAsOverrideOfBuiltInWithErasedValueParameters Boolean if namesameAsBuiltinMethodWithErasedValueParameters return false val candidatesToOverride supertypeScopeContextcollectIntersectionResultsForCallablesname FirScopeprocessFunctionsByName flatMap itoverriddenMembers filterNot member _ membervalueParameterSymbolsall itresolvedReturnTypelowerBoundIfFlexibleisAny mapNotNull member scope BuiltinMethodsWithSpecialGenericSignaturegetOverriddenBuiltinFunctionWithErasedValueParametersInJavamember scope val jvmDescriptor fircomputeJvmDescriptor return candidatesToOverrideany candidate candidatefircomputeJvmDescriptor jvmDescriptor thishasErasedParameters override fun FirNamedFunctionSymbolreplaceWithWrapperSymbolIfNeeded FirNamedFunctionSymbol if isJavaOrEnhancement return this val continuationParameter firvalueParameterslastOrNull return this val owner ownerClassLookupTagtoSymbolsessionfir as FirJavaClass return this val continuationParameterType continuationParameter returnTypeRef resolveIfJavaTypesession ownerjavaTypeParameterStack sourcefakeElementKtFakeSourceElementKindEnhancement coneTypeSafeConeKotlinType lowerBoundIfFlexible as ConeClassLikeType return this if continuationParameterTypelookupTagclassIdasSingleFqName StandardNamesCONTINUATION_INTERFACE_FQ_NAME return this return buildSimpleFunctionCopyfir valueParametersclear valueParametersaddAllfirvalueParametersdropLast1 returnTypeRef buildResolvedTypeRef type continuationParameterTypetypeArguments0type return thisreplaceWithWrapperSymbolIfNeeded status as FirDeclarationStatusImplisSuspend true symbol FirNamedFunctionSymbolcallableId symbol override fun collectFunctionsname Name CollectionFirNamedFunctionSymbol val result mutableListOfFirNamedFunctionSymbol collectDeclaredFunctionsname result val explicitlyDeclaredFunctions resulttoSet val functionsWithScopeFromSupertypes supertypeScopeContextcollectMembersGroupedByScopename FirScopeprocessFunctionsByName if namesameAsRenamedInJvmBuiltin namesameAsBuiltinMethodWithErasedValueParameters functionsWithScopeFromSupertypesall itsecondnone functionSymbol functionSymbolisSuspend Simple fast path in case of name is not suspicious ie name is not one of builtins that have different signature in Java supercollectFunctionsFromSupertypesname result explicitlyDeclaredFunctions return result processSpecialFunctionsname explicitlyDeclaredFunctions functionsWithScopeFromSupertypes result return resulttoSet private fun D FirCallableSymbol ResultOfIntersectionDextractSomeSymbolFromSuperType D return if thisisIntersectionOverride we dont want to create intersection override if some declared function actually overrides some functions from supertypes so instead of intersection override symbol we check actual symbol from supertype TODOKT65925 is it enough to check only one function keySymbol else chosenSymbol private fun processSpecialFunctions requestedName Name explicitlyDeclaredFunctionsWithNaturalName CollectionFirNamedFunctionSymbol functionsFromSupertypesWithRequestedName MembersByScopeFirNamedFunctionSymbol candidates for override destination MutableCollectionFirNamedFunctionSymbol val functionsFromSupertypesToSaveInCache mutableListOfResultOfIntersectionFirNamedFunctionSymbol The special override checker is needed for the case when were trying to consider eg explicitly defined Long toLong as an override of long toLong which is an enhanced version of long longValue K1 in such cases used LazyJavaClassMemberScopedoesOverride that ignores the return type so we reproduce the behavior here See the test testDatadiagnosticstestsjkkt62197kt and the issue KT62197 for more details TODO consider some more transparent approach val overrideCheckerForSpecialFunctions JavaOverrideCheckersession klassjavaTypeParameterStack superTypeScopes considerReturnTypeKinds false val intersectionResults supertypeScopeContextconvertGroupedCallablesToIntersectionResultsfunctionsFromSupertypesWithRequestedName for resultOfIntersectionWithNaturalName in intersectionResults val someSymbolWithNaturalNameFromSuperType resultOfIntersectionWithNaturalNameextractSomeSymbolFromSuperType val explicitlyDeclaredFunctionWithNaturalName explicitlyDeclaredFunctionsWithNaturalNamefirstOrNull overrideCheckerForSpecialFunctionsisOverriddenFunctionit someSymbolWithNaturalNameFromSuperType if processOverridesForFunctionsWithDifferentJvmName someSymbolWithNaturalNameFromSuperType explicitlyDeclaredFunctionWithNaturalName requestedName resultOfIntersectionWithNaturalName destination functionsFromSupertypesToSaveInCache continue if processOverridesForFunctionsWithErasedValueParameter requestedName destination resultOfIntersectionWithNaturalName explicitlyDeclaredFunctionWithNaturalName continue regular rules when explicitlyDeclaredFunctionWithNaturalName null val chosenSymbol resultOfIntersectionWithNaturalNamechosenSymbol if chosenSymbolisVisibleInCurrentClass continue destination chosenSymbol functionsFromSupertypesToSaveInCache resultOfIntersectionWithNaturalName else destination explicitlyDeclaredFunctionWithNaturalName directOverriddenFunctionsexplicitlyDeclaredFunctionWithNaturalName listOfresultOfIntersectionWithNaturalName for overriddenMember in resultOfIntersectionWithNaturalNameoverriddenMembers overrideByBaseoverriddenMembermember explicitlyDeclaredFunctionWithNaturalName functionsFromSupertypesrequestedName functionsFromSupertypesToSaveInCache This function collects in destination an overriding method for base method group resultOfIntersectionWithNaturalName in case base methods should have their value parameters erased in Java eg CollectioncontainsT in Kotlin is paired with CollectioncontainsObject in Java Given we have a Java class klass and some its methods name name with base method group resultOfIntersectionWithNaturalName and maybe explicitly declared explicitlyDeclaredFunctionWithNaturalName this function builds a synthetic override for resultOfIntersectionWithNaturalName in the Java class binds it with this intersection result using the override relation and collects it as a matching method with this name Important all explicitly declared functions are already collected at this point there is no reason to collect them once more param name a given method name param destination used to collect base functions for explicitlyDeclaredFunctionWithNaturalName with erased value parameters in Java param resultOfIntersectionWithNaturalName one group of intersected base methods each overridden member inside is a pair of base method its scope param explicitlyDeclaredFunctionWithNaturalName the function in the Java class klass with the name name which overrides resultOfIntersectionWithNaturalName if any return true if we collected something false otherwise see SpecialGenericSignaturesGENERIC_PARAMETERS_METHODS_TO_DEFAULT_VALUES_MAP and SpecialGenericSignaturesERASED_COLLECTION_PARAMETER_NAME_AND_SIGNATURES ", "modifier": "private ", "signature": "fun processOverridesForFunctionsWithErasedValueParameter(\n        name: Name,\n        destination: MutableCollection<FirNamedFunctionSymbol>,\n        resultOfIntersectionWithNaturalName: ResultOfIntersection<FirNamedFunctionSymbol>,\n        explicitlyDeclaredFunctionWithNaturalName: FirNamedFunctionSymbol?\n    ): Boolean", "body": "{<EOL> val membersFromSupertypesWithScopes = resultOfIntersectionWithNaturalName.overriddenMembers<EOL> // E.g. contains(String) or contains(T)<EOL> val memberFromSupertypeWithValueParametersToBeErased = membersFromSupertypesWithScopes.firstOrNull { (member, scope) -><EOL> BuiltinMethodsWithSpecialGenericSignature.getOverriddenBuiltinFunctionWithErasedValueParametersInJava(member, scope) != null<EOL> }"}
{"docstring": " See the comment to shouldBeVisibleAsOverrideOfBuiltInWithErasedValueParameters function It explains why we should check value parameters for Any type var allParametersAreAny true Its a copy like containsT or containsString in Java we perform unerasing here val declaredFunctionCopyWithParameterTypesFromSupertype buildJavaMethodCopy explicitlyDeclaredFunctionWithErasedValueParametersfir as FirJavaMethod thisname name symbol FirNamedFunctionSymbolexplicitlyDeclaredFunctionWithErasedValueParameterscallableId thisvalueParametersclear explicitlyDeclaredFunctionWithErasedValueParametersfirvalueParameterszip memberFromSupertypeWithValueParametersToBeErasedfirvalueParameters mapTothisvalueParameters overrideParameter parameterFromSupertype if parameterFromSupertypereturnTypeRefconeTypelowerBoundIfFlexibleisAny allParametersAreAny false buildJavaValueParameterCopyoverrideParameter thisbuildJavaValueParameterCopyreturnTypeRef parameterFromSupertypereturnTypeRef apply initialSignatureAttr explicitlyDeclaredFunctionWithErasedValueParametersfir symbol if allParametersAreAny return false Eg containsString from Java if any val accidentalOverrideWithDeclaredFunction explicitlyDeclaredFunctionWithNaturalNametakeIf overrideCheckerisOverriddenFunction declaredFunctionCopyWithParameterTypesFromSupertype it val symbolToBeCollected if accidentalOverrideWithDeclaredFunction null Collect synthetic function which is an unerased copy of declared one with erased parameters declaredFunctionCopyWithParameterTypesFromSupertype else val newSymbol FirNamedFunctionSymbolaccidentalOverrideWithDeclaredFunctioncallableId val original accidentalOverrideWithDeclaredFunctionfir val accidentalOverrideWithDeclaredFunctionHiddenCopy buildSimpleFunctionCopyoriginal thisname name symbol newSymbol dispatchReceiverType klassdefaultType apply initialSignatureAttr explicitlyDeclaredFunctionWithErasedValueParametersfir isHiddenToOvercomeSignatureClash true Collect synthetic function which is a hidden copy of declared one with unerased parameters accidentalOverrideWithDeclaredFunctionHiddenCopysymbol destination symbolToBeCollected directOverriddenFunctionssymbolToBeCollected listOfresultOfIntersectionWithNaturalName for member _ in membersFromSupertypesWithScopes overrideByBasemember symbolToBeCollected return true private fun FirNamedFunctionSymbolhasSameJvmDescriptor builtinWithErasedParameters FirNamedFunctionSymbol Boolean return fircomputeJvmDescriptorincludeReturnType false builtinWithErasedParametersfircomputeJvmDescriptorincludeReturnType false This function collects in destination an overriding method for base method group resultOfIntersectionWithNaturalName in case base methods should have its name changed in Java eg MutableListremoveAtInt in Kotlin is paired with Listremoveint in Java Given we have a Java class klass and some its methods name mapped to naturalName in Kotlin with base method group resultOfIntersectionWithNaturalName and maybe explicitly declared explicitlyDeclaredFunctionWithNaturalName this function builds a synthetic override for resultOfIntersectionWithNaturalName in the Java class binds it with this intersection result using the override relation and collects it as a matching method with this naturalName Important all explicitly declared functions are already collected at this point there is no reason to collect them once more param naturalName the Kotlin name of the function eg toByte get removeAt param destination used to collect base functions for explicitlyDeclaredFunctionWithNaturalName with erased value parameters in Java param resultOfIntersectionWithNaturalName one group of intersected base methods each overridden member inside is a pair of base method its scope param someSymbolWithNaturalNameFromSuperType unwrapped symbol taken from resultOfIntersectionWithNaturalName param explicitlyDeclaredFunctionWithNaturalName the function in the Java class klass with the name naturalName which overrides resultOfIntersectionWithNaturalName if any return true if we collected something false otherwise see SpecialGenericSignaturesNAME_AND_SIGNATURE_TO_JVM_REPRESENTATION_NAME_MAP and SpecialGenericSignaturesJVM_SIGNATURES_FOR_RENAMED_BUILT_INS ", "modifier": "private ", "signature": "fun processOverridesForFunctionsWithDifferentJvmName(\n        someSymbolWithNaturalNameFromSuperType: FirNamedFunctionSymbol,\n        explicitlyDeclaredFunctionWithNaturalName: FirNamedFunctionSymbol?,\n        naturalName: Name,\n        resultOfIntersectionWithNaturalName: ResultOfIntersection<FirNamedFunctionSymbol>,\n        destination: MutableCollection<FirNamedFunctionSymbol>,\n        functionsFromSupertypesToSaveInCache: MutableList<ResultOfIntersection<FirNamedFunctionSymbol>>\n    ): Boolean", "body": "{<EOL> // The JVM name of the function, e.g., byteValue or charAt<EOL> val jvmName = resultOfIntersectionWithNaturalName.overriddenMembers.firstNotNullOfOrNull {<EOL> it.member.getJvmMethodNameIfSpecial(it.baseScope, session)<EOL> }"}
{"docstring": " Creates the next Flow by joining a set of previous Flows param flows All PersistentFlows which flow into the join flow These will determine assignments and variable aliases for the resulting join flow param statementFlows A subset of flows used to determine what TypeStatements and Implications will be copied to the joined flow param union Determines if TypeStatements from different flows should be combined with union or intersection logic ", "modifier": "", "signature": "fun joinFlow(flows: Collection<PersistentFlow>, statementFlows: Collection<PersistentFlow>, union: Boolean): MutableFlow", "body": "{<EOL> when (flows.size) {<EOL> 0 -> return MutableFlow()<EOL> 1 -> return flows.first().fork()<EOL> }"}
{"docstring": " Compared to resolveToPackageOrClass does not perform the actual resolve Instead of it it just looks for the longest existing package name prefix in the fqName and assumes that the rest of the name if present is a relative class name Given that FqNameROOT package is always present in any FirSymbolProvider this function can never fail ", "modifier": "", "signature": "fun findLongestExistingPackage(symbolProvider: FirSymbolProvider, fqName: FqName): PackageAndClass", "body": "{<EOL> var currentPackage = fqName<EOL><EOL> val pathSegments = fqName.pathSegments()<EOL> var prefixSize = pathSegments.size<EOL> while (!currentPackage.isRoot && prefixSize > 0) {<EOL> if (symbolProvider.getPackage(currentPackage) != null) {<EOL> break<EOL> }"}
{"docstring": " param allowLazyDeclarationsCreation should be passed only during fakeoverride generation ", "modifier": "", "signature": "fun createAndCacheIrFunction(\n        function: FirFunction,\n        irParent: IrDeclarationParent?,\n        predefinedOrigin: IrDeclarationOrigin? = null,\n        isLocal: Boolean = false,\n        fakeOverrideOwnerLookupTag: ConeClassLikeLookupTag? = null,\n        allowLazyDeclarationsCreation: Boolean = false\n    ): IrSimpleFunction", "body": "{<EOL> val symbol = getIrFunctionSymbol(function.symbol, fakeOverrideOwnerLookupTag, isLocal) as IrSimpleFunctionSymbol<EOL> return callablesGenerator.createIrFunction(<EOL> function,<EOL> irParent,<EOL> symbol,<EOL> predefinedOrigin,<EOL> isLocal = isLocal,<EOL> fakeOverrideOwnerLookupTag = fakeOverrideOwnerLookupTag,<EOL> allowLazyDeclarationsCreation<EOL> )<EOL> }"}
{"docstring": " This function is quite messy and doesnt have a good contract of what exactly is traversed The basic idea is to traverse the symbols which can be reasonably referenced from other modules Be careful when using it and avoid it except really needed DelicateDeclarationStorageApi fun forEachCachedDeclarationSymbolblock IrSymbol Unit classCachevaluesforEach blockit typeAliasCachevaluesforEach blockit enumEntryCachevaluesforEach blockit fieldsForContextReceiversvaluesforEach fields fieldsforEach blockitsymbol private var processMembersOfClassesOnTheFlyImmediately false private fun FirTypeReftoIrTypetypeOrigin ConversionTypeOrigin ConversionTypeOriginDEFAULT IrType withtypeConverter toIrTypetypeOrigin type parameters Note declareTypeParameters should be called before internal fun preCacheTypeParametersowner FirTypeParameterRefsOwner for index typeParameter in ownertypeParameterswithIndex val original typeParametersymbolfir getCachedIrTypeParameteroriginal createAndCacheIrTypeParameteroriginal index if owner is FirProperty ownerisVar val context ConversionTypeOriginSETTER getCachedIrTypeParameteroriginal context createAndCacheIrTypeParameteroriginal index context internal fun getIrTypeParameter typeParameter FirTypeParameter index Int typeOrigin ConversionTypeOrigin ConversionTypeOriginDEFAULT IrTypeParameter getCachedIrTypeParametertypeParameter typeOriginlet return it val irTypeParameter createAndCacheIrTypeParametertypeParameter index typeOrigin classifiersGeneratorinitializeTypeParameterBoundstypeParameter irTypeParameter return irTypeParameter private fun createAndCacheIrTypeParameter typeParameter FirTypeParameter index Int typeOrigin ConversionTypeOrigin ConversionTypeOriginDEFAULT IrTypeParameter val symbol IrTypeParameterSymbolImpl val irTypeParameter classifiersGeneratorcreateIrTypeParameterWithoutBoundstypeParameter index symbol Cache the type parameter BEFORE processing its boundssupertypes to properly handle recursive type bounds if typeOriginforSetter typeParameterCacheForSettertypeParameter irTypeParameter else typeParameterCachetypeParameter irTypeParameter return irTypeParameter internal fun getCachedIrTypeParameter typeParameter FirTypeParameter typeOrigin ConversionTypeOrigin ConversionTypeOriginDEFAULT IrTypeParameter return if typeOriginforSetter typeParameterCacheForSettertypeParameter else typeParameterCachetypeParameter fun getIrTypeParameterSymbol firTypeParameterSymbol FirTypeParameterSymbol typeOrigin ConversionTypeOrigin IrTypeParameterSymbol val firTypeParameter firTypeParameterSymbolfir val cachedSymbol getCachedIrTypeParameterfirTypeParameter typeOriginsymbol typeParameterCachefirTypeParametersymbol We can try to use default cache because setter can use parent type parameters if cachedSymbol null return cachedSymbol if cconfigurationallowNonCachedDeclarations return createIrTypeParameterForNonCachedDeclarationfirTypeParameter errorCannot find cached type parameter by FIR symbol firTypeParameterSymbolname of the owner firTypeParametercontainingDeclarationSymbol private fun createIrTypeParameterForNonCachedDeclarationfirTypeParameter FirTypeParameter IrTypeParameterSymbol val firTypeParameterOwnerSymbol firTypeParametercontainingDeclarationSymbol val firTypeParameterOwner firTypeParameterOwnerSymbolfir as FirTypeParameterRefsOwner val index firTypeParameterOwnertypeParametersindexOffirTypeParameteralso checkit 0 val isSetter firTypeParameterOwner is FirPropertyAccessor firTypeParameterOwnerisSetter val conversionTypeOrigin if isSetter ConversionTypeOriginSETTER else ConversionTypeOriginDEFAULT return createAndCacheIrTypeParameterfirTypeParameter index conversionTypeOriginalso classifiersGeneratorinitializeTypeParameterBoundsfirTypeParameter it symbol classes fun createAndCacheIrClass regularClass FirRegularClass parent IrDeclarationParent predefinedOrigin IrDeclarationOrigin null IrClass val symbol createClassSymbol return classifiersGeneratorcreateIrClassregularClass parent symbol predefinedOriginalso OptInLeakedDeclarationCachesclass cacheIrClassregularClass it private fun createClassSymbol IrClassSymbol return IrClassSymbolImpl LeakedDeclarationCaches internal fun cacheIrClassregularClass FirRegularClass irClass IrClass if regularClassvisibility VisibilitiesLocal localStorageregularClass irClass else classCacheregularClass irClasssymbol FIR2IR looks over all nonlocal source classes and creates IR for them using createAndCacheIrClass This means that after this phase all classes are either created and bound to their symbols or external classes which are created and bound at the first access anyway So unlike callable declarations its safe to expose an API which returns not just IrClassSymbol but IrClass itself But on the first FIR2IR stage this API should not be used ", "modifier": "", "signature": "fun getIrClass(firClass: FirClass): IrClass", "body": "{<EOL> getCachedIrClass(firClass)?.let { return it }"}
{"docstring": " A generator for delegated members from implementation by delegation It assumes a synthetic field with the superinterface type has been created for the delegate expression It looks for delegatable methods and properties in the superinterface and creates corresponding members in the subclass TODO generic super interface types and generic delegated members class DelegatedMemberGeneratorprivate val c Fir2IrComponents Fir2IrComponents by c private val baseFunctionSymbols MutableMapIrFunction CollectionFirNamedFunctionSymbol mutableMapOf private val basePropertySymbols MutableMapIrProperty CollectionFirPropertySymbol mutableMapOf private data class DeclarationBodyInfo val delegatedFirDeclaration FirCallableDeclaration val delegatedIrDeclaration IrDeclaration val irField IrField val delegateToSymbol FirCallableSymbol val delegateToLookupTag ConeClassLikeLookupTag private val bodiesInfo mutableListOfDeclarationBodyInfo fun generateBodies for delegatedFirDeclaration delegatedIrDeclaration irField delegateToFirSymbol delegateToLookupTag in bodiesInfo when delegatedIrDeclaration is IrSimpleFunction val delegateToIrFunctionSymbol declarationStoragegetIrFunctionSymbol delegateToFirSymbolunwrapCallRepresentativec delegateToLookupTag as FirNamedFunctionSymbol delegateToLookupTag as IrSimpleFunctionSymbol continue val body createDelegateBody irField delegatedFirDeclaration delegatedIrDeclaration delegateToFirSymbolfir delegateToIrFunctionSymbol isSetter false delegatedIrDeclarationbody body is IrProperty val delegateToIrPropertySymbol declarationStoragegetIrPropertySymbol delegateToFirSymbolunwrapCallRepresentativec delegateToLookupTag as FirPropertySymbol delegateToLookupTag as IrPropertySymbol continue val delegateToGetterSymbol declarationStoragefindGetterOfPropertydelegateToIrPropertySymbol val getter delegatedIrDeclarationgetter getterbody createDelegateBody irField delegatedFirDeclaration getter delegateToFirSymbolfir delegateToGetterSymbol isSetter false if delegatedIrDeclarationisVar val delegateToSetterSymbol declarationStoragefindSetterOfPropertydelegateToIrPropertySymbol val setter delegatedIrDeclarationsetter setterbody createDelegateBody irField delegatedFirDeclaration setter delegateToFirSymbolfir delegateToSetterSymbol isSetter true bodiesInfoclear fun generateWithBodiesIfNeededfirField FirField irField IrField firSubClass FirClass subClass IrClass delegatedMemberGeneratorgenerateirField firField firSubClass subClass if firSubClassisLocalClassOrAnonymousObject delegatedMemberGeneratorgenerateBodies Generate delegated members for subClass The synthetic field irField has the super interface type fun generateirField IrField firField FirField firSubClass FirClass subClass IrClass val subClassScope firSubClassunsubstitutedScopec val delegateToScope firFieldinitializerresolvedType fullyExpandedTypesession lowerBoundIfFlexible scopesession scopeSession CallableCopyTypeCalculatorForced null return val subClassLookupTag firSubClasssymboltoLookupTag subClassScopeprocessAllFunctions functionSymbol val unwrapped functionSymbolunwrapDelegateTargetsubClassLookupTag firField returnprocessAllFunctions val delegateToSymbol findDelegateToSymbol unwrappedsymbol delegateToScopeprocessFunctionsByName delegateToScopeprocessOverriddenFunctions returnprocessAllFunctions val delegateToLookupTag delegateToSymboldispatchReceiverClassLookupTagOrNull returnprocessAllFunctions val delegatedFunction functionSymbolfir val irSubFunction generateDelegatedFunctionsubClass firSubClass delegatedFunction bodiesInfo DeclarationBodyInfodelegatedFunction irSubFunction irField delegateToSymbol delegateToLookupTag declarationStoragecacheDelegationFunctiondelegatedFunction irSubFunction subClassScopeprocessAllProperties propertySymbol if propertySymbol is FirPropertySymbol returnprocessAllProperties val unwrapped propertySymbolunwrapDelegateTargetsubClassLookupTag firField returnprocessAllProperties val delegateToSymbol findDelegateToSymbol unwrappedsymbol name processor delegateToScopeprocessPropertiesByNamename if it is FirPropertySymbol returnprocessPropertiesByName processorit delegateToScopeprocessOverriddenProperties returnprocessAllProperties val delegateToLookupTag delegateToSymboldispatchReceiverClassLookupTagOrNull returnprocessAllProperties val delegatedProperty propertySymbolfir val irSubProperty generateDelegatedPropertysubClass firSubClass delegatedProperty bodiesInfo DeclarationBodyInfodelegatedProperty irSubProperty irField delegateToSymbol delegateToLookupTag declarationStoragecacheDelegatedPropertydelegatedProperty irSubProperty private inline fun reified S FirCallableSymbol findDelegateToSymbol symbol S processCallables name Name processor S Unit Unit crossinline processOverridden base S processor S ProcessorAction ProcessorAction S val unwrappedSymbol symbolunwrapUseSiteSubstitutionOverrides var result S null The purpose of this code is to find member in delegateto scope which matches or overrides unwrappedSymbol which is in turn taken from subclass scope Note that its important to not unwrap callsite substitution override of the found function because later it will be used to compute the proper substituted type for call of this function processCallablesunwrappedSymbolname candidateSymbol if result null returnprocessCallables val unwrappedCandidateSymbol candidateSymbolunwrapUseSiteSubstitutionOverrides if unwrappedCandidateSymbol unwrappedSymbol result candidateSymbol returnprocessCallables processOverriddencandidateSymbol overriddenSymbol val unwrappedOverriddenSymbol overriddenSymbolunwrapUseSiteSubstitutionOverrides if unwrappedOverriddenSymbol unwrappedSymbol result candidateSymbol ProcessorActionSTOP else ProcessorActionNEXT return result OptInFirBasedFakeOverrideGeneratorclass fun bindDelegatedMembersOverriddenSymbolsirClass IrClass if cconfigurationuseFirBasedFakeOverrideGenerator return val superClasses by lazyLazyThreadSafetyModeNONE irClasssuperTypesmapNotNullTomutableSetOf All class symbols should be already bound at this moment OptInUnsafeDuringIrConstructionAPIclass itclassifierOrNullowner as IrClass requireirClass is Fir2IrLazyClass OptInUnsafeDuringIrConstructionAPIclass val declarations irClassdeclarations for declaration in declarations if declarationorigin IrDeclarationOriginDELEGATED_MEMBER continue when declaration is IrSimpleFunction val symbol declarationsymbol declarationoverriddenSymbols baseFunctionSymbolsdeclarationflatMap fakeOverrideGeneratorgetOverriddenSymbolsInSupertypesit superClasses filter it symbol orEmpty is IrProperty val symbol declarationsymbol declarationoverriddenSymbols basePropertySymbolsdeclarationflatMap fakeOverrideGeneratorgetOverriddenSymbolsInSupertypesit superClasses filter it symbol orEmpty declarationgetteroverriddenSymbols declarationoverriddenSymbolsmapNotNull declarationStoragefindGetterOfPropertyit if declarationisVar declarationsetteroverriddenSymbols declarationoverriddenSymbolsmapNotNull declarationStoragefindSetterOfPropertyit else continue private fun generateDelegatedFunction subClass IrClass firSubClass FirClass delegateOverride FirSimpleFunction IrSimpleFunction val delegateFunction declarationStoragecreateAndCacheIrFunction delegateOverride subClass predefinedOrigin IrDeclarationOriginDELEGATED_MEMBER fakeOverrideOwnerLookupTag firSubClasssymboltoLookupTag val baseSymbols mutableSetOfFirNamedFunctionSymbol the overridden symbols should be collected only after all fake overrides for all superclases are created and bound to their overridden symbols otherwise in some cases they will be left in inconsistent state leading to the errors in IR delegateOverrideprocessOverriddenFunctionSymbolsfirSubClass c baseSymbolsaddit baseFunctionSymbolsdelegateFunction baseSymbols annotationGeneratorgeneratedelegateFunction delegateOverride return delegateFunction interface Base fun foo String class Impl Base override fun foo String originalFirFunction originalFunctionSymbol return OK class Delegatedimpl Impl Base by impl private field delegate_xxx Impl impl irField generated override fun foo String delegateFunction ", "modifier": "private ", "signature": "fun createDelegateBody(\n        irField: IrField,\n        delegatedFirDeclaration: FirCallableDeclaration,\n        delegatedIrFunction: IrSimpleFunction,\n        originalFirDeclaration: FirCallableDeclaration,\n        originalFunctionSymbol: IrSimpleFunctionSymbol,\n        isSetter: Boolean\n    ): IrBlockBody", "body": "{<EOL> val startOffset = SYNTHETIC_OFFSET<EOL> val endOffset = SYNTHETIC_OFFSET<EOL> val body = irFactory.createBlockBody(startOffset, endOffset)<EOL><EOL> val typeOrigin = when {<EOL> originalFirDeclaration is FirPropertyAccessor && originalFirDeclaration.isSetter -> ConversionTypeOrigin.SETTER<EOL> else -> ConversionTypeOrigin.DEFAULT<EOL> }"}
{"docstring": " Should be called on dispatch receiver of corresponding field access This method attempts to replicate the behavior of K1 in generation of superQualifiedSymbol for IrFieldAccessExpression private fun FirExpressionsuperQualifierSymbolForFieldAccessfirResolvedSymbol FirBasedSymbol IrClassSymbol if firResolvedSymbol is FirBackingFieldSymbol firResolvedSymbol is FirDelegateFieldSymbol return null val classSymbol when this is FirResolvedQualifier if resolvedToCompanionObject return null thissymbol as FirClassSymbol else thisresolvedTypefullyExpandedTypesessiontoClassSymbolsession return null class Some companion object val x Int 1 Somex no superQualifiedSymbol if classSymbolisCompanion return null val irClassSymbol classifierStoragegetIrClassSymbolclassSymbol enum class Some A B val x Int 1 fun foo thisx no superQualifiedSymbol if classSymbolclassKind ClassKindENUM_CLASS conversionScopeparentStackany it as IrClasssymbol irClassSymbol return null FILE Basejava public class Base int fromJava 0 FILE Derivedkt class Derived Base val fromKotlin 1 init thisfromJava no superQualifiedSymbol thisfromKotlin superQualifiedSymbol is set if conversionScopeinitBlocksStackany itparentAsClasssymbol irClassSymbol this is FirThisReceiverExpression firResolvedSymbolfir is FirJavaField return null return irClassSymbol private val NamedynamicOperator get when this OperatorNameConventionsUNARY_PLUS IrDynamicOperatorUNARY_PLUS OperatorNameConventionsUNARY_MINUS IrDynamicOperatorUNARY_MINUS OperatorNameConventionsNOT IrDynamicOperatorEXCL OperatorNameConventionsPLUS IrDynamicOperatorBINARY_PLUS OperatorNameConventionsMINUS IrDynamicOperatorBINARY_MINUS OperatorNameConventionsTIMES IrDynamicOperatorMUL OperatorNameConventionsDIV IrDynamicOperatorDIV OperatorNameConventionsREM IrDynamicOperatorMOD OperatorNameConventionsAND IrDynamicOperatorANDAND OperatorNameConventionsOR IrDynamicOperatorOROR OperatorNameConventionsEQUALS IrDynamicOperatorEQEQ OperatorNameConventionsPLUS_ASSIGN IrDynamicOperatorPLUSEQ OperatorNameConventionsMINUS_ASSIGN IrDynamicOperatorMINUSEQ OperatorNameConventionsTIMES_ASSIGN IrDynamicOperatorMULEQ OperatorNameConventionsDIV_ASSIGN IrDynamicOperatorDIVEQ OperatorNameConventionsREM_ASSIGN IrDynamicOperatorMODEQ else null private val FirQualifiedAccessExpressiondynamicOperator IrDynamicOperator get val kind calleeReferencesourcekind val isOperationOnArray explicitReceiver as FirQualifiedAccessExpression calleeReferenceresolvedname SpecialNamesARRAY return when kind is KtFakeSourceElementKindArrayAccessNameReference isOperationOnArray when calleeReferenceresolvedname OperatorNameConventionsSET IrDynamicOperatorEQ OperatorNameConventionsGET IrDynamicOperatorARRAY_ACCESS else errorUnexpected name kind is KtFakeSourceElementKindDesugaredPrefixInc IrDynamicOperatorPREFIX_INCREMENT kind is KtFakeSourceElementKindDesugaredPrefixDec IrDynamicOperatorPREFIX_DECREMENT kind is KtFakeSourceElementKindDesugaredPostfixInc IrDynamicOperatorPOSTFIX_INCREMENT kind is KtFakeSourceElementKindDesugaredPostfixDec IrDynamicOperatorPOSTFIX_DECREMENT kind is KtFakeSourceElementKindDesugaredAugmentedAssign when calleeReferenceresolvedname OperatorNameConventionsSET IrDynamicOperatorEQ OperatorNameConventionsGET IrDynamicOperatorARRAY_ACCESS else errorUnexpected name else null private fun convertToIrCallForDynamic qualifiedAccess FirQualifiedAccessExpression explicitReceiverExpression IrExpression type IrType calleeReference FirReference symbol FirBasedSymbol dynamicOperator IrDynamicOperator null noArguments Boolean false IrExpression val selectedReceiver qualifiedAccessfindIrDynamicReceiverexplicitReceiverExpression return qualifiedAccessconvertWithOffsets startOffset endOffset when symbol is FirFunctionSymbol val name calleeReferenceresolvedname errorMust have a name val operator dynamicOperator namedynamicOperator qualifiedAccessdynamicOperator IrDynamicOperatorINVOKE val theType if name OperatorNameConventionsCOMPARE_TO typeConverterirBuiltInsbooleanType else type IrDynamicOperatorExpressionImplstartOffset endOffset theType operatorapply receiver if operator IrDynamicOperatorINVOKE qualifiedAccess is FirImplicitInvokeCall IrDynamicMemberExpressionImplstartOffset endOffset type nameidentifier selectedReceiver else selectedReceiver is FirPropertySymbol val name calleeReferenceresolvedname errorThere must be a name IrDynamicMemberExpressionImplstartOffset endOffset type nameidentifier selectedReceiver else generateErrorCallExpressionstartOffset endOffset calleeReference type applyTypeArgumentsqualifiedAccess applyCallArgumentsqualifiedAccess as FirCalltakeIf noArguments internal fun injectGetValueCallelement FirElement calleeReference FirReference IrExpression val injectedValue findInjectedValuecalleeReference if injectedValue null return elementconvertWithOffsets startOffset endOffset useInjectedValueinjectedValue calleeReference startOffset endOffset return null internal fun useInjectedValue injectedValue InjectedValue calleeReference FirReference startOffset Int endOffset Int IrGetValueImpl val type injectedValuetypeReftoIrType val origin calleeReferencestatementOrigin return IrGetValueImplstartOffset endOffset type injectedValueirParameterSymbol origin fun convertToIrCall qualifiedAccess FirQualifiedAccessExpression type ConeKotlinType explicitReceiverExpression IrExpression dynamicOperator IrDynamicOperator null variableAsFunctionMode Boolean false noArguments Boolean false IrExpression convertCatchingqualifiedAccess conversionScope injectGetValueCallqualifiedAccess qualifiedAccesscalleeReferencelet return it val irType typetoIrType val samConstructorCall qualifiedAccesstryConvertToSamConstructorCallirType if samConstructorCall null return samConstructorCall val dispatchReceiver qualifiedAccessdispatchReceiver val calleeReference qualifiedAccesscalleeReference val firSymbol calleeReferencetoResolvedBaseSymbol val isDynamicAccess firSymbolorigin FirDeclarationOriginDynamicScope if isDynamicAccess return convertToIrCallForDynamic qualifiedAccess explicitReceiverExpression irType calleeReference firSymbol errorMust have had a symbol dynamicOperator noArguments We might have had a dynamic receiver but resolved into a nonfake member For example we can resolve into members of Any val convertedExplicitReceiver if explicitReceiverExpressiontype is IrDynamicType qualifiedAccessconvertWithOffsets startOffset endOffset val callableDeclaration firSymbolfir as FirCallableDeclaration val targetType callableDeclarationdispatchReceiverTypetoIrType callableDeclarationreceiverParametertypeReftoIrType errorCouldnt get the proper receiver IrTypeOperatorCallImpl startOffset endOffset targetType IrTypeOperatorIMPLICIT_DYNAMIC_CAST targetType explicitReceiverExpression else explicitReceiverExpression return qualifiedAccessconvertWithOffsets startOffset endOffset if calleeReference is FirSuperReference if dispatchReceiver null returnconvertWithOffsets visitorconvertToIrExpressiondispatchReceiver val symbol calleeReferencetoSymbolForCall c dispatchReceiver explicitReceiver qualifiedAccessexplicitReceiver when symbol is IrConstructorSymbol requirefirSymbol is FirConstructorSymbol val constructor firSymbolunwrapCallRepresentativecfir as FirConstructor val totalTypeParametersCount constructortypeParameterssize val constructorTypeParametersCount constructortypeParameterscount it is FirTypeParameter IrConstructorCallImpl startOffset endOffset irType symbol typeArgumentsCount totalTypeParametersCount valueArgumentsCount firSymbolvalueParametersSize constructorTypeArgumentsCount constructorTypeParametersCount is IrSimpleFunctionSymbol requirefirSymbol is FirCallableSymbol Illegal symbol firSymbolclass val callOrigin calleeReferencestatementOrigin For x y x xplusy receiver of call plus should also have an augmented assignment origin But its hard to detect this origin during conversion the receiver itself so we update it afterward if explicitReceiverExpression null calleeReferencesourcekind is KtFakeSourceElementKindDesugaredAugmentedAssign callOrigin null This is to reproduce K1 behavior K1 does not set origin for augmented assignmentoriginated get and set firSymbolname OperatorNameConventionsGET firSymbolname OperatorNameConventionsSET explicitReceiverExpressionupdateStatementOrigincallOrigin IrCallImpl startOffset endOffset irType symbol typeArgumentsCount firSymboltypeParameterSymbolssize valueArgumentsCount firSymbolvalueParametersSize origin callOrigin superQualifierSymbol dispatchReceiversuperQualifierSymbolForFunctionAndPropertyAccess is IrLocalDelegatedPropertySymbol IrCallImpl startOffset endOffset irType declarationStoragefindGetterOfPropertysymbol typeArgumentsCount calleeReferencetoResolvedCallableSymbolfirtypeParameterssize valueArgumentsCount 0 origin IrStatementOriginGET_LOCAL_PROPERTY superQualifierSymbol dispatchReceiversuperQualifierSymbolForFunctionAndPropertyAccess is IrPropertySymbol val property calleeReferencetoResolvedPropertySymbolfir val getterSymbol declarationStoragefindGetterOfPropertysymbol val backingFieldSymbol declarationStoragefindBackingFieldOfPropertysymbol when getterSymbol null IrCallImpl startOffset endOffset irType getterSymbol typeArgumentsCount propertytypeParameterssize valueArgumentsCount propertycontextReceiverssize origin incOrDeclSourceKindToIrStatementOriginqualifiedAccesssourcekind augmentedAssignSourceKindToIrStatementOriginqualifiedAccesssourcekind IrStatementOriginGET_PROPERTY superQualifierSymbol dispatchReceiversuperQualifierSymbolForFunctionAndPropertyAccess backingFieldSymbol null IrGetFieldImpl startOffset endOffset backingFieldSymbol irType superQualifierSymbol dispatchReceiversuperQualifierSymbolForFieldAccessfirSymbol else IrErrorCallExpressionImpl startOffset endOffset irType description No getter or backing field found for calleeReferencerender is IrFieldSymbol IrGetFieldImpl startOffset endOffset symbol irType superQualifierSymbol dispatchReceiversuperQualifierSymbolForFieldAccessfirSymbol is IrValueSymbol val variable calleeReferencetoResolvedVariableSymbolfir IrGetValueImpl startOffset endOffset Note there is a case with componentN function when IR type of variable differs from FIR type variableirTypeForPotentiallyComponentCallc predefinedType irType symbol origin if variableAsFunctionMode IrStatementOriginVARIABLE_AS_FUNCTION else incOrDeclSourceKindToIrStatementOriginqualifiedAccesssourcekind calleeReferencestatementOrigin is IrEnumEntrySymbol IrGetEnumValueImplstartOffset endOffset irType symbol else generateErrorCallExpressionstartOffset endOffset calleeReference irType applyTypeArgumentsqualifiedAccessapplyReceiversqualifiedAccess convertedExplicitReceiver applyCallArgumentsqualifiedAccess private fun FirCallableSymbolvalueParametersSize Int return when this is FirSyntheticPropertySymbol 0 is FirNamedFunctionSymbol firvalueParameterssize fircontextReceiverssize is FirConstructorSymbol firvalueParameterssize fircontextReceiverssize is FirFunctionSymbol firvalueParameterssize else errorIllegal symbol thisclass private fun convertToIrSetCallForDynamic variableAssignment FirVariableAssignment explicitReceiverExpression IrExpression type IrType calleeReference FirReference symbol FirBasedSymbol assignedValue IrExpression IrExpression val selectedReceiver variableAssignmentunwrapLValue errorAssignment has no lValuefindIrDynamicReceiverexplicitReceiverExpression return variableAssignmentconvertWithOffsets startOffset endOffset when symbol is FirPropertySymbol val name calleeReferenceresolvedname errorThere must be a name IrDynamicOperatorExpressionImplstartOffset endOffset type IrDynamicOperatorEQapply receiver IrDynamicMemberExpressionImpl startOffset endOffset type nameidentifier selectedReceiver argumentsaddassignedValue else generateErrorCallExpressionstartOffset endOffset calleeReference A dynamic call has either an explicit receiver or an implicit this dispatch receiver private fun FirQualifiedAccessExpressionfindIrDynamicReceiver explicitReceiverExpression IrExpression IrExpression return explicitReceiverExpression dispatchReceiver as FirThisReceiverExpressionletvisitorconvertToIrExpression errorNo receiver for dynamic call private fun injectSetValueCallelement FirElement calleeReference FirReference assignedValue IrExpression IrExpression val injectedValue findInjectedValuecalleeReference if injectedValue null return elementconvertWithOffsets startOffset endOffset val type irBuiltInsunitType val origin calleeReferencestatementOrigin IrSetValueImplstartOffset endOffset type injectedValueirParameterSymbol assignedValue origin return null internal fun findInjectedValuecalleeReference FirReference extensionsfindInjectedValuecalleeReference conversionScope fun convertToIrSetCall variableAssignment FirVariableAssignment explicitReceiverExpression IrExpression IrExpression convertCatchingvariableAssignment conversionScope val type irBuiltInsunitType val calleeReference variableAssignmentcalleeReference errorReference not resolvable TODOKT63348 An expected type should be passed to the IrExpression conversion val assignedValue wrapWithImplicitCastForAssignmentvariableAssignment visitorconvertToIrExpressionvariableAssignmentrValue injectSetValueCallvariableAssignment calleeReference assignedValuelet return it val firSymbol calleeReferencetoResolvedBaseSymbol val isDynamicAccess firSymbolorigin FirDeclarationOriginDynamicScope if isDynamicAccess return convertToIrSetCallForDynamic variableAssignment explicitReceiverExpression type calleeReference firSymbol errorMustve had a symbol assignedValue val symbol calleeReferencetoSymbolForCall c extractDispatchReceiverOfAssignmentvariableAssignment explicitReceiver variableAssignmentexplicitReceiver preferGetter false val origin variableAssignmentgetIrAssignmentOrigin val lValue variableAssignmentunwrapLValue errorAssignment lValue unwrapped to null return variableAssignmentconvertWithOffsetscalleeReference startOffset endOffset when symbol is IrFieldSymbol IrSetFieldImpl startOffset endOffset symbol type origin superQualifierSymbol lValuedispatchReceiversuperQualifierSymbolForFieldAccessfirSymbol apply value assignedValue is IrLocalDelegatedPropertySymbol val firProperty calleeReferencetoResolvedPropertySymbolfir val setterSymbol declarationStoragefindSetterOfPropertysymbol when setterSymbol null IrCallImpl startOffset endOffset type setterSymbol typeArgumentsCount firPropertytypeParameterssize valueArgumentsCount 1 firPropertycontextReceiverssize origin origin superQualifierSymbol variableAssignmentdispatchReceiversuperQualifierSymbolForFunctionAndPropertyAccess apply putContextReceiverArgumentslValue putValueArgument0 assignedValue else generateErrorCallExpressionstartOffset endOffset calleeReference is IrPropertySymbol val setterSymbol declarationStoragefindSetterOfPropertysymbol val backingFieldSymbol declarationStoragefindBackingFieldOfPropertysymbol val firProperty calleeReferencetoResolvedPropertySymbolfir when setterSymbol null IrCallImpl startOffset endOffset type setterSymbol typeArgumentsCount firPropertytypeParameterssize valueArgumentsCount 1 firPropertycontextReceiverssize origin origin superQualifierSymbol variableAssignmentdispatchReceiversuperQualifierSymbolForFunctionAndPropertyAccess apply putValueArgumentputContextReceiverArgumentslValue assignedValue backingFieldSymbol null IrSetFieldImpl startOffset endOffset backingFieldSymbol type origin null NB to be consistent with PSI2IR origin should be null here superQualifierSymbol variableAssignmentdispatchReceiversuperQualifierSymbolForFieldAccessfirSymbol apply value assignedValue else generateErrorCallExpressionstartOffset endOffset calleeReference is IrSimpleFunctionSymbol val firFunction calleeReferencetoResolvedFunctionSymbolfir IrCallImpl startOffset endOffset type symbol typeArgumentsCount firFunctiontypeParameterssize 0 valueArgumentsCount 1 origin origin apply putValueArgument0 assignedValue is IrVariableSymbol IrSetValueImplstartOffset endOffset type symbol assignedValue origin else generateErrorCallExpressionstartOffset endOffset calleeReference applyTypeArgumentslValueapplyReceiverslValue explicitReceiverExpression Wrap an assignment as needed with an implicit cast to the lefthard side type ", "modifier": "private ", "signature": "fun wrapWithImplicitCastForAssignment(assignment: FirVariableAssignment, value: IrExpression): IrExpression", "body": "{<EOL> if (value is IrTypeOperatorCall) return value // Value is already cast.<EOL><EOL> val rValue = assignment.rValue<EOL> if (rValue !is FirSmartCastExpression) return value // Value was not smartcast.<EOL><EOL> // Convert the original type to not-null, as an implicit cast is not needed in this case.<EOL> val originalType = rValue.originalExpression.resolvedType.withNullability(ConeNullability.NOT_NULL, session.typeContext)<EOL> val assignmentType = assignment.lValue.resolvedType<EOL> if (originalType.isSubtypeOf(assignmentType, session)) return value // Cast is not needed.<EOL><EOL> return implicitCast(value, assignmentType.toIrType(), IrTypeOperator.IMPLICIT_CAST)<EOL> }"}
{"docstring": " A generator that converts callable references or arguments that needs an adapter in between This covers 1 Suspend conversion where a reference to or qualified access of nonsuspend functional type is passed as an argument whose expected type is a suspend functional type 2 coerciontounit where a reference to a function whose return type isnt Unit is passed as an argument whose expected return type is Unit 3 vararg spread where a reference to a function with vararg parameter is passed as an argument whose use of that vararg parameter requires spreading internal class AdapterGenerator private val c Fir2IrComponents private val conversionScope Fir2IrConversionScope Fir2IrComponents by c private val samResolver FirSamResolversession scopeSession internal fun needToGenerateAdaptedCallableReference callableReferenceAccess FirCallableReferenceAccess type IrSimpleType function FirFunction Boolean return needSuspendConversiontype function needCoercionToUnittype function hasVarargOrDefaultArgumentscallableReferenceAccess For example fun referenceConsumerf suspend Unit fun nonSuspendFunction fun useSite referenceConsumernonSuspendFunction At the use site instead of referenced we can put the suspend lambda as an adapter ", "modifier": "private ", "signature": "fun needSuspendConversion(type: IrSimpleType, function: FirFunction): Boolean", "body": "{<EOL> return type.isSuspendFunction() && !function.isSuspend<EOL> }"}
{"docstring": " For example fun referenceConsumerf Unit f fun referenced Any fun useSite referenceConsumerreferenced At the use site instead of referenced we can put the adapter referenced ", "modifier": "private ", "signature": "fun needCoercionToUnit(type: IrSimpleType, function: FirFunction): Boolean", "body": "{<EOL> val expectedReturnType = type.arguments.last().typeOrNull<EOL> val actualReturnType = function.returnTypeRef.coneType<EOL> return expectedReturnType?.isUnit() == true &&<EOL> // In case of an external function whose return type is a type parameter, e.g., operator fun <T, R> invoke(T): R<EOL> !actualReturnType.isUnit && actualReturnType.toSymbol(c.session) !is FirTypeParameterSymbol<EOL> }"}
{"docstring": " For example fun referenceConsumerf Char Char String String eg fchar1 char2 fun referencedvararg xs Char fun useSite referenceConsumerreferenced At the use site instead of referenced we can put the adapter a b referenceda b ", "modifier": "private ", "signature": "fun hasVarargOrDefaultArguments(callableReferenceAccess: FirCallableReferenceAccess): Boolean", "body": "{<EOL> // Unbound callable reference 'A::foo'<EOL> val calleeReference = callableReferenceAccess.calleeReference as? FirResolvedCallableReference ?: return false<EOL> return calleeReference.mappedArguments.any { (_, value) -><EOL> value is ResolvedCallArgument.VarargArgument || value is ResolvedCallArgument.DefaultArgument<EOL> }"}
{"docstring": " This function runs only common checkers Platform checkers should be run separately after all parts of MPP structure will be resolved ", "modifier": "", "signature": "fun resolveAndCheckFir(\n    session: FirSession,\n    firFiles: List<FirFile>,\n    diagnosticsReporter: BaseDiagnosticsCollector\n): ModuleCompilerAnalyzedOutput", "body": "{<EOL> val (scopeSession, fir) = session.runResolution(firFiles)<EOL> session.runCheckers(scopeSession, fir, diagnosticsReporter, MppCheckerKind.Common)<EOL> return ModuleCompilerAnalyzedOutput(session, scopeSession, fir)<EOL>}"}
{"docstring": " EXPRESSIONS ", "modifier": "", "signature": "fun convertExpression(expression: LighterASTNode, errorReason: String): FirElement", "body": "{<EOL> return when (expression.tokenType) {<EOL> LAMBDA_EXPRESSION -> convertLambdaExpression(expression)<EOL> BINARY_EXPRESSION -> convertBinaryExpression(expression)<EOL> BINARY_WITH_TYPE -> convertBinaryWithTypeRHSExpression(expression) {<EOL> this.getOperationSymbol().toFirOperation()<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseFunctionLiteral see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitLambdaExpression ", "modifier": "private ", "signature": "fun convertLambdaExpression(lambdaExpression: LighterASTNode): FirExpression", "body": "{<EOL> val valueParameterList = mutableListOf<ValueParameter>()<EOL> var block: LighterASTNode? = null<EOL> var hasArrow = false<EOL><EOL> val functionSymbol = FirAnonymousFunctionSymbol()<EOL> lambdaExpression.getChildNodesByType(FUNCTION_LITERAL).first().forEachChildren {<EOL> when (it.tokenType) {<EOL> VALUE_PARAMETER_LIST -> valueParameterList += declarationBuilder.convertValueParameters(it, functionSymbol, ValueParameterDeclaration.LAMBDA)<EOL> BLOCK -> block = it<EOL> ARROW -> hasArrow = true<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseBinaryExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitBinaryExpression ", "modifier": "private ", "signature": "fun convertBinaryExpression(binaryExpression: LighterASTNode): FirStatement", "body": "{<EOL> var isLeftArgument = true<EOL> lateinit var operationTokenName: String<EOL> var leftArgNode: LighterASTNode? = null<EOL> var rightArg: LighterASTNode? = null<EOL> var operationReferenceSource: KtLightSourceElement? = null<EOL> binaryExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> OPERATION_REFERENCE -> {<EOL> isLeftArgument = false<EOL> operationTokenName = it.asText<EOL> operationReferenceSource = it.toFirSourceElement()<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseLabeledExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitLabeledExpression ", "modifier": "private ", "signature": "fun convertLabeledExpression(labeledExpression: LighterASTNode): FirElement", "body": "{<EOL> var firExpression: FirElement? = null<EOL> var labelSource: KtSourceElement? = null<EOL> var forbiddenLabelKind: ForbiddenLabelKind? = null<EOL><EOL> val isRepetitiveLabel = labeledExpression.getLabeledExpression()?.tokenType == LABELED_EXPRESSION<EOL><EOL> labeledExpression.forEachChildren {<EOL> context.setNewLabelUserNode(it)<EOL> when (it.tokenType) {<EOL> LABEL_QUALIFIER -> {<EOL> val name = it.asText.dropLast(1)<EOL> labelSource = it.getChildNodesByType(LABEL).single().toFirSourceElement()<EOL> context.addNewLabel(buildLabel(name, labelSource!!))<EOL> forbiddenLabelKind = getForbiddenLabelKind(name, isRepetitiveLabel)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparsePostfixExpression see orgjetbrainskotlinparsingKotlinExpressionParsingparsePrefixExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitUnaryExpression ", "modifier": "private ", "signature": "fun convertUnaryExpression(unaryExpression: LighterASTNode): FirExpression", "body": "{<EOL> lateinit var operationTokenName: String<EOL> var argument: LighterASTNode? = null<EOL> var operationReference: LighterASTNode? = null<EOL> unaryExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> OPERATION_REFERENCE -> {<EOL> operationReference = it<EOL> operationTokenName = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparsePrefixExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitAnnotatedExpression ", "modifier": "private ", "signature": "fun convertAnnotatedExpression(annotatedExpression: LighterASTNode): FirElement", "body": "{<EOL> var firExpression: FirElement? = null<EOL> val firAnnotationList = mutableListOf<FirAnnotation>()<EOL> annotatedExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION -> firAnnotationList += declarationBuilder.convertAnnotation(it)<EOL> ANNOTATION_ENTRY -> firAnnotationList += declarationBuilder.convertAnnotationEntry(it)<EOL> BLOCK -> firExpression = declarationBuilder.convertBlockExpression(it)<EOL> else -> if (it.isExpression()) {<EOL> context.forwardLabelUsagePermission(annotatedExpression, it)<EOL> firExpression = getAsFirStatement(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseDoubleColonSuffix see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitClassLiteralExpression ", "modifier": "private ", "signature": "fun convertClassLiteralExpression(classLiteralExpression: LighterASTNode): FirExpression", "body": "{<EOL> var firReceiverExpression: FirExpression? = null<EOL> classLiteralExpression.forEachChildren {<EOL> if (it.isExpression()) firReceiverExpression = getAsFirExpression(it, \"No receiver in class literal\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseDoubleColonSuffix see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitCallableReferenceExpression ", "modifier": "private ", "signature": "fun convertCallableReferenceExpression(callableReferenceExpression: LighterASTNode): FirExpression", "body": "{<EOL> var isReceiver = true<EOL> var hasQuestionMarkAtLHS = false<EOL> var firReceiverExpression: FirExpression? = null<EOL> lateinit var namedReference: FirNamedReference<EOL> callableReferenceExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> COLONCOLON -> isReceiver = false<EOL> QUEST -> hasQuestionMarkAtLHS = true<EOL> else -> if (it.isExpression()) {<EOL> if (isReceiver) {<EOL> firReceiverExpression = getAsFirExpression(it, \"Incorrect receiver expression\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparsePostfixExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitQualifiedExpression ", "modifier": "private ", "signature": "fun convertQualifiedExpression(dotQualifiedExpression: LighterASTNode): FirExpression", "body": "{<EOL> var isSelector = false<EOL> var isSafe = false<EOL> var firSelector: FirExpression? = null<EOL> var firReceiver: FirExpression? = null //before dot<EOL> dotQualifiedExpression.forEachChildren {<EOL> when (val tokenType = it.tokenType) {<EOL> DOT -> isSelector = true<EOL> SAFE_ACCESS -> {<EOL> isSafe = true<EOL> isSelector = true<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseCallSuffix ", "modifier": "private ", "signature": "fun convertCallExpression(callSuffix: LighterASTNode): FirExpression", "body": "{<EOL> var name: String? = null<EOL> val firTypeArguments = mutableListOf<FirTypeProjection>()<EOL> val valueArguments = mutableListOf<LighterASTNode>()<EOL> var additionalArgument: FirExpression? = null<EOL> var hasArguments = false<EOL> var superNode: LighterASTNode? = null<EOL> callSuffix.forEachChildren { child -><EOL> fun process(node: LighterASTNode) {<EOL> when (node.tokenType) {<EOL> REFERENCE_EXPRESSION -> {<EOL> name = node.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseStringTemplate ", "modifier": "private ", "signature": "fun convertStringTemplate(stringTemplate: LighterASTNode): FirExpression", "body": "{<EOL> return stringTemplate.getChildrenAsArray().toInterpolatingCall(stringTemplate) { convertShortOrLongStringTemplate(it) }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseLiteralConstant ", "modifier": "private ", "signature": "fun convertConstantExpression(constantExpression: LighterASTNode): FirExpression", "body": "{<EOL> return generateConstantExpressionByLiteral(constantExpression)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseWhen see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitWhenExpression ", "modifier": "private ", "signature": "fun convertWhenExpression(whenExpression: LighterASTNode): FirExpression", "body": "{<EOL> var subjectExpression: FirExpression? = null<EOL> var subjectVariable: FirVariable? = null<EOL> val whenEntryNodes = mutableListOf<LighterASTNode>()<EOL> val whenEntries = mutableListOf<WhenEntry>()<EOL> whenExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> PROPERTY -> subjectVariable = (declarationBuilder.convertPropertyDeclaration(it) as FirVariable).let { variable -><EOL> buildProperty {<EOL> source = it.toFirSourceElement()<EOL> origin = FirDeclarationOrigin.Source<EOL> moduleData = baseModuleData<EOL> returnTypeRef = variable.returnTypeRef<EOL> name = variable.name<EOL> initializer = variable.initializer<EOL> isVar = false<EOL> symbol = FirPropertySymbol(variable.name)<EOL> isLocal = true<EOL> status = FirDeclarationStatusImpl(Visibilities.Local, Modality.FINAL)<EOL> annotations += variable.annotations<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseWhenEntry see orgjetbrainskotlinparsingKotlinExpressionParsingparseWhenEntryNotElse ", "modifier": "private ", "signature": "fun convertWhenEntry(\n        whenEntry: LighterASTNode,\n        whenRefWithSubject: FirExpressionRef<FirWhenExpression>,\n        hasSubject: Boolean,\n    ): WhenEntry", "body": "{<EOL> var isElse = false<EOL> var firBlock: FirBlock = buildEmptyExpressionBlock()<EOL> val conditions = mutableListOf<FirExpression>()<EOL> var shouldBindSubject = false<EOL> whenEntry.forEachChildren {<EOL> when (it.tokenType) {<EOL> WHEN_CONDITION_EXPRESSION -> conditions += convertWhenConditionExpression(it, whenRefWithSubject.takeIf { hasSubject }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseArrayAccess see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitArrayAccessExpression ", "modifier": "private ", "signature": "fun convertArrayAccessExpression(arrayAccess: LighterASTNode): FirExpression", "body": "{<EOL> var firExpression: FirExpression? = null<EOL> val indices: MutableList<FirExpression> = mutableListOf()<EOL> arrayAccess.forEachChildren {<EOL> when (it.tokenType) {<EOL> INDICES -> indices += convertIndices(it)<EOL> else -> if (it.isExpression()) firExpression = getAsFirExpression(it, \"No array expression\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseCollectionLiteralExpression ", "modifier": "private ", "signature": "fun convertCollectionLiteralExpression(expression: LighterASTNode): FirExpression", "body": "{<EOL> val firExpressionList = mutableListOf<FirExpression>()<EOL> expression.forEachChildren {<EOL> if (it.isExpression()) firExpressionList += getAsFirExpression<FirExpression>(it, \"Incorrect collection literal argument\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseAsCollectionLiteralExpression private fun convertIndicesindices LighterASTNode ListFirExpression val firExpressionList MutableListFirExpression mutableListOf indicesforEachChildren if itisExpression firExpressionList getAsFirExpressionFirExpressionit Incorrect index expression return firExpressionList see orgjetbrainskotlinparsingKotlinExpressionParsingparseSimpleNameExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitSimpleNameExpression ", "modifier": "private ", "signature": "fun convertSimpleNameExpression(referenceExpression: LighterASTNode): FirQualifiedAccessExpression", "body": "{<EOL> val nameSource = referenceExpression.toFirSourceElement()<EOL> val referenceSourceElement = if (nameSource.kind is KtFakeSourceElementKind) {<EOL> nameSource<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseDoWhile see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitDoWhileExpression ", "modifier": "private ", "signature": "fun convertDoWhile(doWhileLoop: LighterASTNode): FirElement", "body": "{<EOL> var block: LighterASTNode? = null<EOL> var firCondition: FirExpression? = null<EOL><EOL> val target: FirLoopTarget<EOL> return FirDoWhileLoopBuilder().apply {<EOL> source = doWhileLoop.toFirSourceElement()<EOL> // For break/continue in the do-while loop condition, prepare the loop target first so that it can refer to the same loop.<EOL> target = prepareTarget(doWhileLoop)<EOL> doWhileLoop.forEachChildren {<EOL> when (it.tokenType) {<EOL> BODY -> block = it<EOL> CONDITION -> firCondition = getAsFirExpression(it, \"No condition in do-while loop\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseWhile see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitWhileExpression ", "modifier": "private ", "signature": "fun convertWhile(whileLoop: LighterASTNode): FirElement", "body": "{<EOL> var block: LighterASTNode? = null<EOL> var firCondition: FirExpression? = null<EOL> whileLoop.forEachChildren {<EOL> when (it.tokenType) {<EOL> BODY -> block = it<EOL> CONDITION -> firCondition = getAsFirExpression(it, \"No condition in while loop\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseFor see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitForExpression ", "modifier": "private ", "signature": "fun convertFor(forLoop: LighterASTNode): FirElement", "body": "{<EOL> var parameter: ValueParameter? = null<EOL> var rangeExpression: FirExpression? = null<EOL> var blockNode: LighterASTNode? = null<EOL> forLoop.forEachChildren {<EOL> when (it.tokenType) {<EOL> VALUE_PARAMETER -> parameter = declarationBuilder.convertValueParameter(it, null, ValueParameterDeclaration.FOR_LOOP)<EOL> LOOP_RANGE -> rangeExpression = getAsFirExpression(it, \"No range in for loop\")<EOL> BODY -> blockNode = it<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseLoopBody see orgjetbrainskotlinfirbuilderRawFirBuilderVisitortoFirBlock ", "modifier": "private ", "signature": "fun convertLoopBody(body: LighterASTNode?): FirBlock", "body": "{<EOL> return convertLoopOrIfBody(body) ?: buildEmptyExpressionBlock()<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseTry see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitTryExpression ", "modifier": "private ", "signature": "fun convertTryExpression(tryExpression: LighterASTNode): FirExpression", "body": "{<EOL> lateinit var tryBlock: FirBlock<EOL> val catchClauses = mutableListOf<Triple<ValueParameter?, FirBlock, KtLightSourceElement>>()<EOL> var finallyBlock: FirBlock? = null<EOL> tryExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> BLOCK -> tryBlock = declarationBuilder.convertBlock(it)<EOL> CATCH -> convertCatchClause(it)?.also { oneClause -> catchClauses += oneClause }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseTry private fun convertCatchClausecatchClause LighterASTNode TripleValueParameter FirBlock KtLightSourceElement var valueParameter ValueParameter null var blockNode LighterASTNode null catchClauseforEachChildren when ittokenType VALUE_PARAMETER_LIST valueParameter declarationBuilderconvertValueParametersit FirAnonymousFunctionSymbolTODO ValueParameterDeclarationCATCH firstOrNull return null BLOCK blockNode it return TriplevalueParameter declarationBuilderconvertBlockblockNode catchClausetoFirSourceElement see orgjetbrainskotlinparsingKotlinExpressionParsingparseTry ", "modifier": "private ", "signature": "fun convertFinally(finallyExpression: LighterASTNode): FirBlock", "body": "{<EOL> var blockNode: LighterASTNode? = null<EOL> finallyExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> BLOCK -> blockNode = it<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseIf see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitIfExpression ", "modifier": "private ", "signature": "fun convertIfExpression(ifExpression: LighterASTNode): FirExpression", "body": "{<EOL> return buildWhenExpression {<EOL> source = ifExpression.toFirSourceElement()<EOL> with(parseIfExpression(ifExpression)) {<EOL> val trueBranch = convertLoopBody(thenBlock)<EOL> branches += buildWhenBranch {<EOL> source = firCondition?.source<EOL> condition = firCondition ?: buildErrorExpression(<EOL> null,<EOL> ConeSyntaxDiagnostic(\"If statement should have condition\")<EOL> )<EOL> result = trueBranch<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseJump see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitBreakExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitContinueExpression ", "modifier": "private ", "signature": "fun convertLoopJump(jump: LighterASTNode): FirExpression", "body": "{<EOL> var isBreak = true<EOL> jump.forEachChildren {<EOL> when (it.tokenType) {<EOL> CONTINUE_KEYWORD -> isBreak = false<EOL> //BREAK -> isBreak = true<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseReturn see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitReturnExpression ", "modifier": "private ", "signature": "fun convertReturn(returnExpression: LighterASTNode): FirExpression", "body": "{<EOL> var labelName: String? = null<EOL> var firExpression: FirExpression? = null<EOL> returnExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> LABEL_QUALIFIER -> labelName = it.getAsStringWithoutBacktick().replace(\"@\", \"\")<EOL> else -> if (it.isExpression()) firExpression = getAsFirExpression(it, \"Incorrect return expression\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseThrow see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitThrowExpression ", "modifier": "private ", "signature": "fun convertThrow(throwExpression: LighterASTNode): FirExpression", "body": "{<EOL> var firExpression: FirExpression? = null<EOL> throwExpression.forEachChildren {<EOL> if (it.isExpression()) firExpression = getAsFirExpression(it, \"Nothing to throw\")<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseThisExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitThisExpression ", "modifier": "private ", "signature": "fun convertThisExpression(thisExpression: LighterASTNode): FirQualifiedAccessExpression", "body": "{<EOL> val label: String? = thisExpression.getLabelName()<EOL> return buildThisReceiverExpression {<EOL> val sourceElement = thisExpression.toFirSourceElement()<EOL> source = sourceElement<EOL> calleeReference = buildExplicitThisReference {<EOL> labelName = label<EOL> source = sourceElement.fakeElement(KtFakeSourceElementKind.ReferenceInAtomicQualifiedAccess)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseSuperExpression see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitSuperExpression ", "modifier": "private ", "signature": "fun convertSuperExpression(superExpression: LighterASTNode): FirQualifiedAccessExpression", "body": "{<EOL> val label: String? = superExpression.getLabelName()<EOL> var superTypeRef: FirTypeRef = implicitType<EOL> superExpression.forEachChildren {<EOL> when (it.tokenType) {<EOL> TYPE_REFERENCE -> superTypeRef = declarationBuilder.convertType(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseValueArgumentList fun convertValueArgumentsvalueArguments LighterASTNode ListFirExpression return valueArgumentsforEachChildrenReturnList node container when nodetokenType VALUE_ARGUMENT container convertValueArgumentnode LAMBDA_EXPRESSION LABELED_EXPRESSION ANNOTATED_EXPRESSION container getAsFirExpressionFirAnonymousFunctionExpressionnodeapply TODOKT66553 remove and set in builder OptInRawFirApiclass replaceIsTrailingLambdanewIsTrailingLambda true see orgjetbrainskotlinparsingKotlinExpressionParsingparseValueArgument see orgjetbrainskotlinfirbuilderRawFirBuilderVisitortoFirExpressionorgjetbrainskotlinpsiValueArgument ", "modifier": "private ", "signature": "fun convertValueArgument(valueArgument: LighterASTNode): FirExpression", "body": "{<EOL> var identifier: String? = null<EOL> var isSpread = false<EOL> var firExpression: FirExpression? = null<EOL> valueArgument.forEachChildren {<EOL> when (it.tokenType) {<EOL> VALUE_ARGUMENT_NAME -> identifier = it.asText<EOL> MUL -> isSpread = true<EOL> STRING_TEMPLATE -> firExpression = convertStringTemplate(it)<EOL> is KtConstantExpressionElementType -> firExpression = convertConstantExpression(it)<EOL> else -> if (it.isExpression()) firExpression = getAsFirExpression(it, \"Argument is absent\")<EOL> }"}
{"docstring": " orgjetbrainskotlinparsingKotlinParsingparseFile orgjetbrainskotlinparsingKotlinParsingparsePreamble ", "modifier": "", "signature": "fun convertFile(file: LighterASTNode, sourceFile: KtSourceFile, linesMapping: KtSourceFileLinesMapping): FirFile", "body": "{<EOL> if (file.tokenType != KT_FILE) {<EOL> //TODO throw error<EOL> throw Exception()<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseBlockExpression ", "modifier": "", "signature": "fun convertBlockExpression(block: LighterASTNode): FirBlock", "body": "{<EOL> return convertBlockExpressionWithoutBuilding(block).build()<EOL> }"}
{"docstring": " PREAMBLE see orgjetbrainskotlinparsingKotlinParsingparsePackageName ", "modifier": "private ", "signature": "fun convertPackageDirective(packageNode: LighterASTNode): FirPackageDirective", "body": "{<EOL> var packageName: FqName = FqName.ROOT<EOL> packageNode.forEachChildren {<EOL> when (it.tokenType) {<EOL> //TODO separate logic for both expression types<EOL> DOT_QUALIFIED_EXPRESSION, REFERENCE_EXPRESSION -> packageName = FqName(it.getAsStringWithoutBacktick())<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseImportDirective ", "modifier": "private ", "signature": "fun convertImportDirective(importDirective: LighterASTNode): FirImport", "body": "{<EOL> var importedFqName: FqName? = null<EOL> var isAllUnder = false<EOL> var aliasName: String? = null<EOL> var aliasSource: KtSourceElement? = null<EOL> importDirective.forEachChildren {<EOL> when (it.tokenType) {<EOL> REFERENCE_EXPRESSION, DOT_QUALIFIED_EXPRESSION -> {<EOL> importedFqName = mutableListOf<String>()<EOL> .apply { collectSegments(it) }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseImportDirectives private fun convertImportDirectivesimportList LighterASTNode ListFirImport return importListforEachChildrenReturnList node container when nodetokenType IMPORT_DIRECTIVE container convertImportDirectivenode MODIFIERS Convert only modifiers see orgjetbrainskotlinparsingKotlinParsingparseModifierList ", "modifier": "private ", "signature": "fun convertModifierList(modifiers: LighterASTNode, isInClass: Boolean = false): Modifier", "body": "{<EOL> val modifier = Modifier()<EOL> modifiers.forEachChildren {<EOL> if (it.tokenType is KtModifierKeywordToken) {<EOL> modifier.addModifier(it, isInClass)<EOL> }"}
{"docstring": " Convert only annotations see orgjetbrainskotlinparsingKotlinParsingparseModifierList private fun convertAnnotationListannotations LighterASTNode ListFirAnnotationCall return annotationsforEachChildrenReturnListFirAnnotationCall node list when nodetokenType ANNOTATION list convertAnnotationnode ANNOTATION_ENTRY list convertAnnotationEntrynode see orgjetbrainskotlinparsingKotlinParsingparseTypeModifierList ", "modifier": "private ", "signature": "fun convertTypeModifierList(modifiers: LighterASTNode): Modifier", "body": "{<EOL> val typeModifier = Modifier()<EOL> modifiers.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION -> typeModifier.annotations += convertAnnotation(it)<EOL> ANNOTATION_ENTRY -> typeModifier.annotations += convertAnnotationEntry(it)<EOL> is KtModifierKeywordToken -> typeModifier.addModifier(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeArgumentModifierList ", "modifier": "private ", "signature": "fun convertTypeArgumentModifierList(modifiers: LighterASTNode): TypeProjectionModifier", "body": "{<EOL> val typeArgumentModifier = TypeProjectionModifier()<EOL> modifiers.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION -> typeArgumentModifier.annotations += convertAnnotation(it)<EOL> ANNOTATION_ENTRY -> typeArgumentModifier.annotations += convertAnnotationEntry(it)<EOL> is KtModifierKeywordToken -> typeArgumentModifier.addModifier(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeArgumentModifierList ", "modifier": "private ", "signature": "fun convertTypeParameterModifiers(modifiers: LighterASTNode): TypeParameterModifier", "body": "{<EOL> val modifier = TypeParameterModifier()<EOL> modifiers.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION -> modifier.annotations += convertAnnotation(it)<EOL> ANNOTATION_ENTRY -> modifier.annotations += convertAnnotationEntry(it)<EOL> is KtModifierKeywordToken -> modifier.addModifier(it)<EOL> }"}
{"docstring": " ANNOTATIONS see orgjetbrainskotlinparsingKotlinParsingparseAnnotationOrList fun convertAnnotationannotationNode LighterASTNode ListFirAnnotationCall var annotationTarget AnnotationUseSiteTarget null return annotationNodeforEachChildrenReturnList node container when nodetokenType ANNOTATION_TARGET annotationTarget convertAnnotationTargetnode ANNOTATION_ENTRY container convertAnnotationEntrynode annotationTarget see orgjetbrainskotlinparsingKotlinParsingparseAnnotationTarget ", "modifier": "private ", "signature": "fun convertAnnotationTarget(annotationUseSiteTarget: LighterASTNode): AnnotationUseSiteTarget", "body": "{<EOL> lateinit var annotationTarget: AnnotationUseSiteTarget<EOL> annotationUseSiteTarget.forEachChildren {<EOL> when (it.tokenType) {<EOL> FIELD_KEYWORD -> annotationTarget = FIELD<EOL> FILE_KEYWORD -> annotationTarget = FILE<EOL> PROPERTY_KEYWORD -> annotationTarget = AnnotationUseSiteTarget.PROPERTY<EOL> GET_KEYWORD -> annotationTarget = PROPERTY_GETTER<EOL> SET_KEYWORD -> annotationTarget = PROPERTY_SETTER<EOL> RECEIVER_KEYWORD -> annotationTarget = RECEIVER<EOL> PARAM_KEYWORD -> annotationTarget = CONSTRUCTOR_PARAMETER<EOL> SETPARAM_KEYWORD -> annotationTarget = SETTER_PARAMETER<EOL> DELEGATE_KEYWORD -> annotationTarget = PROPERTY_DELEGATE_FIELD<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseAnnotation can be treated as unescapedAnnotation ", "modifier": "", "signature": "fun convertAnnotationEntry(\n        unescapedAnnotation: LighterASTNode,\n        defaultAnnotationUseSiteTarget: AnnotationUseSiteTarget? = null,\n        diagnostic: ConeDiagnostic? = null,\n    ): FirAnnotationCall", "body": "{<EOL> var annotationUseSiteTarget: AnnotationUseSiteTarget? = null<EOL> lateinit var constructorCalleePair: Pair<FirTypeRef, List<FirExpression>><EOL> unescapedAnnotation.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION_TARGET -> annotationUseSiteTarget = convertAnnotationTarget(it)<EOL> CONSTRUCTOR_CALLEE -> constructorCalleePair = convertConstructorInvocation(unescapedAnnotation)<EOL> }"}
{"docstring": " DECLARATIONS see orgjetbrainskotlinparsingKotlinParsingparseClassOrObject ", "modifier": "private ", "signature": "fun convertClass(classNode: LighterASTNode): FirDeclaration", "body": "{<EOL> var modifiers: Modifier? = null<EOL> var classKind: ClassKind = ClassKind.CLASS<EOL> var identifier: String? = null<EOL> val firTypeParameters = mutableListOf<FirTypeParameter>()<EOL> var primaryConstructor: LighterASTNode? = null<EOL> val typeConstraints = mutableListOf<TypeConstraint>()<EOL> val classAnnotations = mutableListOf<FirAnnotationCall>()<EOL> var classBody: LighterASTNode? = null<EOL> var superTypeList: LighterASTNode? = null<EOL> var typeParameterList: LighterASTNode? = null<EOL> classNode.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> modifiers = convertModifierList(it, isInClass = true)<EOL> IDENTIFIER -> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinExpressionParsingparseObjectLiteral see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitObjectLiteralExpression ", "modifier": "", "signature": "fun convertObjectLiteral(objectLiteral: LighterASTNode): FirElement", "body": "{<EOL> return withChildClassName(SpecialNames.ANONYMOUS, forceLocalContext = true, isExpect = false) {<EOL> var delegatedFieldsMap: Map<Int, FirFieldSymbol>? = null<EOL> buildAnonymousObjectExpression {<EOL> source = objectLiteral.toFirSourceElement()<EOL> anonymousObject = buildAnonymousObject {<EOL> val objectDeclaration = objectLiteral.getChildNodesByType(OBJECT_DECLARATION).first()<EOL> source = objectDeclaration.toFirSourceElement()<EOL> origin = FirDeclarationOrigin.Source<EOL> moduleData = baseModuleData<EOL> classKind = ClassKind.CLASS<EOL> scopeProvider = baseScopeProvider<EOL> symbol = FirAnonymousObjectSymbol(context.packageFqName)<EOL> status = FirDeclarationStatusImpl(Visibilities.Local, Modality.FINAL)<EOL> context.appendOuterTypeParameters(ignoreLastLevel = false, typeParameters)<EOL> val delegatedSelfType = objectDeclaration.toDelegatedSelfType(this)<EOL> registerSelfType(delegatedSelfType)<EOL><EOL> var modifiers: Modifier? = null<EOL> val objectAnnotations = mutableListOf<FirAnnotationCall>()<EOL> var primaryConstructor: LighterASTNode? = null<EOL> val superTypeRefs = mutableListOf<FirTypeRef>()<EOL> var delegatedSuperTypeRef: FirTypeRef? = null<EOL> var classBody: LighterASTNode? = null<EOL> var delegatedConstructorSource: KtLightSourceElement? = null<EOL> var delegatedSuperCalls: List<DelegatedConstructorWrapper>? = null<EOL> var delegateFields: List<FirField>? = null<EOL><EOL> objectDeclaration.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> {<EOL> modifiers = convertModifierList(it)<EOL> objectAnnotations += convertAnnotationList(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseEnumEntry ", "modifier": "private ", "signature": "fun convertEnumEntry(enumEntry: LighterASTNode, classWrapper: ClassWrapper): FirEnumEntry", "body": "{<EOL> var modifiers: Modifier? = null<EOL> val entryAnnotations = mutableListOf<FirAnnotationCall>()<EOL> lateinit var identifier: String<EOL> val enumSuperTypeCallEntry = mutableListOf<FirExpression>()<EOL> var classBodyNode: LighterASTNode? = null<EOL> var superTypeCallEntry: LighterASTNode? = null<EOL> enumEntry.getChildNodeByType(IDENTIFIER)?.let {<EOL> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseMemberDeclarationRest at INIT keyword ", "modifier": "private ", "signature": "fun convertAnonymousInitializer(\n        anonymousInitializer: LighterASTNode,\n        classWrapper: ClassWrapper\n    ): FirDeclaration", "body": "{<EOL> val initializerSymbol = FirAnonymousInitializerSymbol()<EOL> withContainerSymbol(initializerSymbol) {<EOL> var firBlock: FirBlock? = null<EOL> val initializerAnnotations = mutableListOf<FirAnnotationCall>()<EOL> anonymousInitializer.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> initializerAnnotations += convertAnnotationList(it)<EOL> BLOCK -> withForcedLocalContext {<EOL> firBlock = convertBlock(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseSecondaryConstructor ", "modifier": "private ", "signature": "fun convertSecondaryConstructor(secondaryConstructor: LighterASTNode, classWrapper: ClassWrapper): FirConstructor", "body": "{<EOL> var modifiers: Modifier? = null<EOL> val constructorAnnotations = mutableListOf<FirAnnotationCall>()<EOL> val firValueParameters = mutableListOf<ValueParameter>()<EOL> var constructorDelegationCall: FirDelegatedConstructorCall? = null<EOL> var block: LighterASTNode? = null<EOL><EOL> val constructorSymbol = FirConstructorSymbol(callableIdForClassConstructor())<EOL> withContainerSymbol(constructorSymbol) {<EOL> secondaryConstructor.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> {<EOL> modifiers = convertModifierList(it)<EOL> constructorAnnotations += convertAnnotationList(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorconvert KtConstructorDelegationCall FirTypeRef Boolean private fun convertConstructorDelegationCall constructorDelegationCall LighterASTNode classWrapper ClassWrapper FirDelegatedConstructorCall var thisKeywordPresent false val firValueArguments mutableListOfFirExpression constructorDelegationCallforEachChildren when ittokenType CONSTRUCTOR_DELEGATION_REFERENCE if itasText this thisKeywordPresent true VALUE_ARGUMENT_LIST firValueArguments expressionConverterconvertValueArgumentsit val isImplicit constructorDelegationCalltextLength 0 if isImplicit classWrappermodifiershasExternal return null val isThis thisKeywordPresent isImplicit classWrapperhasPrimaryConstructor val delegatedType when isThis classWrapperdelegatedSelfTypeRef else classWrapperdelegatedSuperTypeRef return buildDelegatedConstructorCall source if isImplicit constructorDelegationCalltoFirSourceElementfakeElementKtFakeSourceElementKindImplicitConstructor else constructorDelegationCalltoFirSourceElement constructedTypeRef delegatedTypecopyWithNewSourceKindKtFakeSourceElementKindImplicitTypeRef thisisThis isThis val calleeKind if isImplicit KtFakeSourceElementKindImplicitConstructor else KtFakeSourceElementKindDelegatingConstructorCall val calleeSource constructorDelegationCallgetChildNodeByTypeCONSTRUCTOR_DELEGATION_REFERENCE toFirSourceElementcalleeKind thisbuildDelegatedConstructorCallsourcefakeElementcalleeKind calleeReference if isThis buildExplicitThisReference thissource calleeSource else buildExplicitSuperReference source calleeSource superTypeRef thisbuildDelegatedConstructorCallconstructedTypeRef extractArgumentsFromfirValueArguments see orgjetbrainskotlinparsingKotlinParsingparseTypeAlias ", "modifier": "private ", "signature": "fun convertTypeAlias(typeAlias: LighterASTNode): FirDeclaration", "body": "{<EOL> var modifiers: Modifier? = null<EOL> var identifier: String? = null<EOL> lateinit var firType: FirTypeRef<EOL> val aliasAnnotations = mutableListOf<FirAnnotationCall>()<EOL><EOL> typeAlias.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> modifiers = convertModifierList(it)<EOL> IDENTIFIER -> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseProperty ", "modifier": "", "signature": "fun convertPropertyDeclaration(property: LighterASTNode, classWrapper: ClassWrapper? = null): FirDeclaration", "body": "{<EOL> var modifiers: Modifier? = null<EOL> val propertyAnnotations = mutableListOf<FirAnnotationCall>()<EOL> var identifier: String? = null<EOL> val firTypeParameters = mutableListOf<FirTypeParameter>()<EOL> var isReturnType = false<EOL> var delegate: LighterASTNode? = null<EOL> var isVar = false<EOL> var receiverType: FirTypeRef? = null<EOL> var returnType: FirTypeRef = implicitType<EOL> val typeConstraints = mutableListOf<TypeConstraint>()<EOL> val accessors = mutableListOf<LighterASTNode>()<EOL> var propertyInitializer: FirExpression? = null<EOL> var typeParameterList: LighterASTNode? = null<EOL> var fieldDeclaration: LighterASTNode? = null<EOL> property.getChildNodeByType(IDENTIFIER)?.let {<EOL> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorvisitDestructuringDeclaration internal fun convertDestructingDeclarationdestructingDeclaration LighterASTNode DestructuringDeclaration val annotations mutableListOfFirAnnotationCall var isVar false val entries mutableListOfDestructuringEntry val source destructingDeclarationtoFirSourceElement var firExpression FirExpression null destructingDeclarationforEachChildren when ittokenType MODIFIER_LIST annotations convertAnnotationListit VAR_KEYWORD isVar true DESTRUCTURING_DECLARATION_ENTRY entries convertDestructingDeclarationEntryit Property delegates should be ignored as they arent a valid initializers PROPERTY_DELEGATE else if itisExpression firExpression expressionConvertergetAsFirExpressionit Initializer required for destructuring declaration return DestructuringDeclaration isVar entries firExpression buildErrorExpression null ConeSyntaxDiagnosticInitializer required for destructuring declaration source annotations see orgjetbrainskotlinparsingKotlinParsingparseMultiDeclarationName ", "modifier": "private ", "signature": "fun convertDestructingDeclarationEntry(entry: LighterASTNode): DestructuringEntry", "body": "{<EOL> val annotations = mutableListOf<FirAnnotationCall>()<EOL> var identifier: String? = null<EOL> var firType: FirTypeRef? = null<EOL> entry.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> annotations += convertAnnotationList(it)<EOL> IDENTIFIER -> identifier = it.asText<EOL> TYPE_REFERENCE -> firType = convertType(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparsePropertyComponent ", "modifier": "private ", "signature": "fun convertGetterOrSetter(\n        getterOrSetter: LighterASTNode,\n        propertyTypeRef: FirTypeRef,\n        propertyVisibility: Visibility,\n        propertySymbol: FirPropertySymbol,\n        propertyModifiers: Modifier,\n        propertyAnnotations: List<FirAnnotationCall>,\n    ): FirPropertyAccessor", "body": "{<EOL> var modifiers: Modifier? = null<EOL> val accessorAnnotations = mutableListOf<FirAnnotationCall>()<EOL> var isGetter = true<EOL> var returnType: FirTypeRef? = null<EOL> val propertyTypeRefToUse = propertyTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.ImplicitTypeRef)<EOL> val accessorSymbol = FirPropertyAccessorSymbol()<EOL> var firValueParameters: FirValueParameter = buildDefaultSetterValueParameter {<EOL> moduleData = baseModuleData<EOL> containingFunctionSymbol = accessorSymbol<EOL> origin = FirDeclarationOrigin.Source<EOL> returnTypeRef = propertyTypeRefToUse<EOL> symbol = FirValueParameterSymbol(StandardNames.DEFAULT_VALUE_PARAMETER)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparsePropertyComponent private fun LighterASTNodeconvertBackingField propertySymbol FirPropertySymbol propertyModifiers Modifier propertyReturnType FirTypeRef isVar Boolean annotationsFromProperty ListFirAnnotationCall property LighterASTNode FirBackingField var modifiers Modifier null val fieldAnnotations mutableListOfFirAnnotationCall var returnType FirTypeRef implicitType var backingFieldInitializer FirExpression null thisforEachChildren when ittokenType MODIFIER_LIST modifiers convertModifierListit fieldAnnotations convertAnnotationListit ittokenType TYPE_REFERENCE returnType convertTypeit itisExpression backingFieldInitializer expressionConvertergetAsFirExpressionit Should have initializer val calculatedModifiers modifiers Modifier var componentVisibility calculatedModifiersgetVisibility if componentVisibility VisibilitiesUnknown componentVisibility VisibilitiesPrivate val status obtainPropertyComponentStatuscomponentVisibility calculatedModifiers propertyModifiers val sourceElement thistoFirSourceElement return if this null buildBackingField source sourceElement moduleData baseModuleData origin FirDeclarationOriginSource returnTypeRef returnType name StandardNamesBACKING_FIELD symbol FirBackingFieldSymbolCallableIdname thisstatus status annotations fieldAnnotations annotations annotationsFromProperty thispropertySymbol propertySymbol thisinitializer backingFieldInitializer thisisVar isVar thisisVal isVar else FirDefaultPropertyBackingField moduleData baseModuleData origin FirDeclarationOriginSource source propertytoFirSourceElementKtFakeSourceElementKindDefaultAccessor annotations annotationsFromPropertytoMutableList returnTypeRef propertyReturnTypecopyWithNewSourceKindKtFakeSourceElementKindDefaultAccessor isVar isVar propertySymbol propertySymbol status status private fun obtainPropertyComponentStatus componentVisibility Visibility modifiers Modifier propertyModifiers Modifier FirDeclarationStatus Downward propagation of inline and external modifiers from property to its accessors return FirDeclarationStatusImplcomponentVisibility modifiersgetModalityisClassOrObject falseapply isInline propertyModifiershasInline modifiershasInline isExternal propertyModifiershasExternal modifiershasExternal isLateInit modifiershasLateinit private fun obtainContractDescriptionrawContractDescription LighterASTNode FirContractDescription buildRawContractDescription source rawContractDescriptiontoFirSourceElement extractRawEffectsrawContractDescription rawEffects private fun extractRawEffectsrawContractDescription LighterASTNode destination MutableListFirExpression rawContractDescriptionforEachChildren val errorReason The contract effect is not an expression when ittokenType CONTRACT_EFFECT val effect itgetFirstChild if effect null val errorExpression buildErrorExpressionnull ConeSimpleDiagnosticerrorReason DiagnosticKindExpressionExpected destinationadderrorExpression else val expression expressionConverterconvertExpressioneffect errorReason destinationaddexpression as FirExpression else Unit this is just a VALUE_PARAMETER_LIST see orgjetbrainskotlinparsingKotlinParsingparsePropertyComponent see orgjetbrainskotlinfirbuilderRawFirBuilderVisitortoFirValueParameter ", "modifier": "private ", "signature": "fun convertSetterParameter(\n        setterParameter: LighterASTNode,\n        functionSymbol: FirFunctionSymbol<*>,\n        propertyTypeRef: FirTypeRef,\n        additionalAnnotations: List<FirAnnotation>\n    ): FirValueParameter", "body": "{<EOL> var modifiers: Modifier? = null<EOL> lateinit var firValueParameter: FirValueParameter<EOL> setterParameter.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> modifiers = convertModifierList(it)<EOL> VALUE_PARAMETER -> firValueParameter = convertValueParameter(it, functionSymbol, ValueParameterDeclaration.SETTER).firValueParameter<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseFunction ", "modifier": "", "signature": "fun convertFunctionDeclaration(functionDeclaration: LighterASTNode): FirStatement", "body": "{<EOL> var modifiers: Modifier? = null<EOL> val functionAnnotations = mutableListOf<FirAnnotationCall>()<EOL> var identifier: String? = null<EOL> var valueParametersList: LighterASTNode? = null<EOL> var isReturnType = false<EOL> var receiverType: FirTypeRef? = null<EOL> var returnType: FirTypeRef? = null<EOL> val typeConstraints = mutableListOf<TypeConstraint>()<EOL> var block: LighterASTNode? = null<EOL> var expression: LighterASTNode? = null<EOL> var hasEqToken = false<EOL> var typeParameterList: LighterASTNode? = null<EOL> var outerContractDescription: FirContractDescription? = null<EOL> functionDeclaration.getChildNodeByType(IDENTIFIER)?.let {<EOL> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseFunctionBody see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorbuildFirBody private fun convertFunctionBody blockNode LighterASTNode expression LighterASTNode allowLegacyContractDescription Boolean PairFirBlock FirContractDescription return when blockNode null val block convertBlockblockNode val contractDescription runIfallowLegacyContractDescription val blockSource blocksource val diagnostic when blockSource null isCallTheFirstStatementblockSource ConeContractShouldBeFirstStatement else null processLegacyContractDescriptionblock diagnostic block to contractDescription expression null FirSingleExpressionBlock expressionConvertergetAsFirExpressionFirExpressionexpression Function has no body but shouldtoReturn to null else null to null private fun isCallTheFirstStatementsourceElement KtSourceElement Boolean isCallTheFirstStatementsourceElementlighterASTNode itelementType itgetChildrensourceElementtreeStructure see orgjetbrainskotlinparsingKotlinParsingparseBlock ", "modifier": "", "signature": "fun convertBlock(block: LighterASTNode?): FirBlock", "body": "{<EOL> if (block == null) return buildEmptyExpressionBlock()<EOL> if (block.tokenType != BLOCK) {<EOL> return FirSingleExpressionBlock(<EOL> expressionConverter.getAsFirStatement(block)<EOL> )<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseDelegationSpecifierList see orgjetbrainskotlinfirbuilderRawFirBuilderVisitorextractSuperTypeListEntriesTo SUPER_TYPE_ENTRY userType SUPER_TYPE_CALL_ENTRY constructorInvocation DELEGATED_SUPER_TYPE_ENTRY explicitDelegation TODO make wrapper for result private data class DelegationSpecifiers val superTypeCalls ListDelegatedConstructorWrapper val superTypesRef ListFirTypeRef val delegateFieldsMap MapInt FirFieldSymbol private fun convertDelegationSpecifiersdelegationSpecifiers LighterASTNode DelegationSpecifiers val superTypeRefs mutableListOfFirTypeRef val superTypeCalls mutableListOfDelegatedConstructorWrapper val delegateFieldsMap mutableMapOfInt FirFieldSymbol var index 0 delegationSpecifiersforEachChildren when ittokenType SUPER_TYPE_ENTRY superTypeRefs convertTypeit index SUPER_TYPE_CALL_ENTRY convertConstructorInvocationitapply superTypeCalls DelegatedConstructorWrapperfirst second ittoFirSourceElement superTypeRefs first index DELEGATED_SUPER_TYPE_ENTRY superTypeRefs convertExplicitDelegationit delegateFieldsMap index index return DelegationSpecifierssuperTypeCalls superTypeRefs delegateFieldsMap see orgjetbrainskotlinparsingKotlinParsingparseDelegationSpecifier constructorInvocation userType valueArguments private fun convertConstructorInvocationconstructorInvocation LighterASTNode PairFirTypeRef ListFirExpression var firTypeRef FirTypeRef implicitType val firValueArguments mutableListOfFirExpression constructorInvocationforEachChildren when ittokenType CONSTRUCTOR_CALLEE firTypeRef convertTypeit VALUE_ARGUMENT_LIST firValueArguments expressionConverterconvertValueArgumentsit return PairfirTypeRef firValueArguments see orgjetbrainskotlinparsingKotlinParsingparseDelegationSpecifier explicitDelegation userType by element ", "modifier": "private ", "signature": "fun convertExplicitDelegation(\n        explicitDelegation: LighterASTNode,\n        delegateFieldsMap: MutableMap<Int, FirFieldSymbol>,\n        index: Int\n    ): FirTypeRef", "body": "{<EOL> lateinit var firTypeRef: FirTypeRef<EOL> var firExpression: FirExpression? = null<EOL> explicitDelegation.forEachChildren {<EOL> when (it.tokenType) {<EOL> TYPE_REFERENCE -> firTypeRef = convertType(it)<EOL> else -> if (it.isExpression()) firExpression = expressionConverter.getAsFirExpression(it, \"Should have delegate\")<EOL> }"}
{"docstring": " TYPES see orgjetbrainskotlinparsingKotlinParsingparseTypeParameterList private fun convertTypeParameters typeParameterList LighterASTNode typeConstraints ListTypeConstraint containingDeclarationSymbol FirBasedSymbol ListFirTypeParameter return typeParameterListforEachChildrenReturnList node container when nodetokenType TYPE_PARAMETER container convertTypeParameternode typeConstraints containingDeclarationSymbol see orgjetbrainskotlinparsingKotlinParsingparseTypeConstraintList private fun convertTypeConstraintstypeConstraints LighterASTNode ListTypeConstraint return typeConstraintsforEachChildrenReturnList node container when nodetokenType TYPE_CONSTRAINT container convertTypeConstraintnode see orgjetbrainskotlinparsingKotlinParsingparseTypeConstraint ", "modifier": "private ", "signature": "fun convertTypeConstraint(typeConstraint: LighterASTNode): TypeConstraint", "body": "{<EOL> var identifier: String? = null<EOL> var firType: FirTypeRef? = null<EOL> var referenceExpression: LighterASTNode? = null<EOL><EOL> val annotations = mutableListOf<FirAnnotation>()<EOL> typeConstraint.forEachChildren {<EOL> when (it.tokenType) {<EOL> ANNOTATION_ENTRY -> {<EOL> annotations +=<EOL> convertAnnotationEntry(<EOL> it,<EOL> diagnostic = ConeSimpleDiagnostic(<EOL> \"Type parameter annotations are not allowed inside where clauses\", DiagnosticKind.AnnotationNotAllowed,<EOL> )<EOL> )<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeParameter ", "modifier": "private ", "signature": "fun convertTypeParameter(\n        typeParameter: LighterASTNode,\n        typeConstraints: List<TypeConstraint>,\n        containingSymbol: FirBasedSymbol<*>\n    ): FirTypeParameter", "body": "{<EOL> var typeParameterModifiers: TypeParameterModifier? = null<EOL> var identifier: String? = null<EOL> var firType: FirTypeRef? = null<EOL> typeParameter.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> typeParameterModifiers = convertTypeParameterModifiers(it)<EOL> IDENTIFIER -> identifier = it.asText<EOL> TYPE_REFERENCE -> firType = convertType(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeRef ", "modifier": "", "signature": "fun convertType(type: LighterASTNode): FirTypeRef", "body": "{<EOL> val typeRefSource = type.toFirSourceElement()<EOL><EOL> // There can be MODIFIER_LIST children on the TYPE_REFERENCE node AND the descendant NULLABLE_TYPE nodes.<EOL> // We aggregate them to get modifiers and annotations. Not only that, there could be multiple modifier lists on each. Examples:<EOL> //<EOL> // `@A() (@B Int)` -> Has 2 modifier lists (@A and @B) in TYPE_REFERENCE<EOL> // `(@A() (@B Int))? -> No modifier list on TYPE_REFERENCE, but 2 modifier lists (@A and @B) on child NULLABLE_TYPE<EOL> // `@A() (@B Int)? -> Has 1 modifier list (@A) on TYPE_REFERENCE, and 1 modifier list (@B) on child NULLABLE_TYPE<EOL> // `@A (@B() (@C() (@Bar D)?)?)?` -> Has 1 modifier list (@A) on B and 1 modifier list on each of the<EOL> // 3 descendant NULLABLE_TYPE (@B, @C, @D)<EOL> //<EOL> // We need to examine all modifier lists for some cases:<EOL> // 1. `@A Int?` and `(@A Int)?` are effectively the same, but in the latter, the modifier list is on the child NULLABLE_TYPE<EOL> // 2. `(suspend @A () -> Int)?` is a nullable suspend function type but the modifier list is on the child NULLABLE_TYPE<EOL> //<EOL> // TODO: Report MODIFIER_LIST_NOT_ALLOWED error when there are multiple modifier lists. How do we report on each of them?<EOL> val allTypeModifiers = mutableListOf<Modifier>()<EOL><EOL> var firType: FirTypeRef? = null<EOL> type.forEachChildren {<EOL> when (it.tokenType) {<EOL> TYPE_REFERENCE -> firType = convertType(it)<EOL> MODIFIER_LIST -> allTypeModifiers += convertTypeModifierList(it)<EOL> USER_TYPE -> firType = convertUserType(typeRefSource, it)<EOL> NULLABLE_TYPE -> firType = convertNullableType(typeRefSource, it, allTypeModifiers)<EOL> FUNCTION_TYPE -> firType = convertFunctionType(typeRefSource, it, isSuspend = allTypeModifiers.hasSuspend())<EOL> DYNAMIC_TYPE -> firType = buildDynamicTypeRef {<EOL> source = typeRefSource<EOL> isMarkedNullable = false<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeRefContents ", "modifier": "private ", "signature": "fun convertReceiverType(receiverType: LighterASTNode): FirTypeRef", "body": "{<EOL> receiverType.forEachChildren {<EOL> when (it.tokenType) {<EOL> TYPE_REFERENCE -> return convertType(it)<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseNullableTypeSuffix ", "modifier": "private ", "signature": "fun convertNullableType(\n        typeRefSource: KtSourceElement,\n        nullableType: LighterASTNode,\n        allTypeModifiers: MutableList<Modifier>,\n        isNullable: Boolean = true\n    ): FirTypeRef", "body": "{<EOL> lateinit var firType: FirTypeRef<EOL> nullableType.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> allTypeModifiers += convertTypeModifierList(it)<EOL> USER_TYPE -> firType = convertUserType(typeRefSource, it, isNullable)<EOL> FUNCTION_TYPE -> firType = convertFunctionType(typeRefSource, it, isNullable, isSuspend = allTypeModifiers.hasSuspend())<EOL> NULLABLE_TYPE -> firType = convertNullableType(typeRefSource, it, allTypeModifiers)<EOL> DYNAMIC_TYPE -> firType = buildDynamicTypeRef {<EOL> source = typeRefSource<EOL> isMarkedNullable = true<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseUserType ", "modifier": "private ", "signature": "fun convertUserType(\n        typeRefSource: KtSourceElement,\n        userType: LighterASTNode,\n        isNullable: Boolean = false\n    ): FirTypeRef", "body": "{<EOL> var simpleFirUserType: FirUserTypeRef? = null<EOL> var identifier: String? = null<EOL> var identifierSource: KtSourceElement? = null<EOL> val firTypeArguments = mutableListOf<FirTypeProjection>()<EOL> var typeArgumentsSource: KtSourceElement? = null<EOL> userType.forEachChildren {<EOL> when (it.tokenType) {<EOL> USER_TYPE -> simpleFirUserType = convertUserType(typeRefSource, it) as? FirUserTypeRef //simple user type<EOL> REFERENCE_EXPRESSION -> {<EOL> identifierSource = it.toFirSourceElement()<EOL> identifier = it.asText<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseTypeArgumentList fun convertTypeArgumentstypeArguments LighterASTNode allowedUnderscoredTypeArgument Boolean ListFirTypeProjection return typeArgumentsforEachChildrenReturnList node container when nodetokenType TYPE_PROJECTION container convertTypeProjectionnode allowedUnderscoredTypeArgument see orgjetbrainskotlinparsingKotlinParsingtryParseTypeArgumentList ", "modifier": "private ", "signature": "fun convertTypeProjection(typeProjection: LighterASTNode, allowedUnderscoredTypeArgument: Boolean): FirTypeProjection", "body": "{<EOL> var modifiers: TypeProjectionModifier? = null<EOL> lateinit var firType: FirTypeRef<EOL> var isStarProjection = false<EOL> typeProjection.forEachChildren {<EOL> when (it.tokenType) {<EOL> MODIFIER_LIST -> modifiers = convertTypeArgumentModifierList(it)<EOL> TYPE_REFERENCE -> firType = convertType(it)<EOL> MUL -> isStarProjection = true<EOL> }"}
{"docstring": " see orgjetbrainskotlinparsingKotlinParsingparseFunctionType ", "modifier": "private ", "signature": "fun convertFunctionType(\n        typeRefSource: KtSourceElement,\n        functionType: LighterASTNode,\n        isNullable: Boolean = false,\n        isSuspend: Boolean = false\n    ): FirTypeRef", "body": "{<EOL> var receiverTypeReference: FirTypeRef? = null<EOL> lateinit var returnTypeReference: FirTypeRef<EOL> val parameters = mutableListOf<FirFunctionTypeParameter>()<EOL> functionType.forEachChildren {<EOL> when (it.tokenType) {<EOL> FUNCTION_TYPE_RECEIVER -> receiverTypeReference = convertReceiverType(it)<EOL> VALUE_PARAMETER_LIST -> parameters += convertFunctionTypeParameters(it)<EOL> TYPE_REFERENCE -> returnTypeReference = convertType(it)<EOL> }"}
{"docstring": " Creates balanced tree of OR expressions for given set of conditions We do so to avoid too deep ORexpression structures that can cause running out of stack while processing conditions should contain at least one element otherwise it will cause StackOverflow ", "modifier": "", "signature": "fun buildBalancedOrExpressionTree(conditions: List<FirExpression>, lower: Int = 0, upper: Int = conditions.lastIndex): FirExpression", "body": "{<EOL> val size = upper - lower + 1<EOL> val middle = size / 2 + lower<EOL><EOL> if (lower == upper) {<EOL> return conditions[middle]<EOL> }"}
{"docstring": " param type the return type for new field In the case of null will be calculated inside withContainerSymbol so it is crucial to decide to whom type annotation will be belonged ", "modifier": "protected ", "signature": "fun buildFieldForSupertypeDelegate(\n            entry: KtDelegatedSuperTypeEntry,\n            type: FirTypeRef?,\n            fieldOrd: Int,\n        ): FirField", "body": "{<EOL> val delegateSource = entry.toFirSourceElement(KtFakeSourceElementKind.ClassDelegationField)<EOL><EOL> val delegateExpression = buildOrLazyExpression(delegateSource) {<EOL> { entry.delegateExpression }"}
{"docstring": " Checks if the ResolutionResult is valid The PsiSubstitutor which is contained inside ResolutionResult might become invalidated as it contains PsiTypes inside return true if the substitutor is valid false otherwise ", "modifier": "", "signature": "fun isValid(): Boolean", "body": "{<EOL> return substitutor.isValid<EOL> }"}
{"docstring": " Resolves the current JavaClassifierType The code is thread safe and the logic is the following 1 Try to get a cached resolution result and return it if its not invalidated 2 Otherwise resolve the current JavaClassifierType update the cache and return the result returns ResolutionResult to which the JavaClassifierType resovled ", "modifier": "private ", "signature": "fun resolve(): ResolutionResult", "body": "{<EOL> while (true) {<EOL> val snapshot = resolutionResult<EOL> @Suppress(\"LiftReturnOrAssignment\")<EOL> when {<EOL> snapshot != null && snapshot.isValid() -> {<EOL> return snapshot<EOL> }"}
{"docstring": " Collects returned expressions from current pseudocode Returned expression here last expression in controlflow terms Intuitively it considers all execution paths takes last expression on each path and returns them More specifically this function starts from EXIT instruction and performs DFSsearch on reversed controlflow edges in a following manner if the current instruction is a Returninstruction then add its expression to result if the current instruction is a Elementinstruction then add its element to result if the current instruction is a Jumpinstruction then process its predecessors recursively NB The second case Elementinstruction means that notion of returned expression here differs from what the language treats as returned expression notably in the presence of Unitcoercion Example fun foo val x 42 xinc This call will be in a returnedExpressions even though this expression isnt actually returned ", "modifier": "private ", "signature": "fun collectReturnExpressions(): ReturnedExpressionsInfo", "body": "{<EOL> val instructions = pseudocode.instructions.toHashSet()<EOL> val exitInstruction = pseudocode.exitInstruction<EOL><EOL> val returnedExpressions = arrayListOf<KtElement>()<EOL> var hasReturnsInInlinedLambda = false<EOL><EOL> for (previousInstruction in exitInstruction.previousInstructions) {<EOL> previousInstruction.accept(object : InstructionVisitor() {<EOL> override fun visitReturnValue(instruction: ReturnValueInstruction) {<EOL> if (instructions.contains(instruction)) { //exclude non-local return expressions<EOL> returnedExpressions.add(instruction.element)<EOL> }"}
{"docstring": " This overload exists just for sake of optimizations in some cases weve just retrieved the old value so we dont need to scan through the persistent hashmap again ", "modifier": "", "signature": "fun put(key: K, value: D, oldValue: D?): S", "body": "{<EOL> @Suppress(\"UNCHECKED_CAST\")<EOL> // Avoid a copy instance creation if new value is the same<EOL> if (value == oldValue) return this as S<EOL> return copy(map.put(key, value))<EOL> }"}
{"docstring": " Two types are related roughly when one of them is a subtype of the other constructing class Note that some types have platformspecific counterparts ie kotlinString is mapped to javalangString such types and all their sub and supertypes are related too Due to limitations in PlatformToKotlinClassMap we only consider mapping of platform classes to Kotlin classed ie javalangString kotlinString and ignore mappings that go the other way ", "modifier": "private ", "signature": "fun isRelated(a: KotlinType, b: KotlinType, platformToKotlinClassMapper: PlatformToKotlinClassMapper): Boolean", "body": "{<EOL> val aClasses = mapToPlatformIndependentClasses(a, platformToKotlinClassMapper)<EOL> val bClasses = mapToPlatformIndependentClasses(b, platformToKotlinClassMapper)<EOL><EOL> return aClasses.any { DescriptorUtils.isSubtypeOfClass(b, it) }"}
{"docstring": " Does not check names ", "modifier": "", "signature": "fun isOverloadable(a: DeclarationDescriptor, b: DeclarationDescriptor): Boolean", "body": "{<EOL> val aCategory = getDeclarationCategory(a)<EOL> val bCategory = getDeclarationCategory(b)<EOL><EOL> if (aCategory != bCategory) return true<EOL> if (a !is CallableDescriptor || b !is CallableDescriptor) return false<EOL><EOL> return checkOverloadability(a, b)<EOL> }"}
{"docstring": " Type alias can be used as bare type after isas eg x is List iff all type arguments of the corresponding expanded type are either star projections or type parameters of the given type alias in invariant projection and each of the type parameters is mentioned no more than once Eg typealias HashMapK V javautilHashMapK V can be used as bare type typealias MyListT X ListX can be used as bare type typealias StarMapT MapT can be used as bare type typealias MyMapT MapT T CAN NOT be used as bare type type parameter T is used twice typealias StringMapT MapString T CAN NOT be used as bare type type argument String is not a type parameter ", "modifier": "private ", "signature": "fun canBeUsedAsBareType(descriptor: TypeAliasDescriptor): Boolean", "body": "{<EOL> val expandedType = descriptor.expandedType<EOL> if (expandedType.isError) return false<EOL><EOL> val classDescriptor = descriptor.classDescriptor ?: return false<EOL> if (!isPossibleToSpecifyTypeArgumentsFor(classDescriptor)) return false<EOL><EOL> val usedTypeParameters = linkedSetOf<TypeParameterDescriptor>()<EOL> for (argument in expandedType.arguments) {<EOL> if (argument.isStarProjection) continue<EOL><EOL> if (argument.projectionKind != INVARIANT) return false<EOL><EOL> val argumentTypeDescriptor = argument.type.constructor.declarationDescriptor as? TypeParameterDescriptor ?: return false<EOL> if (argumentTypeDescriptor.containingDeclaration != descriptor) return false<EOL> if (usedTypeParameters.contains(argumentTypeDescriptor)) return false<EOL><EOL> usedTypeParameters.add(argumentTypeDescriptor)<EOL> }"}
{"docstring": " Visits a call expression and its arguments Determines the result type and data flow information after the call ", "modifier": "private ", "signature": "fun getCallExpressionTypeInfoWithoutFinalTypeCheck(\n        callExpression: KtCallExpression, receiver: Receiver?,\n        callOperationNode: ASTNode?, context: ExpressionTypingContext,\n        initialDataFlowInfoForArguments: DataFlowInfo\n    ): KotlinTypeInfo", "body": "{<EOL> val call = CallMaker.makeCall(receiver, callOperationNode, callExpression)<EOL><EOL> val temporaryForFunction = TemporaryTraceAndCache.create(<EOL> context, \"trace to resolve as function call\", callExpression<EOL> )<EOL> val (resolveResult, resolvedCall) = getResolvedCallForFunction(<EOL> call,<EOL> context.replaceTraceAndCache(temporaryForFunction),<EOL> CheckArgumentTypesMode.CHECK_VALUE_ARGUMENTS,<EOL> initialDataFlowInfoForArguments<EOL> )<EOL> if (resolveResult) {<EOL> val functionDescriptor = resolvedCall?.resultingDescriptor<EOL> temporaryForFunction.commit()<EOL> if (callExpression.valueArgumentList == null && callExpression.lambdaArguments.isEmpty()) {<EOL> // there are only type arguments<EOL> val hasValueParameters = functionDescriptor == null || functionDescriptor.valueParameters.size > 0<EOL> context.trace.report(FUNCTION_CALL_EXPECTED.on(callExpression, callExpression, hasValueParameters))<EOL> }"}
{"docstring": " Visits a qualified expression like xy or xz controlling data flow information changes return qualified expression type together with data flow information ", "modifier": "", "signature": "fun getQualifiedExpressionTypeInfo(expression: KtQualifiedExpression, context: ExpressionTypingContext): KotlinTypeInfo", "body": "{<EOL> val currentContext = context.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT)<EOL> val trace = currentContext.trace<EOL><EOL> val elementChain = expression.elementChain(currentContext)<EOL> val firstReceiver = elementChain.first().receiver<EOL><EOL> var receiverTypeInfo = when (trace.get(BindingContext.QUALIFIER, firstReceiver)) {<EOL> null -> expressionTypingServices.getTypeInfo(firstReceiver, currentContext)<EOL> else -> KotlinTypeInfo(null, currentContext.dataFlowInfo)<EOL> }"}
{"docstring": " Exclusion list 1 Primary constructors of public API classes 2 Properties of data classes in public API 3 Overrides of public API Effectively this means no report on overrides at all 4 Getters and setters because getters cant change visibility and setteronly explicit visibility looks ugly 5 Properties of annotations in public API Do we need something like PublicApiFile to disable or invert this inspection perfile ", "modifier": "", "signature": "fun explicitVisibilityIsNotRequired(descriptor: DeclarationDescriptor): Boolean", "body": "{<EOL> /* 1. */ if ((descriptor as? ClassConstructorDescriptor)?.isPrimary == true) return true<EOL> /* 2. */ if (descriptor is PropertyDescriptor && (descriptor.containingDeclaration as? ClassDescriptor)?.isData == true) return true<EOL> /* 3. */ if ((descriptor as? CallableDescriptor)?.overriddenDescriptors?.isNotEmpty() == true) return true<EOL> /* 4. */ if (descriptor is PropertyAccessorDescriptor) return true<EOL> /* 5. */ if (descriptor is PropertyDescriptor && (descriptor.containingDeclaration as? ClassDescriptor)?.kind == ClassKind.ANNOTATION_CLASS) return true<EOL> return false<EOL> }"}
{"docstring": " Collects calls to be treated as tail calls last expressions which are either direct return statement with a call to other suspend function or for a Unitreturning function a call to other suspend function also returning Unit ", "modifier": "", "signature": "fun collectTailSuspendCalls(context: CommonBackendContext, irFunction: IrSimpleFunction): TailSuspendCalls", "body": "{<EOL> require(irFunction.isSuspend) { \"A suspend function expected: ${irFunction.render()}"}
{"docstring": " This lowering pass optimizes forloops Replace iteration over progressions eg Xindices ab and arrays with a simple while loop over primitive induction variable For example this loop for loopVar in AB Loop body is represented in IR in such a manner val it ABiterator while ithasNext val loopVar itnext Loop body We transform it into one of the following loops 1 If the induction variable cannot overflow ie B is const and MAX_VALUE if increasing or MIN_VALUE if decreasing var inductionVar A val last B if inductionVar last inductionVar last if the progression is decreasing Loop is not empty do val loopVar inductionVar inductionVar inductionVar if the progression is decreasing Loop body while inductionVar last 2 If the induction variable CAN overflow ie last is not const or is MAXMIN_VALUE var inductionVar A val last B if inductionVar last inductionVar last if the progression is decreasing Loop is not empty do val loopVar inductionVar inductionVar inductionVar if the progression is decreasing Loop body while loopVar last If loop is an until loop eg for i in A until B or for i in AB it is transformed into var inductionVar A val last B 1 if inductionVar last B MIN_VALUE Loop is not empty do val loopVar inductionVar inductionVar Loop body while inductionVar last In case of iteration over an array eg for i in array we transform it into the following var inductionVar 0 val last arraysize while inductionVar last val loopVar arrayinductionVar Loop body PhaseDescription name ForLoopsLowering description For loops loweringopen class ForLoopsLoweringval context CommonBackendContext BodyLoweringPass open val loopBodyTransformer ForLoopBodyTransformer get null override fun lowerirBody IrBody container IrDeclaration val oldLoopToNewLoop mutableMapOfIrLoop IrLoop val transformer RangeLoopTransformercontext container as IrSymbolOwner oldLoopToNewLoop loopBodyTransformer irBodytransformChildrenVoidtransformer Update references in breakcontinue irBodytransformChildrenVoidobject IrElementTransformerVoid override fun visitBreakContinuejump IrBreakContinue IrExpression oldLoopToNewLoopjumplooplet jumploop it return jump Abstract class for additional forloop bodies transformations abstract class ForLoopBodyTransformer IrElementTransformerVoid abstract fun transform context CommonBackendContext loopBody IrExpression loopVariable IrVariable forLoopHeader ForLoopHeader loopComponents MapInt IrVariable private class RangeLoopTransformer val context CommonBackendContext val container IrSymbolOwner val oldLoopToNewLoop MutableMapIrLoop IrLoop val loopBodyTransformer ForLoopBodyTransformer null IrElementTransformerVoidWithContext private val headerInfoBuilder DefaultHeaderInfoBuildercontext thisgetScopeOwnerSymbol private val headerProcessor HeaderProcessorcontext headerInfoBuilder thisgetScopeOwnerSymbol fun getScopeOwnerSymbol currentScopescopescopeOwnerSymbol containersymbol override fun visitBlockexpression IrBlock IrExpression LoopExpressionGenerator in psi2ir lowers for loopVar in someIterable Loop body into an IrBlock with origin FOR_LOOP This block has 2 statements 1 The header val it someIterableiterator 2 The inner while loop while ithasNext val loopVar itnext Loop body We primarily need to determine HOW to optimize the for loop from the iterable expression in the header eg if its a withIndex call a progression such as 10 downTo 1 However in some cases eg for withIndex we also need to examine the while loop to determine if we CAN optimize the loop if expressionorigin IrStatementOriginFOR_LOOP return supervisitBlockexpression Not a forloop block val statements expressionstatements assertstatementssize 2 Expected 2 statements in forloop block wasnexpressiondump val iteratorVariable statements0 as IrVariable assertiteratorVariableorigin IrDeclarationOriginFOR_LOOP_ITERATOR Expected FOR_LOOP_ITERATOR origin for iterator variable wasniteratorVariabledump val oldLoop statements1 as IrWhileLoop assertoldLooporigin IrStatementOriginFOR_LOOP_INNER_WHILE Expected FOR_LOOP_INNER_WHILE origin for while loop wasnoldLoopdump val loopHeader headerProcessorextractHeaderiteratorVariable return supervisitBlockexpressionapply specializeIteratorIfPossiblethis The iterable in the header is not supported if loopHeaderloopInitStatementsany it as IrVariabletypeisNothing true return supervisitBlockexpression val loweredHeader lowerHeaderiteratorVariable loopHeader val newLoop loopReplacementExpression lowerWhileLoopoldLoop loopHeader return supervisitBlockexpression Cannot lower the loop We can lower both the header and while loop Update mapping from old to new loop so we can later update references in breakcontinue oldLoopToNewLoopoldLoop newLoop statements0 loweredHeader statements1 loopReplacementExpression return supervisitBlockexpression Lowers the header statement that stores the iterator into the loop variable eg val it someIterableiterator and gather information for building the forloop as a ForLoopHeader Returns null if the forloop cannot be lowered ", "modifier": "private ", "signature": "fun lowerHeader(variable: IrVariable, loopHeader: ForLoopHeader): IrStatement", "body": "{<EOL> // Lower into a composite with additional statements (e.g., induction variable) used in the loop condition and body.<EOL> return IrCompositeImpl(<EOL> variable.startOffset,<EOL> variable.endOffset,<EOL> context.irBuiltIns.unitType,<EOL> null,<EOL> loopHeader.loopInitStatements<EOL> )<EOL> }"}
{"docstring": " see javalanginvokeLambdaMetafactorymetafactory private val jdkMetafactoryHandle Handle OpcodesH_INVOKESTATIC javalanginvokeLambdaMetafactory metafactory LjavalanginvokeMethodHandlesLookup LjavalangString LjavalanginvokeMethodType LjavalanginvokeMethodType LjavalanginvokeMethodHandle LjavalanginvokeMethodType LjavalanginvokeCallSite false see javalanginvokeLambdaMetafactoryaltMetafactory private val jdkAltMetafactoryHandle Handle OpcodesH_INVOKESTATIC javalanginvokeLambdaMetafactory altMetafactory LjavalanginvokeMethodHandlesLookup LjavalangString LjavalanginvokeMethodType LjavalangObject LjavalanginvokeCallSite false override fun visitCallexpression IrCall IrExpression return when expressionsymbol jvmIndyLambdaMetafactoryIntrinsic expressiontransformChildrenVoid rewriteIndyLambdaMetafactoryCallexpression else supervisitCallexpression private class SerializableMethodRefInfo val samType IrType val samMethodSymbol IrSimpleFunctionSymbol val implFunSymbol IrFunctionSymbol val instanceFunSymbol IrFunctionSymbol val requiredBridges CollectionIrSimpleFunction val dynamicCallSymbol IrSimpleFunctionSymbol private class ClassContext val serializableMethodRefInfos ArrayListSerializableMethodRefInfo private val classContextStack ArrayDequeClassContext private fun enterClass ClassContext return ClassContextalso classContextStackpushit private fun leaveClass classContextStackpop private fun getClassContext ClassContext if classContextStackisEmpty throw AssertionErrorNo class context return classContextStacklast override fun visitClassdeclaration IrClass IrStatement val context enterClass val result supervisitClassdeclaration if contextserializableMethodRefInfosisNotEmpty generateDeserializeLambdaMethoddeclaration contextserializableMethodRefInfos leaveClass return result private data class DeserializedLambdaInfo val functionalInterfaceClass String val implMethodHandle Handle val functionalInterfaceMethod Method private fun generateDeserializeLambdaMethod irClass IrClass serializableMethodRefInfos ListSerializableMethodRefInfo fun deserializeLambdalambda javalanginvokeSerializedLambda Object val tmp lambdagetImplMethodName when tmp NAME_i when lambdagetImplMethodKind LAMBDA_i_kimplMethodKind lambdagetFunctionalInterfaceClass LAMBDA_i_kfunctionalInterfaceClass lambdagetFunctionalInterfaceMethodName LAMBDA_i_kfunctionalInterfaceMethodName lambdagetFunctionalInterfaceMethodSignature LAMBDA_i_kfunctionalInterfaceMethodSignature lambdagetImplClass LAMBDA_i_kimplClass lambdagetImplMethodSignature LAMBDA_i_kimplMethodSignature jvmindyLAMBDA_i_k throw IllegalArgumentExceptionInvalid lambda deserialization val groupedByImplMethodName HashMapString HashMapDeserializedLambdaInfo SerializableMethodRefInfo for serializableMethodRefInfo in serializableMethodRefInfos val deserializedLambdaInfo mapDeserializedLambdaserializableMethodRefInfo val implMethodName deserializedLambdaInfoimplMethodHandlename val byDeserializedLambdaInfo groupedByImplMethodNamegetOrPutimplMethodName HashMap byDeserializedLambdaInfodeserializedLambdaInfo serializableMethodRefInfo val deserializeLambdaFun backendContextirFactorybuildFun name NameidentifierdeserializeLambda visibility DescriptorVisibilitiesPRIVATE origin JvmLoweredDeclarationOriginDESERIALIZE_LAMBDA_FUN deserializeLambdaFunparent irClass val lambdaParameter deserializeLambdaFunaddValueParameterlambda backendContextirsymbolsserializedLambdairType deserializeLambdaFunreturnType backendContextirBuiltInsanyType deserializeLambdaFunbody backendContextcreateJvmIrBuilderdeserializeLambdaFunsymbol UNDEFINED_OFFSET UNDEFINED_OFFSETrun irBlockBody val tmp irTemporary irCallbackendContextirsymbolsserializedLambdagetImplMethodNameapply dispatchReceiver irGetlambdaParameter irWhen backendContextirBuiltInsunitType groupedByImplMethodNameentriesmap implMethodName infos irBranch irEqualsirGettmp irStringimplMethodName irWhen backendContextirBuiltInsunitType infosentriesmap deserializedLambdaInfo serializedMethodRefInfo irBranch generateSerializedLambdaEqualslambdaParameter deserializedLambdaInfo irReturngenerateCreateDeserializedMethodReflambdaParameter serializedMethodRefInfo irThrow irCallbackendContextirsymbolsillegalArgumentExceptionCtorStringalso ctorCall ctorCallputValueArgument 0 Replace argument with irCallbackendContextirBuiltInsanyClassgetSimpleFunctiontoStringapply dispatchReceiver irGetlambdaParameter for debugging Invalid lambda deserialization exceptions irStringInvalid lambda deserialization irClassdeclarationsadddeserializeLambdaFun private fun mapDeserializedLambdainfo SerializableMethodRefInfo DeserializedLambdaInfo functionalInterfaceClass backendContextdefaultTypeMappermapTypeinfosamTypeinternalName implMethodHandle backendContextdefaultMethodSignatureMappermapToMethodHandleinfoimplFunSymbolowner functionalInterfaceMethod backendContextdefaultMethodSignatureMappermapAsmMethodinfosamMethodSymbolowner private fun JvmIrBuildergenerateSerializedLambdaEquals lambdaParameter IrValueParameter deserializedLambdaInfo DeserializedLambdaInfo IrExpression val functionalInterfaceClass deserializedLambdaInfofunctionalInterfaceClass val implMethodHandle deserializedLambdaInfoimplMethodHandle val samMethod deserializedLambdaInfofunctionalInterfaceMethod fun irGetLambdaPropertygetter IrSimpleFunction irCallgetterapply dispatchReceiver irGetlambdaParameter return irAndAnd irEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetImplMethodKind irIntimplMethodHandletag irObjectEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetFunctionalInterfaceClass irStringfunctionalInterfaceClass irObjectEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetFunctionalInterfaceMethodName irStringsamMethodname irObjectEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetFunctionalInterfaceMethodSignature irStringsamMethoddescriptor irObjectEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetImplClass irStringimplMethodHandleowner irObjectEquals irGetLambdaPropertybackendContextirsymbolsserializedLambdagetImplMethodSignature irStringimplMethodHandledesc private val equalsAny backendContextirBuiltInsanyClassgetSimpleFunctionequals private fun JvmIrBuilderirObjectEqualsreceiver IrExpression arg IrExpression irCallequalsAnyapply dispatchReceiver receiver putValueArgument0 arg private fun JvmIrBuilderirAndAndvararg args IrExpression IrExpression if argsisEmpty throw AssertionErrorAt least one argument expected var result args0 for i in 1 until argssize result irCallbackendContextirBuiltInsandandSymbolapply putValueArgument0 result putValueArgument1 argsi return result private fun JvmIrBuildergenerateCreateDeserializedMethodRef lambdaParameter IrValueParameter info SerializableMethodRefInfo IrExpression val dynamicCall irCallinfodynamicCallSymbol for index dynamicValueParameter in infodynamicCallSymbolownervalueParameterswithIndex val capturedArg irCallbackendContextirsymbolsserializedLambdagetCapturedArgalso call calldispatchReceiver irGetlambdaParameter callputValueArgument0 irIntindex val expectedType dynamicValueParametertype val downcastArg if expectedTypeisInlineClassType Inline class type arguments are stored as their underlying representation val unboxedType expectedTypeunboxInlineClass irCallbackendContextirsymbolsunsafeCoerceIntrinsicalso coercion coercionputTypeArgument0 unboxedType coercionputTypeArgument1 expectedType coercionputValueArgument0 capturedArg else irAscapturedArg expectedType dynamicCallputValueArgumentindex downcastArg return createLambdaMetafactoryCall infosamMethodSymbol infoimplFunSymbol infoinstanceFunSymbol true inforequiredBridges dynamicCall see FunctionReferenceLoweringwrapWithIndySamConversion ", "modifier": "private ", "signature": "fun rewriteIndyLambdaMetafactoryCall(call: IrCall): IrCall", "body": "{<EOL> fun fail(message: String): Nothing =<EOL> throw AssertionError(\"$message, call:\\n${call.dump()}"}
{"docstring": " Whether this is accessible in currentScope according to the platform rules and with respect to function inlining param context The backend context param currentScope The scope in which this is to be accessed param inlineScopeResolver The helper that allows to find the places from which private inline functions are called useful if this is accessed from a private inline function param withSuper If an access to this symbol like IrCall has a super qualifier the access rules will be stricter param thisObjReference If this is a member access the class symbol of the receiver param fromOtherClassLoader If this is a protected declaration being accessed from the same package but not from a subclass setting this parameter to true marks this declaration as inaccessible since JVM protected unlike Kotlin protected permits accesses from the same package _provided the call is not across class loader boundaries_ fun IrSymbolisAccessible context JvmBackendContext currentScope ScopeWithIr inlineScopeResolver IrInlineScopeResolver withSuper Boolean thisObjReference IrClassSymbol fromOtherClassLoader Boolean false Boolean We assume that IR code that reaches us has been checked for correctness at the frontend This function needs to single out those cases where Java accessibility rules differ from Kotlins val declarationRaw owner as IrDeclarationWithVisibility Enum entry constructors are generated as packageprivate and are accessed only from corresponding enum class if declarationRaw is IrConstructor declarationRawconstructedClassisEnumEntry return true Public declarations are already accessible However super calls are subclassonly val jvmVisibility AsmUtilgetVisibilityAccessFlagdeclarationRawvisibilitydelegate if jvmVisibility OpcodesACC_PUBLIC withSuper return true toArray is always accessible cause mapped to public functions if declarationRaw is IrSimpleFunction declarationRawisNonGenericToArray declarationRawisGenericToArraycontext declarationRawparentAsClassisCollectionSubClass return true assertionsDisabled is accessed only from the same class even in an inline function the inliner will generate it at the call site if necessary if declarationRaw is IrField declarationRawisAssertionsDisabledFieldcontext return true If this expression wont actually result in a JVM instruction call access modifiers dont matter if declarationRaw is IrFunction declarationRawisInline contextgetIntrinsicdeclarationRawsymbol null return true val declaration when declarationRaw is IrSimpleFunction declarationRawresolveFakeOverrideMaybeAbstractOrFail is IrField declarationRawresolveFieldFakeOverride else declarationRaw val ownerClass declarationparent as IrClass return true locals are always accessible val scopeClassOrPackage inlineScopeResolverfindContainercurrentScopeirElement return false val samePackage ownerClassgetPackageFragmentpackageFqName scopeClassOrPackagegetPackageFragmentpackageFqName return when jvmVisibility OpcodesACC_PRIVATE ownerClass scopeClassOrPackage withSuper samePackage jvmVisibility 0 package only true withSuper samePackage fromOtherClassLoader true Super calls and crosspackage protected accesses are both only possible from a subclass of the declaration owner Also the target of a nonstatic call must be assignable to the current class This is a verification constraint httpsdocsoraclecomjavasespecsjvmsse7htmljvms4htmljvms41018 else scopeClassOrPackage is IrClass scopeClassOrPackageisSubclassOfownerClass thisObjReference null thisObjReferenceownerisSubclassOfscopeClassOrPackage private class SyntheticAccessorTransformer val context JvmBackendContext val irFile IrFile val pendingAccessorsToAdd MutableSetIrFunction IrElementTransformerVoidWithContext private val accessorGenerator contextcachedDeclarationssyntheticAccessorGenerator private val inlineScopeResolver IrInlineScopeResolver irFilefindInlineCallSitescontext private var processingIrInlinedFun false private inline fun T withinIrInlinedFunblock T T val oldProcessingInline processingIrInlinedFun try processingIrInlinedFun true return block finally processingIrInlinedFun oldProcessingInline private fun T IrFunctionSymbol Tsave T assertownerfileOrNull irFile processingIrInlinedFun SyntheticAccessorLowering should not attempt to modify other filesn While lowering this file irFilerendern Trying to add this accessor ownerrender if ownerfileOrNull irFile pendingAccessorsToAdd thisowner return this private fun IrSymbolisAccessiblewithSuper Boolean thisObjReference IrClassSymbol Boolean withSyntheticAccessorLowering isAccessiblecontext currentScope inlineScopeResolver withSuper thisObjReference override fun visitFunctionAccessexpression IrFunctionAccessExpression IrExpression if expressionusesDefaultArguments return supervisitFunctionAccessexpression val callee expressionsymbolowner val withSuper expression as IrCallsuperQualifierSymbol null val thisSymbol expression as IrCalldispatchReceivertypeclassifierOrNull as IrClassSymbol if expression is IrCall calleesymbol contextirsymbolsindyLambdaMetafactoryIntrinsic return supervisitExpressionhandleLambdaMetafactoryIntrinsicexpression thisSymbol val accessor when callee is IrConstructor accessorGeneratorisOrShouldBeHiddenAsSealedClassConstructorcallee accessorGeneratorgetSyntheticConstructorOfSealedClasscalleesymbol callee is IrConstructor accessorGeneratorisOrShouldBeHiddenSinceHasMangledParamscallee accessorGeneratorgetSyntheticConstructorWithMangledParamscalleesymbol expressionsymbolisAccessiblewithSuper thisSymbol accessorGeneratorgetSyntheticFunctionAccessorexpression allScopessave else return supervisitFunctionAccessexpression return supervisitExpressionmodifyFunctionAccessExpressionexpression accessor private fun handleLambdaMetafactoryIntrinsiccall IrCall thisSymbol IrClassSymbol IrExpression val implFunRef callgetValueArgument1 as IrFunctionReference throw AssertionErrorimplMethodReference is expected to be IrFunctionReference calldump val implFunSymbol implFunRefsymbol if implFunSymbolisAccessibleFromSyntheticProxythisSymbol return call val accessorSymbol accessorGeneratorgetSyntheticFunctionAccessorimplFunRef allScopessave val accessorFun accessorSymbolowner val accessorRef IrFunctionReferenceImpl implFunRefstartOffset implFunRefendOffset implFunReftype accessorSymbol accessorFuntypeParameterssize accessorFunvalueParameterssize implFunRefreflectionTarget implFunReforigin accessorRefcopyTypeArgumentsFromimplFunRef val implFun implFunSymbolowner var accessorArgIndex 0 if implFundispatchReceiverParameter null accessorRefputValueArgumentaccessorArgIndex implFunRefdispatchReceiver if implFunextensionReceiverParameter null accessorRefputValueArgumentaccessorArgIndex implFunRefextensionReceiver for implArgIndex in 0 until implFunRefvalueArgumentsCount accessorRefputValueArgumentaccessorArgIndex implFunRefgetValueArgumentimplArgIndex if accessorFun is IrConstructor accessorRefputValueArgumentaccessorArgIndex createAccessorMarkerArgument callputValueArgument1 accessorRef return call private fun IrFunctionSymbolisAccessibleFromSyntheticProxythisSymbol IrClassSymbol Boolean if isAccessiblefalse thisSymbol return false if ownervisibility DescriptorVisibilitiesPROTECTED ownervisibility JavaDescriptorVisibilitiesPROTECTED_STATIC_VISIBILITY return true We have a protected member It is accessible from a synthetic proxy class created by LambdaMetafactory if it belongs to the current class return inlineScopeResolverfindContainercurrentScopeirElement ownerparentAsClass override fun visitGetFieldexpression IrGetField IrExpression val dispatchReceiverType expressionreceivertype val dispatchReceiverClassSymbol dispatchReceiverTypeclassifierOrNull as IrClassSymbol if expressionsymbolisAccessiblewithSuper false dispatchReceiverClassSymbol return supervisitExpressionexpression return supervisitExpression modifyGetterExpression expression accessorGeneratorgetSyntheticGetterexpression allScopessave override fun visitSetFieldexpression IrSetField IrExpression FE accepts code that assigns to a val of this or other class if it happens in unreachable code KT35565 Sometimes this can cause internal error in the BE see KT49316 Assume that val property with a backing field can never be initialized from a context that requires synthetic accessor val correspondingProperty expressionsymbolownercorrespondingPropertySymbolowner if correspondingProperty null correspondingPropertyisVar return supervisitExpressionexpression val dispatchReceiverType expressionreceivertype val dispatchReceiverClassSymbol dispatchReceiverTypeclassifierOrNull as IrClassSymbol if expressionsymbolisAccessiblefalse dispatchReceiverClassSymbol return supervisitExpressionexpression return supervisitExpression modifySetterExpression expression accessorGeneratorgetSyntheticSetterexpression allScopessave override fun visitConstructordeclaration IrConstructor IrStatement when accessorGeneratorisOrShouldBeHiddenSinceHasMangledParamsdeclaration accessorGeneratorgetSyntheticConstructorWithMangledParamsdeclarationsymbolsave declarationvisibility DescriptorVisibilitiesPRIVATE accessorGeneratorisOrShouldBeHiddenAsSealedClassConstructordeclaration accessorGeneratorgetSyntheticConstructorOfSealedClassdeclarationsymbolsave declarationvisibility DescriptorVisibilitiesPRIVATE return supervisitConstructordeclaration override fun visitFunctionReferenceexpression IrFunctionReference IrExpression val function expressionsymbolowner if expressionoriginisLambda function is IrConstructor val generatedAccessor when accessorGeneratorisOrShouldBeHiddenSinceHasMangledParamsfunction accessorGeneratorgetSyntheticConstructorWithMangledParamsfunction accessorGeneratorisOrShouldBeHiddenAsSealedClassConstructorfunction accessorGeneratorgetSyntheticConstructorOfSealedClassfunction else return supervisitFunctionReferenceexpression expressiontransformChildrenVoid return IrFunctionReferenceImpl expressionstartOffset expressionendOffset expressiontype generatedAccessorsymbol generatedAccessortypeParameterssize generatedAccessorvalueParameterssize generatedAccessorsymbol expressionorigin return supervisitFunctionReferenceexpression override fun visitBlockexpression IrBlock IrExpression if expression is IrInlinedFunctionBlock expressionisFunctionInlining val callee expressioninlineDeclaration val parentClass calleeparentClassOrNull return supervisitBlockexpression return withinIrInlinedFun withinScopeparentClass withinScopecallee supervisitBlockexpression return supervisitBlockexpression Produces a call to the synthetic accessor accessorSymbol to replace the call expression oldExpression Before kotlin class C protected constructorval value Int protected fun protectedFuna Int String atoString internal inline fun foox Int printlnprotectedFunx internal inline fun copy C Cvalue After kotlin class C protected constructorval value Int public constructor value Int constructor_marker kotlinjvminternalDefaultConstructorMarker thisvalue protected fun protectedFuna Int String atoString public static fun accessprotectedFunthis C a Int String thisprotectedFuna internal inline fun foox Int printlnCaccessprotectedFunthis x internal inline fun copy C Cvalue null ", "modifier": "private ", "signature": "fun modifyFunctionAccessExpression(\n        oldExpression: IrFunctionAccessExpression,\n        accessorSymbol: IrFunctionSymbol\n    ): IrFunctionAccessExpression", "body": "{<EOL> val newExpression = when (oldExpression) {<EOL> is IrCall -> IrCallImpl.fromSymbolOwner(<EOL> oldExpression.startOffset, oldExpression.endOffset,<EOL> oldExpression.type,<EOL> accessorSymbol as IrSimpleFunctionSymbol, oldExpression.typeArgumentsCount,<EOL> origin = oldExpression.origin<EOL> )<EOL> is IrDelegatingConstructorCall -> IrDelegatingConstructorCallImpl.fromSymbolOwner(<EOL> oldExpression.startOffset, oldExpression.endOffset,<EOL> context.irBuiltIns.unitType,<EOL> accessorSymbol as IrConstructorSymbol, oldExpression.typeArgumentsCount<EOL> )<EOL> is IrConstructorCall -><EOL> IrConstructorCallImpl.fromSymbolOwner(<EOL> oldExpression.startOffset, oldExpression.endOffset,<EOL> oldExpression.type,<EOL> accessorSymbol as IrConstructorSymbol<EOL> )<EOL> else -><EOL> error(\"Unexpected IrFunctionAccessExpression: $oldExpression\")<EOL> }"}
{"docstring": " Produces a call to the synthetic accessor accessorSymbol to replace the field _read_ expression oldExpression Before kotlin class C protected field val myField Int internal inline fun foo Int myField 1 After kotlin class C protected field val myField Int public static fun accessgetMyFieldpthis C Int thismyField internal inline fun foo Int CaccessgetMyFieldpthis 1 ", "modifier": "private ", "signature": "fun modifyGetterExpression(\n        oldExpression: IrGetField,\n        accessorSymbol: IrSimpleFunctionSymbol\n    ): IrCall", "body": "{<EOL> val call = IrCallImpl(<EOL> oldExpression.startOffset, oldExpression.endOffset,<EOL> oldExpression.type,<EOL> accessorSymbol, 0, accessorSymbol.owner.valueParameters.size,<EOL> oldExpression.origin<EOL> )<EOL> oldExpression.receiver?.let {<EOL> call.putValueArgument(0, oldExpression.receiver)<EOL> }"}
{"docstring": " Produces a call to the synthetic accessor accessorSymbol to replace the field _write_ expression oldExpression Before kotlin class C protected var myField Int 0 internal inline fun foox Int myField x After kotlin class C protected var myField Int 0 public static fun accesssetMyFieldpthis C set Int thismyField set internal inline fun foox Int accesssetMyFieldpthis x ", "modifier": "private ", "signature": "fun modifySetterExpression(\n        oldExpression: IrSetField,\n        accessorSymbol: IrSimpleFunctionSymbol\n    ): IrCall", "body": "{<EOL> val call = IrCallImpl(<EOL> oldExpression.startOffset, oldExpression.endOffset,<EOL> oldExpression.type,<EOL> accessorSymbol, 0, accessorSymbol.owner.valueParameters.size,<EOL> oldExpression.origin<EOL> )<EOL> oldExpression.receiver?.let {<EOL> call.putValueArgument(0, oldExpression.receiver)<EOL> }"}
{"docstring": " see javalanginvokeLambdaMetafactory ", "modifier": "", "signature": "fun getLambdaMetafactoryArguments(\n        reference: IrFunctionReference,\n        samType: IrType,\n        plainLambda: Boolean\n    ): MetafactoryArgumentsResult", "body": "{<EOL> val samClass = samType.getClass()<EOL> ?: throw AssertionError(\"SAM type is not a class: ${samType.render()}"}
{"docstring": " Replace inline classes by their underlying types fun IrTypeunboxInlineClass InlineClassAbiunboxTypethis thisobject InlineClassAbi An origin for IrFunctionReferences which prevents inline class mangling This only exists because of inconsistencies between RuntimeTypeMapper and KotlinTypeMapper The RuntimeTypeMapper does not perform inline class mangling and so in the absence of jvm signatures in the metadata we need to avoid inline class mangling as well in the function references used as arguments to the signature string intrinsic val UNMANGLED_FUNCTION_REFERENCE by IrStatementOriginImpl Unwraps inline class types to their underlying representation Returns null if the type cannot be unboxed fun unboxTypetype IrType IrType val klass typeclassOrNullowner return null val representation klassinlineClassRepresentation return null TODO Apply type substitutions var underlyingType representationunderlyingTypeunboxInlineClass if underlyingTypeisNullable underlyingTypeisTypeParameter underlyingType underlyingTypeerasedUpperBounddefaultType if typeisNullable return underlyingType if underlyingTypeisNullable underlyingTypeisPrimitiveType return null return underlyingTypemakeNullable Returns a mangled name for a function taking inline class arguments to avoid clashes between overloaded methods ", "modifier": "", "signature": "fun mangledNameFor(context: JvmBackendContext, irFunction: IrFunction, mangleReturnTypes: Boolean, useOldMangleRules: Boolean): Name", "body": "{<EOL> if (irFunction is IrConstructor) {<EOL> // Note that we might drop this convention and use standard mangling for constructors too, see KT-37186.<EOL> assert(irFunction.constructedClass.isValue) {<EOL> \"Should not mangle names of non-inline class constructors: ${irFunction.render()}"}
{"docstring": " return return true for interface method not annotated with JvmDefault or PlatformDependent ", "modifier": "", "signature": "fun isAbstractOnJvmIgnoringActualModality(descriptor: FunctionDescriptor, jvmDefaultMode: JvmDefaultMode): Boolean", "body": "{<EOL> if (!DescriptorUtils.isInterface(descriptor.containingDeclaration)) return false<EOL><EOL> return !descriptor.isJvmDefaultOrPlatformDependent(jvmDefaultMode)<EOL>}"}
{"docstring": " Given a function descriptor creates another function descriptor with type parameters copied from outer contexts This is needed because once were serializing this to a proto theres no place to store information about external type parameters ", "modifier": "", "signature": "fun createFreeFakeLambdaDescriptor(descriptor: FunctionDescriptor, typeApproximator: TypeApproximator?): FunctionDescriptor", "body": "{<EOL> return createFreeDescriptor(descriptor, typeApproximator)<EOL>}"}
{"docstring": " Given a local delegated variable descriptor creates a descriptor of a property that should be observed when using reflection on that local variable at runtime Only members used by DescriptorSerializerpropertyProto are implemented correctly in this property descriptor ", "modifier": "", "signature": "fun createFreeFakeLocalPropertyDescriptor(descriptor: LocalVariableDescriptor, typeApproximator: TypeApproximator?): PropertyDescriptor", "body": "{<EOL> val property = PropertyDescriptorImpl.create(<EOL> descriptor.containingDeclaration, descriptor.annotations, Modality.FINAL, descriptor.visibility, descriptor.isVar,<EOL> descriptor.name, CallableMemberDescriptor.Kind.DECLARATION, descriptor.source, false, descriptor.isConst,<EOL> false, false, false, descriptor.isDelegated<EOL> )<EOL> property.setType(<EOL> descriptor.type, descriptor.typeParameters,<EOL> descriptor.dispatchReceiverParameter, descriptor.extensionReceiverParameter, descriptor.contextReceiverParameters<EOL> )<EOL><EOL> property.initialize(<EOL> descriptor.getter?.run {<EOL> PropertyGetterDescriptorImpl(property, annotations, modality, visibility, true, isExternal, isInline, kind, null, source)<EOL> .apply {<EOL> initialize(this@run.returnType)<EOL> }"}
{"docstring": " Generates Java overloads for functions and constructors that have the default parameter values substituted class DefaultParameterValueSubstitutorval state GenerationState companion object rename JvmOverloads val ANNOTATION_TYPE_DESCRIPTOR_FOR_JVM_OVERLOADS_GENERATED_METHODS String TypegetObjectTypesynthetickotlinjvmGeneratedByJvmOverloadsdescriptor If all of the parameters of the specified constructor declare default values generates a noargument constructor that passes default values for all arguments fun generatePrimaryConstructorOverloadsIfNeeded constructorDescriptor ConstructorDescriptor classBuilder ClassBuilder memberCodegen MemberCodegen contextKind OwnerKind classOrObject KtPureClassOrObject val element classOrObjectprimaryConstructor classOrObject if generateOverloadsIfNeededelement constructorDescriptor constructorDescriptor contextKind classBuilder memberCodegen isEmptyConstructorNeededconstructorDescriptor classOrObject generateOverloadWithSubstitutedParameters constructorDescriptor constructorDescriptor classBuilder memberCodegen element contextKind constructorDescriptorcountDefaultParameters If the function is annotated with kotlinjvmJvmOverloads generates Java methods that have the default parameter values substituted If a method has N parameters and M of which have default values M overloads are generated the first one takes N1 parameters all but the last one that takes a default value the second takes N2 parameters and so on param functionDescriptor the method for which the overloads are generated param delegateFunctionDescriptor the method descriptor for the implementation that we need to call same as functionDescriptor in all cases except for companion object methods annotated with JvmStatic where functionDescriptor is the static method in the main class and delegateFunctionDescriptor is the implementation in the companion object class return true if the overloads annotation was found on the element false otherwise ", "modifier": "", "signature": "fun generateOverloadsIfNeeded(\n        methodElement: KtPureElement?,\n        functionDescriptor: FunctionDescriptor,\n        delegateFunctionDescriptor: FunctionDescriptor,\n        contextKind: OwnerKind,\n        classBuilder: ClassBuilder,\n        memberCodegen: MemberCodegen<*>\n    ): Boolean", "body": "{<EOL> if (functionDescriptor.findJvmOverloadsAnnotation() == null) return false<EOL><EOL> for (i in 1..functionDescriptor.countDefaultParameters()) {<EOL> generateOverloadWithSubstitutedParameters(<EOL> functionDescriptor, delegateFunctionDescriptor, classBuilder, memberCodegen, methodElement, contextKind, i<EOL> )<EOL> }"}
{"docstring": " return true iff a given function descriptor should be compiled to a method with boxed return type regardless of whether return type of that descriptor is nullable or not This happens in two cases when a target function is a synthetic box method of erased inline class when a function returning a value of a primitive type overrides another function with a nonprimitive return type In that case the generated methods return type should be boxed otherwise its not possible to use this class from Java since javac issues errors when loading the class incompatible return types ", "modifier": "private ", "signature": "fun forceBoxedReturnType(descriptor: FunctionDescriptor): Boolean", "body": "{<EOL> if (isBoxMethodForInlineClass(descriptor)) return true<EOL><EOL> val returnType = descriptor.returnType!!<EOL><EOL> // 'invoke' methods for lambdas, function literals, and callable references<EOL> // implicitly override generic 'invoke' from a corresponding base class.<EOL> if ((isFunctionExpression(descriptor) || isFunctionLiteral(descriptor)) && returnType.isInlineClassType()) return true<EOL><EOL> return isJvmPrimitive(returnType) &&<EOL> getAllOverriddenDescriptors(descriptor).any { !isJvmPrimitive(it.returnType!!) }"}
{"docstring": " return set of type parameters identifiers contained in markers that should be reified further eg when were generating inline function containing reified T and another function containing reifiable parts is inlined into that function ", "modifier": "", "signature": "fun reifyInstructions(node: MethodNode): ReifiedTypeParametersUsages", "body": "{<EOL> if (!hasReifiedParameters) return ReifiedTypeParametersUsages()<EOL><EOL> val instructions = node.instructions<EOL> maxStackSize = 0<EOL> val result = ReifiedTypeParametersUsages()<EOL> for (insn in instructions.toArray()) {<EOL> if (isOperationReifiedMarker(insn)) {<EOL> val newNames = processReifyMarker(insn as MethodInsnNode, instructions)<EOL> if (newNames != null) {<EOL> result.mergeAll(newNames)<EOL> }"}
{"docstring": " insn INVOKESTATIC reifiedOperationMarker insnnext operation to be reified insnnextnext ldcpluginMarker insnnextnextnext INVOKESTATIC voidMagicApiCall ", "modifier": "private ", "signature": "fun isPluginNext(insn: AbstractInsnNode): Boolean", "body": "{<EOL> val magicInsn = insn.next?.next?.next ?: return false<EOL> return magicInsn is MethodInsnNode && magicInsn.opcode == Opcodes.INVOKESTATIC<EOL> && magicInsn.owner == pluginIntrinsicsMarkerOwner<EOL> && magicInsn.name == pluginIntrinsicsMarkerMethod<EOL> && magicInsn.desc == pluginIntrinsicsMarkerSignature<EOL> && magicInsn.previous is LdcInsnNode<EOL> }"}
{"docstring": " call1 is not less specific than call2 ", "modifier": "private ", "signature": "fun isNotLessSpecificCallWithArgumentMapping(\n        call1: FlatSignature<C>,\n        call2: FlatSignature<C>,\n        discriminateGenerics: Boolean,\n        useOriginalSamTypes: Boolean\n    ): Boolean", "body": "{<EOL> return tryCompareDescriptorsFromScripts(call1.candidateDescriptor(), call2.candidateDescriptor()) ?: compareCallsByUsedArguments(<EOL> call1,<EOL> call2,<EOL> discriminateGenerics,<EOL> useOriginalSamTypes<EOL> )<EOL> }"}
{"docstring": " Returns true if call1 is definitely more or equally specific call2 false otherwise ", "modifier": "private ", "signature": "fun compareCallsByUsedArguments(\n        call1: FlatSignature<C>,\n        call2: FlatSignature<C>,\n        discriminateGenerics: Boolean,\n        useOriginalSamTypes: Boolean\n    ): Boolean", "body": "{<EOL> if (discriminateGenerics) {<EOL> val isGeneric1 = call1.isGeneric<EOL> val isGeneric2 = call2.isGeneric<EOL> // generic loses to non-generic<EOL> if (isGeneric1 && !isGeneric2) return false<EOL> if (!isGeneric1 && isGeneric2) return true<EOL> // two generics are non-comparable<EOL> if (isGeneric1 && isGeneric2) return false<EOL> }"}
{"docstring": " Returns true if d1 is definitely not less specific than d2 false if d1 is definitely less specific than d2 null if undecided private fun tryCompareDescriptorsFromScriptsd1 CallableDescriptor d2 CallableDescriptor Boolean val containingDeclaration1 d1containingDeclaration val containingDeclaration2 d2containingDeclaration if containingDeclaration1 is ScriptDescriptor containingDeclaration2 is ScriptDescriptor when containingDeclaration1priority containingDeclaration2priority return true containingDeclaration1priority containingDeclaration2priority return false return null Returns true if f is definitely not less specific than g false if f is definitely less specific than g null if undecided ", "modifier": "private ", "signature": "fun isNotLessSpecificCallableReferenceDescriptor(f: CallableDescriptor, g: CallableDescriptor): Boolean", "body": "{<EOL> if (f.valueParameters.size != g.valueParameters.size) return false<EOL> if (f.varargParameterPosition() != g.varargParameterPosition()) return false<EOL><EOL> val fSignature = FlatSignature.createFromCallableDescriptor(f)<EOL> val gSignature = FlatSignature.createFromCallableDescriptor(g)<EOL> if (!createEmptyConstraintSystem().isSignatureNotLessSpecific(<EOL> fSignature,<EOL> gSignature,<EOL> SpecificityComparisonWithNumerics,<EOL> specificityComparator<EOL> )<EOL> ) {<EOL> return false<EOL> }"}
{"docstring": " interface InvT fun Y barl InvY Y fun X Invout Int foox X val xr barx Here we try to capture from upper bound from type parameter We replace type of x to Invout Intwe chose supertype which contains supertype with expectedTypeConstructor and capture from this type It is correct because it is like this code fun X Invout Int foox X val inv Invout Int x val xr barinv ", "modifier": "", "signature": "fun captureFromTypeParameterUpperBoundIfNeeded(argumentType: UnwrappedType, expectedType: UnwrappedType): UnwrappedType", "body": "{<EOL> val expectedTypeConstructor = expectedType.upperIfFlexible().constructor<EOL><EOL> if (argumentType.lowerIfFlexible().constructor.declarationDescriptor is TypeParameterDescriptor) {<EOL> val chosenSupertype = argumentType.lowerIfFlexible().supertypes().singleOrNull {<EOL> it.constructor.declarationDescriptor is ClassifierDescriptorWithTypeParameters &&<EOL> it.unwrap().hasSupertypeWithGivenTypeConstructor(expectedTypeConstructor)<EOL> }"}
{"docstring": " Check if this text is block but not a lambda please refer to parsing rules see orgjetbrainskotlinparsingKotlinExpressionParsingparseFunctionLiteral ", "modifier": "", "signature": "fun isReparseableBlock(blockText: CharSequence): Boolean", "body": "{<EOL><EOL> fun advanceWhitespacesCheckIsEndOrArrow(lexer: KotlinLexer): Boolean {<EOL> lexer.advance()<EOL> while (lexer.tokenType != null && lexer.tokenType != KtTokens.EOF) {<EOL> if (lexer.tokenType == KtTokens.ARROW) return true<EOL> if (lexer.tokenType != KtTokens.WHITE_SPACE) return false<EOL> lexer.advance()<EOL> }"}
{"docstring": " Parses raw rawImports and appends them to the list of code fragment imports Import strings must be separated by the IMPORT_SEPARATOR Each import must be either a qualified name to import eg foobar or a complete text representation of an import directive eg import foobar as baz Note that already present import directives will be ignored return true if new import directives were added ", "modifier": "private ", "signature": "fun appendImports(rawImports: String): Boolean", "body": "{<EOL> if (rawImports.isEmpty()) {<EOL> return false<EOL> }"}
{"docstring": " Type reference element Underlying token is orgjetbrainskotlinKtNodeTypesTYPE_REFERENCE class KtTypeReference KtModifierListOwnerStubKotlinPlaceHolderStubKtTypeReference KtAnnotated KtAnnotationsContainer constructornode ASTNode supernode constructorstub KotlinPlaceHolderStubKtTypeReference superstub KtStubElementTypesTYPE_REFERENCE override fun R D acceptvisitor KtVisitorR D data D R return visitorvisitTypeReferencethis data val isPlaceholder Boolean get typeElement as KtUserTypereferenceExpression as KtNameReferenceExpressionisPlaceholder true val typeElement KtTypeElement get KtStubbedPsiUtilgetStubOrPsiChildthis KtTokenSetsTYPE_ELEMENT_TYPES KtTypeElementARRAY_FACTORY override fun getAnnotations ListKtAnnotation return modifierListannotationsorEmpty override fun getAnnotationEntries ListKtAnnotationEntry return modifierListannotationEntriesorEmpty fun hasParentheses Boolean return findChildByTypePsiElementKtTokensLPAR null findChildByTypePsiElementKtTokensRPAR null fun nameForReceiverLabel typeElement as KtUserTypereferencedName Returns presentable text for the underlying type based on stubs when provided No decompilation happens if KtTypeReference represents compiled code ", "modifier": "", "signature": "fun getTypeText(): String", "body": "{<EOL> return stub?.let { getTypeText(typeElement) }"}
{"docstring": " A single part of a qualified name in the tag subject or link class KDocNamenode ASTNode KtElementImplnode fun getContainingDoc KDoc val kdoc getStrictParentOfTypeKDoc return kdoc throw IllegalStateExceptionKDocName must be inside a KDoc fun getContainingSection KDocSection val kdoc getStrictParentOfTypeKDocSection return kdoc throw IllegalStateExceptionKDocName must be inside a KDocSection fun getQualifier KDocName getChildOfType Returns the range within the element containing the name in other words the range of the element excluding the qualifier and dot if present ", "modifier": "", "signature": "fun getNameTextRange(): TextRange", "body": "{<EOL> val dot = node.findChildByType(KtTokens.DOT)<EOL> val textRange = textRange<EOL> val nameStart = if (dot != null) dot.textRange.endOffset - textRange.startOffset else 0<EOL> return TextRange(nameStart, textRange.length)<EOL> }"}
{"docstring": " Output directories of the compilation These include 1 The classes output directory 2 workingDir 3 Any additional output directories eg classpath snapshot directory or Kapt generatedstubs directory We will clean these directories when compiling nonincrementally If this property is not set the directories to clean will include the first 2 directories above private val outputDirs CollectionFile Various options Boolean flags both stable and experimental should be added there Nontrivial configuration should NOT be added there protected val icFeatures IncrementalCompilationFeatures protected val cacheDirectory FileworkingDir cacheDirName private val dirtySourcesSinceLastTimeFile FileworkingDir DIRTY_SOURCES_FILE_NAME protected val lastBuildInfoFile FileworkingDir LAST_BUILD_INFO_FILE_NAME private val abiSnapshotFile FileworkingDir ABI_SNAPSHOT_FILE_NAME protected open val kotlinSourceFilesExtensions SetString DEFAULT_KOTLIN_SOURCE_FILES_EXTENSIONS Creates an instance of IncrementalCompilationContext that holds common incremental compilation context mostly required for CacheManager private fun createIncrementalCompilationContext fileLocations FileLocations transaction CompilationTransaction fragmentContext FragmentContext null IncrementalCompilationContext pathConverterForSourceFiles fileLocationsgetRelocatablePathConverterForSourceFiles BasicFileToPathConverter pathConverterForOutputFiles fileLocationsgetRelocatablePathConverterForOutputFiles BasicFileToPathConverter transaction transaction reporter reporter trackChangesInLookupCache shouldTrackChangesInLookupCache storeFullFqNamesInLookupCache shouldStoreFullFqNamesInLookupCache icFeatures icFeatures fragmentContext fragmentContext protected abstract val shouldTrackChangesInLookupCache Boolean protected abstract val shouldStoreFullFqNamesInLookupCache Boolean protected abstract fun createCacheManagericContext IncrementalCompilationContext args Args CacheManager protected abstract fun destinationDirargs Args File fun compile allSourceFiles ListFile args Args messageCollector MessageCollector changedFiles ChangedFiles When notnull changes are provided by the build system otherwise the IC will need to track them fileLocations FileLocations null Must be notnull if the build system needs to support build cache relocatability ExitCode reportermeasureGradleBuildTimeINCREMENTAL_COMPILATION_DAEMON val result when val result tryCompileIncrementallyallSourceFiles changedFiles args fileLocations messageCollector is ICResultCompleted reporterdebug Incremental compilation completed resultexitCode is ICResultRequiresRebuild reporterinfo Nonincremental compilation will be performed resultreason reporteraddAttributeresultreason compileNonIncrementally resultreason allSourceFiles args fileLocations trackChangedFiles changedFiles null messageCollector is ICResultFailed messageCollectorreportExceptionresultcause ExceptionLocationINCREMENTAL_COMPILATION reporterwarn The indentation after the first line is intentional so that this message is distinct from next message Incremental compilation was attempted but failed resultreasonreadableString resultcausestackTraceToStringremoveSuffixIfPresentn Falling back to nonincremental compilation reason resultreason To help us fix this issue please file a bug at httpsyoutrackjetbrainscomissuesKT with the above stack trace Be sure to search for the above exception in existing issues first to avoid filing duplicated bugs trimMargin TODO Collect the stack trace too reporteraddAttributeresultreason compileNonIncrementally resultreason allSourceFiles args fileLocations trackChangedFiles changedFiles null messageCollector collectSizeMetrics return result The result when attempting to compile incrementally tryCompileIncrementally private sealed interface ICResult Incremental compilation completed with an ExitCode class Completedval exitCode ExitCode ICResult Incremental compilation was not possible for some valid reason eg for a clean build class RequiresRebuildval reason BuildAttribute ICResult Incremental compilation failed with an exception class Failedval reason BuildAttribute val cause Throwable ICResult Be aware that tryCompileIncrementally catches a lot of exceptions internally So this transformer should be used for very specific things like cache closing that are related to the transaction as a whole rather than any compilation step private fun incrementalCompilationExceptionTransformert Throwable ICResult when t is CachesManagerCloseException ICResultFailedIC_FAILED_TO_CLOSE_CACHES t else throw t Attempts to compile incrementally and returns either ICResultCompleted ICResultRequiresRebuild or ICResultFailed Note that parts of this function may still throw exceptions that are not caught and wrapped by ICResultFailed because they are not meant to be caught ", "modifier": "private ", "signature": "fun tryCompileIncrementally(\n        allSourceFiles: List<File>,\n        changedFiles: ChangedFiles?,\n        args: Args,\n        fileLocations: FileLocations?,\n        messageCollector: MessageCollector,\n    ): ICResult", "body": "{<EOL> if (changedFiles is ChangedFiles.Unknown) {<EOL> return ICResult.RequiresRebuild(UNKNOWN_CHANGES_IN_GRADLE_INPUTS)<EOL> }"}
{"docstring": " Computes changes between the current and previous lists of classes plus unchanged elements that are impacted by the changes NOTE Each list of classes must not contain duplicates ", "modifier": "", "signature": "fun computeChangedAndImpactedSet(\n        currentClassSnapshots: List<AccessibleClassSnapshot>,\n        previousClassSnapshots: List<AccessibleClassSnapshot>,\n        reporter: ClasspathSnapshotBuildReporter\n    ): ProgramSymbolSet", "body": "{<EOL> val currentClasses: Map<ClassId, AccessibleClassSnapshot> = currentClassSnapshots.associateBy { it.classId }"}
{"docstring": " Computes changes between the current and previous lists of classes The returned result does not need to include elements that are impacted by the changes NOTE Each list of classes must not contain duplicates ", "modifier": "private ", "signature": "fun computeClassChanges(\n        currentClassSnapshots: List<AccessibleClassSnapshot>,\n        previousClassSnapshots: List<AccessibleClassSnapshot>,\n        metrics: BuildMetricsReporter<GradleBuildTime, GradleBuildPerformanceMetric>\n    ): ProgramSymbolSet", "body": "{<EOL> val (currentKotlinClassSnapshots, currentJavaClassSnapshots) = currentClassSnapshots.partition { it is KotlinClassSnapshot }"}
{"docstring": " Converts this DirtyData to ProgramSymbols Specifically DirtyData consists of dirtyLookupSymbols CollectionLookupSymbol dirtyClassesFqNames CollectionFqName dirtyClassesFqNamesForceRecompile CollectionFqName First we will convert dirtyLookupSymbols to ProgramSymbols as dirtyLookupSymbols should contain all the changes Then we will check that 1 There are no items in dirtyLookupSymbols that have not yet been converted to ProgramSymbols 2 dirtyClassesFqNames and dirtyClassesFqNamesForceRecompile must not contain new information that cant be derived from dirtyLookupSymbols private fun DirtyDatatoProgramSymbolsallClasses IterableAccessibleClassSnapshot ProgramSymbolSet val changedProgramSymbols dirtyLookupSymbolstoProgramSymbolSetallClasses Check whether there is any info in this DirtyData that has not yet been converted to changedProgramSymbols val changedLookupSymbols changedFqNames changedProgramSymbolstoChangesEitherlet itlookupSymbolstoSet to itfqNamestoSet val unmatchedLookupSymbols thisdirtyLookupSymbolstoMutableSetalso itremoveAllchangedLookupSymbols val unmatchedFqNames thisdirtyClassesFqNamestoMutableSetalso itaddAllthisdirtyClassesFqNamesForceRecompile itremoveAllchangedFqNames if unmatchedLookupSymbolsisEmpty unmatchedFqNamesisEmpty return changedProgramSymbols When unmatchedLookupSymbols or unmatchedFqNames is not empty there are two cases 1 The unmatched LookupSymbolsFqNames are redundant This is not ideal but because it does not cause incremental compilation to be incorrect we can fix these issues later if they are not easy to fix immediately 2 The unmatched LookupSymbolsFqNames are valid changes Since they are required for incremental compilation to be correct we must fix these issues immediately In the following well list the known issues for case 1 and it must be case 1 only TODO Well fix these issues later Known issue 1 DirtyData reported by IncrementalJvmCache may include both a class and class member eg LookupSymbolcomexample A and LookupSymbolcomexampleA someProperty When the class LookupSymbol is present the class member LookupSymbol is redundant When converting DirtyData to ProgramSymbols we remove redundant class member ProgramSymbols so here we will find that LookupSymbolcomexampleA someProperty is not yet matched Ignore these LookupSymbols for now val changedClassesFqNames changedProgramSymbolsclassesmapTomutableSetOf itasSingleFqName unmatchedLookupSymbolsremoveAll FqNameitscope in changedClassesFqNames Known issue 2 If class A has a companion object containing a constant CONSTANT and if the value of CONSTANT has changed then only Aclass will change not ACompanionclass see ConstantsInCompanionObjectImpact Since we distinguish between changed symbols and impacted symbols we should detect that ACONSTANT has changed ACompanionCONSTANT is unchanged but impacted this detection happens after the step here However currently IncrementalJvmCache will report that both ACONSTANT and ACompanionCONSTANT have changed see IncrementalJvmCacheConstantsMapprocess as it needs to work with both the old IC and the new IC in the old IC changed symbols and impacted symbols are not clearly separated With the new IC when converting DirtyData to ProgramSymbols this method because we consider only changed classes and ACompanionclass is unchanged we will not convert ACompanionCONSTANT Therefore ACompanionCONSTANT is unmatched and well need to ignore it here Note Once we are able to remove this workaround we can remove RegularKotlinClassSnapshotcompanionObjectName as this is the only usage of that property val companionObjectFqNames allClassesmapNotNullTomutableSetOf clazz clazz as RegularKotlinClassSnapshotcompanionObjectNamelet it clazzclassIdcreateNestedClassIdNameidentifieritasSingleFqName unmatchedLookupSymbolsremoveAll FqNameitscope in companionObjectFqNames unmatchedFqNamesremoveAllcompanionObjectFqNames Known issue 3 LookupSymbolnameSAMCONSTRUCTOR scopecomexample reported by IncrementalJvmCache is invalid SAMCONSTRUCTOR should have a class scope not a package scope This issue was detected by KotlinOnlyClasspathChangesComputerTesttestTopLevelMembers val classesFqNames allClassesfilter it is RegularKotlinClassSnapshot it is JavaClassSnapshot mapTomutableSetOf itclassIdasSingleFqName unmatchedLookupSymbolsremoveAll itname SAM_LOOKUP_NAMEasString FqNameitscope in classesFqNames Known issue 4 LookupSymbolnameFooKt scopecomexample reported by IncrementalJvmCache is invalid LookupSymbol should not refer to a package facade it should only refer to either a class a class member or a package member see KT55021 This issue was detected by KotlinOnlyClasspathChangesComputerTesttestRenameFileFacade and IncrementalCompilationClasspathSnapshotJvmMultiProjectITtestMoveFunctionFromLibToApp val packageFacadeFqNames allClassesfilter it is KotlinClassSnapshot it is RegularKotlinClassSnapshot mapTomutableSetOf itclassIdasSingleFqName unmatchedLookupSymbolsremoveAll FqNameitscopechildNameidentifieritname in packageFacadeFqNames unmatchedFqNamesremoveAllpackageFacadeFqNames End of known issues throw an Exception checkunmatchedLookupSymbolsisEmpty The following LookupSymbols are not yet converted to ProgramSymbols unmatchedLookupSymbolsjoinToString checkunmatchedFqNamesisEmpty The following FqNames cant be derived from DirtyDatadirtyLookupSymbols unmatchedFqNamesjoinToString n DirtyData this return changedProgramSymbols private object ImpactedSymbolsComputer Computes the set of ProgramSymbols that are transitively impacted by the given set of ProgramSymbols For example if a superclass has changedbeen impacted its subclasses will be impacted The returned set is inclusive it contains the given set the directlytransitively impacted ones ", "modifier": "", "signature": "fun computeImpactedSymbols(changes: ProgramSymbolSet, allClasses: Iterable<AccessibleClassSnapshot>): ProgramSymbolSet", "body": "{<EOL> val impactedSymbolsResolver = AllImpacts.getResolver(allClasses)<EOL> return ProgramSymbolSet.Collector().apply {<EOL> // Add impacted classes<EOL> val impactedClasses = findReachableNodes(changes.classes, impactedSymbolsResolver::getImpactedClasses)<EOL> addClasses(impactedClasses)<EOL><EOL> // Add impacted class members<EOL> val classMembers = changes.classMembers.map { ClassMembers(it.key, it.value) }"}
{"docstring": " Computes a ClasspathEntrySnapshot of a classpath entry directory or jar object ClasspathEntrySnapshotter private val DEFAULT_CLASS_FILTER unixStyleRelativePath String isDirectory Boolean isDirectory unixStyleRelativePathendsWithclass ignoreCase true unixStyleRelativePathequalsmoduleinfoclass ignoreCase true unixStyleRelativePathstartsWithmetainf ignoreCase true fun snapshot classpathEntry File granularity ClassSnapshotGranularity metrics BuildMetricsReporterGradleBuildTime GradleBuildPerformanceMetric DoNothingBuildMetricsReporter ClasspathEntrySnapshot DirectoryOrJarReadercreateclasspathEntryuse directoryOrJarReader val classes metricsmeasureGradleBuildTimeLOAD_CLASSES_PATHS_ONLY directoryOrJarReadergetUnixStyleRelativePathsDEFAULT_CLASS_FILTERmap unixStyleRelativePath ClassFileWithContentsProvider classFile ClassFileclasspathEntry unixStyleRelativePath contentsProvider directoryOrJarReaderreadBytesunixStyleRelativePath val snapshots metricsmeasureGradleBuildTimeSNAPSHOT_CLASSES ClassSnapshottersnapshotclasses granularity metrics return ClasspathEntrySnapshot classSnapshots classesmap itclassFileunixStyleRelativePath zipsnapshotstoMapLinkedHashMap Computes ClassSnapshots of classes object ClassSnapshotter fun snapshot classes ListClassFileWithContentsProvider granularity ClassSnapshotGranularity metrics BuildMetricsReporterGradleBuildTime GradleBuildPerformanceMetric DoNothingBuildMetricsReporter ListClassSnapshot fun ClassFilegetClassName JvmClassName checkunixStyleRelativePathendsWithclass ignoreCase true return JvmClassNamebyInternalNameunixStyleRelativePathdropLastclasslength val classNameToClassFileMap MapJvmClassName ClassFileWithContentsProvider classesassociateBy itclassFilegetClassName val classFileToSnapshotMap mutableMapOfClassFileWithContentsProvider ClassSnapshot fun snapshotClassclassFile ClassFileWithContentsProvider ClassSnapshot return classFileToSnapshotMapgetOrPutclassFile val clazz metricsmeasureGradleBuildTimeLOAD_CONTENTS_OF_CLASSES classFileloadContents Snapshot outer class first as we need this info to determine whether a class is transitively inaccessible see below val outerClassSnapshot clazzclassInfoclassIdouterClassIdlet outerClassId val outerClassFile classNameToClassFileMapJvmClassNamebyClassIdouterClassId Its possible that the outer class is not found in the given classes it could happen with faulty jars outerClassFilelet snapshotClassit when We dont need to snapshot directly or transitively inaccessible classes A class is transitively inaccessible if its outer class is inaccessible clazzclassInfoisInaccessible outerClassSnapshot is InaccessibleClassSnapshot InaccessibleClassSnapshot clazzclassInfoisKotlinClass metricsmeasureGradleBuildTimeSNAPSHOT_KOTLIN_CLASSES snapshotKotlinClassclazz granularity else metricsmeasureGradleBuildTimeSNAPSHOT_JAVA_CLASSES snapshotJavaClassclazz granularity return classesmap snapshotClassit Returns true if this class is inaccessible and false otherwise or if we dont know A class is inaccessible if it cant be referenced from other source files and therefore any changes in an inaccessible class will not require recompilation of other source files private fun BasicClassInfoisInaccessible Boolean return when isKotlinClass when kotlinClassHeaderkind CLASS isPrivate isLocal isAnonymous isSynthetic SYNTHETIC_CLASS true else false We dont know about the other class kinds else isPrivate isLocal isAnonymous isSynthetic Computes a KotlinClassSnapshot of the given Kotlin class ", "modifier": "private ", "signature": "fun snapshotKotlinClass(classFile: ClassFileWithContents, granularity: ClassSnapshotGranularity): KotlinClassSnapshot", "body": "{<EOL> val kotlinClassInfo =<EOL> KotlinClassInfo.createFrom(classFile.classInfo.classId, classFile.classInfo.kotlinClassHeader!!, classFile.contents)<EOL> val classId = kotlinClassInfo.classId<EOL> val classAbiHash = KotlinClassInfoExternalizer.toByteArray(kotlinClassInfo).hashToLong()<EOL> val classMemberLevelSnapshot = kotlinClassInfo.takeIf { granularity == CLASS_MEMBER_LEVEL }"}
{"docstring": " Computes a JavaClassSnapshot of the given Java class ", "modifier": "private ", "signature": "fun snapshotJavaClass(classFile: ClassFileWithContents, granularity: ClassSnapshotGranularity): JavaClassSnapshot", "body": "{<EOL> // For incremental compilation, we only care about the ABI info of a class. There are 2 approaches:<EOL> // 1. Collect ABI info directly<EOL> // 2. Remove non-ABI info from the full class<EOL> // Note that for incremental compilation to be correct, all ABI info must be collected exhaustively (now and in the future when<EOL> // there are updates to Java/ASM), whereas it is acceptable if non-ABI info is not removed completely.<EOL> // Therefore, we will use the second approach as it is safer and easier.<EOL><EOL> // 1. Create a ClassNode that will contain ABI info of the class<EOL> val classNode = ClassNode()<EOL><EOL> // 2. Load the class's contents into the ClassNode, removing non-ABI info:<EOL> // - Remove private fields and methods<EOL> // - Remove method bodies<EOL> // - [Not yet implemented] Ignore fields' values except for constants<EOL> // Note the `parsingOptions` passed to `classReader`:<EOL> // - Pass SKIP_CODE as we want to remove method bodies<EOL> // - Do not pass SKIP_DEBUG as debug info (e.g., method parameter names) may be important<EOL> val classReader = ClassReader(classFile.contents)<EOL> val selectiveClassVisitor = SelectiveClassVisitor(<EOL> classNode,<EOL> shouldVisitField = { _: JvmMemberSignature.Field, isPrivate: Boolean, _: Boolean -> !isPrivate }"}
{"docstring": " Computes changes between two lists of JavaClassSnapshots object JavaClassChangesComputer Computes changes between two lists of JavaClassSnapshots NOTE Each list of classes must not contain duplicates having the same JvmClassNameClassId ", "modifier": "", "signature": "fun compute(\n        currentJavaClassSnapshots: List<JavaClassSnapshot>,\n        previousJavaClassSnapshots: List<JavaClassSnapshot>\n    ): ProgramSymbolSet", "body": "{<EOL> val currentClasses: Map<ClassId, JavaClassSnapshot> = currentJavaClassSnapshots.associateBy { it.classId }"}
{"docstring": " see orgjetbrainskotlinresolvecallsinferencemodelConstraintStoragetypeVariableDependencies override val typeVariableDependencies MutableMapTypeConstructorMarker MutableSetTypeConstructorMarker get checkStateStateBUILDING StateCOMPLETION StateTRANSACTION return storagetypeVariableDependencies override val fixedTypeVariables MutableMapTypeConstructorMarker KotlinTypeMarker get checkStateStateBUILDING StateCOMPLETION StateTRANSACTION return storagefixedTypeVariables override val postponedTypeVariables ListTypeVariableMarker get checkStateStateBUILDING StateCOMPLETION StateTRANSACTION return storagepostponedTypeVariables override val outerSystemVariablesPrefixSize Int get storageouterSystemVariablesPrefixSize override val constraintsFromAllForkPoints MutableListPairIncorporationConstraintPosition ForkPointData get checkStateStateBUILDING StateCOMPLETION StateTRANSACTION return storageconstraintsFromAllForkPoints This function tries to find the solution set of constraints that is consistent with some branch of each fork And those constraints are being immediately applied to the system override fun resolveForkPointsConstraints if constraintsFromAllForkPointsisEmpty return val allForkPointsData constraintsFromAllForkPointstoList constraintsFromAllForkPointsclear There may be multiple fork points One from subtyping AInt AT AXv Another one from BString BF BYv Each of them defines two sets of constraints eg for the first for point 1 XvInt is a oneelement set but potentially there might be more constraints in the set 2 XvT second constraints set for position forkPointData in allForkPointsData if applyConstraintsFromFirstSuccessfulBranchOfTheForkforkPointData position addErrorNoSuccessfulForkposition Checks if current state of forked constraints is not contradictory That function is expected to be pure ie it should leave the system in the same state it was found before the call return null if for each fork we found a possible branch that doesnt contradict with all other constraints return nonnullable error if theres a contradiction we didnt manage to resolve fun checkIfForksMightBeSuccessfullyResolved ConstraintSystemError if constraintsFromAllForkPointsisEmpty return null val allForkPointsData constraintsFromAllForkPointstoList constraintsFromAllForkPointsclear var result ConstraintSystemError null runTransaction for position forkPointData in allForkPointsData if applyConstraintsFromFirstSuccessfulBranchOfTheForkforkPointData position result NoSuccessfulForkposition break false constraintsFromAllForkPointsaddAllallForkPointsData return result return true if there is a successful constraints set for the fork ", "modifier": "private ", "signature": "fun applyConstraintsFromFirstSuccessfulBranchOfTheFork(\n        forkPointData: ForkPointData,\n        position: IncorporationConstraintPosition,\n    ): Boolean", "body": "{<EOL> return forkPointData.any { constraintSetForForkBranch -><EOL> runTransaction {<EOL> constraintInjector.processGivenForkPointBranchConstraints(<EOL> this@NewConstraintSystemImpl.apply { checkState(State.BUILDING, State.COMPLETION, State.TRANSACTION) }"}
{"docstring": " Holds current mapping from source files to fragments in the K2 KMP context Note for KT62686 we dont really care about removed files if a source isnt recompiled it cant get illegal lookups So theres no need to store previous sourcetofragment mapping class FragmentContext Map from path to source to this sources fragment private val fileToFragment MapString String If a fragment isnt refined by any other fragments its allowed to have incremental compilation Otherwise issues from KT62686 are applicable private val leafFragments SetString Returns true if any file from dirtySet is a part of refined fragment for example common apple linux It is relevant to KT62686 because in k2 refined fragments arent supposed to see symbols from refining fragments but they do Use of absolutePath is coordinated with K2MultiplatformStructurefragmentSourcesCompilerArgs ", "modifier": "", "signature": "fun dirtySetTouchesNonLeafFragments(dirtySet: Iterable<File>): Boolean", "body": "{<EOL> return dirtySet.any { file -><EOL> !leafFragments.contains(fileToFragment[file.absolutePath])<EOL> }"}
