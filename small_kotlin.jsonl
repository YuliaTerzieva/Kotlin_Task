{"Docstring": "/**\n * A palindrome is a word, number, phrase, or other sequence\n * of characters which reads the same backward as forward,\n * such as madam, racecar. There are also numeric palindromes,\n * particularly date/time stamps using short digits 11/11/11 11:11\n * and long digits 02/02/2020\n *\n * This function\n * @param text The text to be checked if it is a palindrome\n * @return return true if the text is a Palindrome\n */", "Modifier": "", "Signature": "fun isPalindrome(text: String): Boolean", "Body": "{\n\n    val normalizedText = text.normalize()\n    for(i in normalizedText.indices)\n        if(normalizedText[i] != normalizedText[normalizedText.length - (i + 1)])\n            return false\n    return true;\n}"}
{"Docstring": "/**\n * Palindrome Partitioning Algorithm\n *\n * You are given a string as input, and task is to find the minimum number of partitions to be made,\n * in the string sot that the resulting strings are all palindrome\n * eg. s = \"nitik\"\n * string s can be partitioned as n | iti | k into 3 palindromes, thus the number of partions are 2\n * Time Complexity = O(n^2)\n *\n * */\n\n\n/**\n * @param String is the string to be checked\n * @param Int is the starting index of the string in consideration\n * @param Int is the ending index of the string in consideration\n * @return whether string is a palindrome or not\n **/", "Modifier": "", "Signature": "fun isPalindrome(string: String, i: Int, j: Int): Boolean", "Body": "{\n    for (l in 0..(j - i) / 2) {\n        if (string[l + i] != string[j - l]) {\n            return false\n        }"}
{"Docstring": "/**\n * @param String is the string to be checked\n * @param Int is the starting index of the string in consideration\n * @param Int is the ending index of the string in consideration\n * @return minimum number of partitions required\n **/", "Modifier": "", "Signature": "fun palindromePartition(string: String, i: Int, j: Int): Int", "Body": "{\n    if (i >= j) {\n        return 0\n    }"}
{"Docstring": "/**\n * memoization table\n **/\nlateinit var dp: Array<Array<Int>>\n\n\n/**\n * @param String the string on which algorithm is to be operated\n */", "Modifier": "", "Signature": "fun initialize(string: String): Int", "Body": "{\n    dp = Array(string.length) { Array(string.length) { -1 }"}
{"Docstring": "/**\n * Calculates the median of an array of Int\n *\n * @param values is an array of Int\n * @return the middle number of the array\n */", "Modifier": "", "Signature": "fun median(values: IntArray): Double", "Body": "{\n    sort(values)\n    return when {\n        values.size % 2 == 0 -> getHalfwayBetweenMiddleValues(values)\n        else -> getMiddleValue(values)\n    }"}
{"Docstring": "/**\n * Calculates the middle number of an array when the size is an even number\n *\n * @param values is an array of Int\n * @return the middle number of the array\n */", "Modifier": "private ", "Signature": "fun getHalfwayBetweenMiddleValues(values: IntArray): Double", "Body": "{\n    val arraySize = values.size\n    val sumOfMiddleValues = (values[arraySize / 2] + values[(arraySize / 2) - 1 ])\n    return sumOfMiddleValues / 2.0\n}"}
{"Docstring": "/**\n * Calculates the middle number of an array when the size is an odd number\n *\n * @param values is an array of Int\n * @return the middle number of the array\n */", "Modifier": "private ", "Signature": "fun getMiddleValue(values: IntArray): Double", "Body": "{\n    return values[values.size / 2].toDouble()\n}"}
{"Docstring": "/**\n * Calculates the factorial of a natural number greater than or equal to 0 recursively.\n * @param number The number of which to calculate the factorial.\n * @return The factorial of the number passed as parameter.\n */", "Modifier": "", "Signature": "fun getFactorial(number: Long): Long", "Body": "{\n    if (number < 0L) {\n        throw InvalidParameterException(\"The number of which to calculate the factorial must be greater or equal to zero.\")\n    }"}
{"Docstring": "/**\n * Approach 1: Brute Force\n *\n * Complexity Analysis:\n *\n * Time complexity: O(n^2)\n * Space complexity: O(1)\n *\n * Try all the pairs in the array and see if any of them add up to the target number.\n * @param nums Array of integers.\n * @param target Integer target.\n * @return Indices of the two numbers such that they add up to target.\n */", "Modifier": "", "Signature": "fun twoSum(nums: IntArray, target: Int): IntArray", "Body": "{\n    for (index1 in nums.indices) {\n        val startIndex = index1 + 1\n        for (index2 in startIndex..nums.lastIndex) {\n            if (nums[index1] + nums[index2] == target) {\n                return intArrayOf(index1, index2)\n            }"}
{"Docstring": "/**\n * Calculate the average of a list of Double\n *\n * @param numbers array to store numbers\n * @return average of given numbers\n */", "Modifier": "", "Signature": "fun average(numbers: Array<Double>): Double", "Body": "{\n    var sum = 0.0\n    for (number in numbers) {\n        sum += number\n    }"}
{"Docstring": "/**\n * Calculate the average of a list of Int\n *\n * @param numbers array to store numbers\n * @return average of given numbers\n */", "Modifier": "", "Signature": "fun average(numbers: Array<Int>) : Int", "Body": "{\n    var sum = 0\n    for (number in numbers) {\n        sum += number\n    }"}
{"Docstring": "/**\n * Interpolation search is an algorithm which finds the position of a target value within an array (Sorted)\n *\n * Worst-case performance\tO(n)\n * Best-case performance\tO(1)\n * Average performance\tO(log log n)\n * Worst-case space complexity\tO(1)\n */\n\n/**\n * @param arr is an array where the element should be found\n * @param lo array starting index\n * @param hi array ending index\n * @param x is an element which should be found\n * @return index of the element\n */", "Modifier": "", "Signature": "fun interpolationSearch(arr: IntArray, lo: Int,\n                        hi: Int, x: Int): Int", "Body": "{\n    val pos: Int\n\n    if (lo <= hi && x >= arr[lo] && x <= arr[hi]) {\n\n        pos = (lo\n                + ((hi - lo) / (arr[hi] - arr[lo])\n                * (x - arr[lo])))\n\n        if (arr[pos] == x) return pos\n\n        if (arr[pos] < x) return interpolationSearch(arr, pos + 1, hi,\n                x)\n\n        if (arr[pos] > x) return interpolationSearch(arr, lo, pos - 1,\n                x)\n    }"}